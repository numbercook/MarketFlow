## ams_version=1.0

Model Main_MarketFlow {
    Section Main_Procedures {
        Parameter IsEndUserMode {
            Range: binary;
            Default: 1;
            Property: NoSave;
        }
        Parameter IsDeveloperMode {
            Range: binary;
            Property: NoSave;
            Definition: 1 $ ProjectDeveloperMode;
        }
        Parameter RegularUserMode {
            Range: binary;
            Default: 1;
        }
        Parameter HideWarnings {
            Range: binary;
            Default: 1;
        }
        Set Periods {
            Index: term, ti, tj;
            Parameter: _term;
            Definition: {
                !data { 1 .. 3 }
                 !{ 1 .. NumberPeriods }
            }
        }
        Set TimePeriods {
            SubsetOf: (Periods, Periods);
            Tags: (ts, tf);
            Text: "from ts to tf";
            Index: tp;
            Parameter: _AllPeriods, Current_tp;
            Definition: {
                { (ti,tj) | ord(ti) <= ord(tj) }
            }
        }
        Set TimePeriodsSingle {
            SubsetOf: TimePeriods;
            Text: "Timeperiods containing a single period";
            Index: tpS;
            Definition: {
                { tp | (tp.ts = tp.tf) }
            }
        }
        Set TimePeriodsMulti {
            SubsetOf: TimePeriods;
            Text: "Timeperiods containing multiple periods";
            Index: tpM;
            Parameter: Current_tpM;
            Definition: {
                { tp | (tp.ts < tp.tf) }
            }
        }
        ElementParameter _FirstTimePeriod {
            Text: "First Timeperiod with demand";
            Range: TimePeriods;
            Definition: {
                if count((dest,gPrGrp,tt,tp) | MillAllDemand_PrGrp(dest,gPrGrp,tt,tp)) > 0 then
                	First( tp | exists((dest,gPrGrp,tt) | MillAllDemand_PrGrp(dest,gPrGrp,tt,tp)))
                else
                	''!First(tp)
                endif
            }
        }
        Parameter NumberPeriods {
            Range: integer;
            Default: 4;
        }
        Procedure MainInitialization {
            Body: {
                !set flags based on user mode
                block ! set user options
                        if ProjectDeveloperMode then
                                IsEndUserMode := 0;
                                HideWarnings := 0;
                                RegularUserMode := 0;
                                if OptionSetString("warning_in_source_text","warning") <> 1 then
                                        dialogMessage("The option 'warning_in_source_text' is not valid.  Please contact Tenure support.","SFMM Internal Error");
                                endif;
                        else
                        		! set comment warnings off
                                if OptionSetString("warning_in_source_text","off") <> 1 then
                                        dialogMessage("The option 'warning_in_source_text' is not valid.  Please contact Tenure support.","SFMM Internal Error");
                                endif;
                            ! --- set user menu bar
                            if OptionSetString("menubar_for_project_window","Tenure Page Menubar") <> 1 then
                            	dialogMessage("The option 'menubar_for_project_window' is not valid.","WoodFlow Internal Error");
                            endif;
                        endif;
                endblock;
                
                block  !Assign AIMMS Version
                	if OptionGetString("Project title",ProjectVersion) <> 1 then
                			DialogMessage("The option 'Project title' is not valid.  Please contact MarketFlow support.","MarketFlow Internal Error");
                	else
                			AimmsRevisionString(AimmsVersion,3);
                
                			i := FindString(ProjectVersion,"AIMMS");
                			if i = 0 then ProjectVersion += " (AIMMS " + AimmsVersion + ")";
                			else ProjectVersion := SubString(ProjectVersion,1,i-1) + "AIMMS " + AimmsVersion + ")";
                			endif;
                
                		if OptionSetString("Project title",ProjectVersion) <> 1 then
                				DialogMessage("The option 'Project title' is not valid.  Please contact SFMM support.","SFMM Internal Error");
                		endif;
                
                	endif;
                endblock;
                
                ReadTooltips;	! read tooltips from project user file
                
                !Periods := { 1 .. NumberPeriods };
                _AllPeriods := stringToElement(TimePeriods, "('1','"+NumberPeriods+"')", 0);
                
                __Lower      := 'Lower' ;
                __Upper      := 'Upper' ;
                __min := 'Min';
                __max := 'Max';
                
                
                ! Initialize element parameters for SupplyZones
                __LowCost := 'LowCost';  __LowLim := 'LowLim';  __LowRec:='LowRec';
                __Recovery:='Recovery';  __Altern:='Altern';	__Tradeoff:='Tradeoff';
                __ZLowCost := 'LowCost';	__ZRecovery:='Recovery';	__zAltern:='Altern';  __ZTradeoff:='Tradeoff';
                
                
                !--Initialize Selector Descriptions
                SelectorDescription(sel) := FormatString("%e",sel);
                
                InitializeObjidElementParameters;
                
                !AutoResolvePages := data { 'Results', 'Results2' , 'Targets','General Targets' };
                
                InitializeParameterToExportSets;
                InitializeProduct;
                
                !switch (dialogAsk("Do you want to use dummy data?","Yes","No",title:"Enter Choice") ) do
                !        1:              InitializeTenureDummyData;
                !endswitch;
                !
                InitializeColourSetOrder;
                !GetPageNames;		Won't work here
                
                !--- Initialize Pivot Table State manager dataset
                !PTStateManager::InitializeStateData;
                
                InitializeUserGroupPermissions;
                
                !SetStartupPage;
            }
            StringParameter ProjectVersion;
            StringParameter AIMMSVersion;
            Parameter i;
        }
        Procedure MainStartup;
        Procedure MainExecution {
            Body: {
                nsm::SolveNSModel;
                !MainExecution_work("",0);
                
                !fro::BatchExecution;
            }
        }
        Procedure MainExecution_work {
            Arguments: (presolve_dumpfilename,dodump);
            Body: {
                MainTenureModelProcedure(presolve_dumpfilename,dodump);
            }
            StringParameter presolve_dumpfilename {
                Property: Input;
            }
            Parameter dodump {
                Range: binary;
                Property: Input;
            }
        }
        Procedure InitializeTenureDummyData {
            Body: {
                
                ManagementUnits := data {'ALGAWA','NSHORE','NIPPS'};
                
                !Blocks                  := data {'ALG0','ALG1','ALG2','NSH0','NSH1','NSH2','NIP0','NIP1','NIP2'}        ;
                SetElementAdd(Blocks,Current_blk,"ALG0");
                        SetElementAdd(Blocks,Current_blk,"ALG1");
                        SetElementAdd(Blocks,Current_blk,"ALG2");
                        SetElementAdd(Blocks,Current_blk,"NSH0");
                        SetElementAdd(Blocks,Current_blk,"NSH1");
                        SetElementAdd(Blocks,Current_blk,"NSH2");
                        SetElementAdd(Blocks,Current_blk,"NIP0");
                        SetElementAdd(Blocks,Current_blk,"NIP1");
                        SetElementAdd(Blocks,Current_blk,"NIP2");
                
                MU_Block_Relation((mu,blk) | substring(mu,0,2) = substring(blk,0,2)) := 1;
                
                !Destinations    := data {'Mill1','Mill2','Mill3','Xall'};
                        SetElementAdd(Destinations,Current_dest,"Mill1");
                        SetElementAdd(Destinations,Current_dest,"Mill2");
                        SetElementAdd(Destinations,Current_dest,"Mill3");
                        SetElementAdd(Destinations,Current_dest,"Xall");
                
                /* ************** PRODUCTS and RESIDUALS **************** */
                InitializeProduct;
                
                
                /* ************** INITIALIZE VOLUME & Mill Demand **************** */
                InitialGS(blk,prd) := 100;
                
                SetTargets;
                
                        InitializeHaulTimes;
                return;
            }
        }
        Procedure InitializeProduct {
            Body: {
                block !Products & Residuals
                
                        empty AllProducts;
                                setElementAdd(Products,Current_prd,"Pwrlog");
                        SetElementAdd(Products,Current_prd,"Pwr");
                        SetElementAdd(Products,Current_prd,"SPFlog");
                        SetElementAdd(Products,Current_prd,"SPF");
                        SetElementAdd(Products,Current_prd,"OC");
                        SetElementAdd(Products,Current_prd,"Polog");
                        SetElementAdd(Products,Current_prd,"Po");
                        SetElementAdd(Products,Current_prd,"Bwlog");
                        SetElementAdd(Products,Current_prd,"Bw");
                        SetElementAdd(Products,Current_prd,"Thlog");
                        SetElementAdd(Products,Current_prd,"Th");
                
                        SetElementAdd(Residuals,Current_res,"Chips");
                        SetElementAdd(Residuals,Current_res,"Chips_Con");
                        SetElementAdd(Residuals,Current_res,"Chips_Hwd");
                        SetElementAdd(Residuals,Current_res,"Sawdust");
                        SetElementAdd(Residuals,Current_res,"Bark");
                endblock;
                
                block        ! Define Product Groups & Residual Groups
                        empty AllProductGroups;
                        SetElementAdd(AllProductGroups,_gPrGrp,"AllInputs");
                        SetElementAdd(ProductGroups,Current_PrGrp,"AllProd");
                        SetElementAdd(ResidualGroups,Current_ResGrp,"AllRes");
                
                                for (gProd in Products) do
                                        !Current_prg := ElementCast(ProductGroups,gProd,1);
                                        SetElementAdd(ProductGroups,Current_PrGrp,gprod);
                                endfor;
                
                        SetElementAdd(ResidualGroups,Current_ResGrp,"Chips");
                        SetElementAdd(ResidualGroups,Current_ResGrp,"Chips_Con");
                        SetElementAdd(ResidualGroups,Current_ResGrp,"Chips_Hwd");
                        SetElementAdd(ResidualGroups,Current_ResGrp,"Sawdust");
                        SetElementAdd(ResidualGroups,Current_ResGrp,"Bark");
                endblock;
                
                block ! Initialize product groups
                    empty cPrG;
                        cPrG(('AllInputs',gprod) ) :=1;
                        cPrG(('AllProd',prd) ) :=1;
                        cPrG(('AllRes',res) ) :=1;
                    cPrG((PrGrp,ElementCast(Products,PrGrp,0))) := 1;
                    cPrG((ResGrp,ElementCast(Residuals,ResGrp,0))) := 1;
                
                    SetElementAdd(ProductGroups,Current_PrGrp,"AllCon");
                        cPrG(('AllCon',prd) | prd='Pwrlog' or prd='Pwr' or prd='SPFlog' or prd='SPF' or prd='OC') :=1;
                    SetElementAdd(ProductGroups,Current_PrGrp,"AllHwd");
                    	cPrG(('AllHwd',prd) | prd='Polog' or prd='Po' or prd='Bwlog' or prd='Bw' or prd='Th' or prd='THLog') :=1;
                
                    ! Residuals
                    cPrG(('Chips',Res) | res='Chips_Con' or res='Chips_Hwd') := 1;
                
                endblock;
                
                block ! Product units
                	for (gpr in Products) do
                		ProductUnit := data { gpr : [m3] } ;
                	endfor;
                
                	for (gpr in Residuals) do
                		ProductUnit := data { gpr : [ODT] } ;
                	endfor;
                
                		for (gPrGrp in ProductGroups) do
                		ProductGroupUnit := data { gPrGrp : [m3] } ;
                	endfor;
                
                	for (gPrGrp in ResidualGroups) do
                		ProductGroupUnit := data { gPrGrp : [ODT] } ;
                	endfor;
                endblock;
            }
        }
        Procedure InitializeHaulTimes {
            Body: {
                empty HaulTime;
                HaulTime(src,dest) := data {
                ! Mill1 Midway
                ! Mill2 Bonifer
                ! Mill3 Dom_esp
                (       ALG0    ,       Mill1   ):      1.36863833333333        ,
                (       ALG0    ,       Mill2   ):      2.31688333333333        ,
                (       ALG0    ,       Mill3   ):      3.00011666666667        ,
                (       ALG1    ,       Mill1   ):      5.25056666666667        ,
                (       ALG1    ,       Mill2   ):      4.25171666666667        ,
                (       ALG1    ,       Mill3   ):      7.2468  ,
                (       ALG2    ,       Mill1   ):      5.48125 ,
                (       ALG2    ,       Mill2   ):      4.48238333333333        ,
                (       ALG2    ,       Mill3   ):      7.47748333333333        ,
                (       NIP1    ,       Mill1   ):      5.8009  ,
                (       NIP1    ,       Mill2   ):      6.93188333333333        ,
                (       NIP1    ,       Mill3   ):      3.8804  ,
                (       NIP2    ,       Mill1   ):      5.13801666666667        ,
                (       NIP2    ,       Mill2   ):      6.269   ,
                (       NIP2    ,       Mill3   ):      3.21751666666667        ,
                (       NIP0    ,       Mill1   ):      5.08213333333333        ,
                (       NIP0    ,       Mill2   ):      6.21311666666667        ,
                (       NIP0    ,       Mill3   ):      3.16163333333333        ,
                (       NSH0    ,       Mill1   ):      1.39665333333333        ,
                (       NSH0    ,       Mill2   ):      2.3278  ,
                (       NSH0    ,       Mill3   ):      3.01505 ,
                (       NSH1    ,       Mill1   ):      2.35573333333333        ,
                (       NSH1    ,       Mill2   ):      2.86376666666667        ,
                (       NSH1    ,       Mill3   ):      3.77253333333333        ,
                (       NSH2    ,       Mill1   ):      2.08725 ,
                (       NSH2    ,       Mill2   ):      2.59746666666667        ,
                (       NSH2    ,       Mill3   ):      3.49746666666667        ,
                
                (       Mill1   ,       Mill3   ):      2.5     ,
                (       Mill2   ,       Mill3   ):      3.1
                
                };
                
                /* Note: Zero means haultime() is true, 0.0 haultime() is false /**/
                
                haultime((blk,dest) | dest = 'Xall') := zero;
                haultime((destFrom,dest) | ProducesResiduals(destFrom) and dest = 'Xall') := zero;
            }
        }
        Procedure SetTargets {
            Body: {
                    empty UsesProducts,UsesResiduals ;
                    UsesProducts(dest) :=1;
                UsesResiduals(dest | dest = 'Mill3' or dest = 'XAll') :=1 ;
                
                    empty ProductsUsed_PrGrp;
                ProductsUsed_PrGrp('Mill1', 'Pwrlog') := 1;
                ProductsUsed_PrGrp('Mill2', 'Pwrlog') := 1;
                ProductsUsed_PrGrp('Mill2', 'SPFlog') := 1;
                ProductsUsed_PrGrp('Mill3', 'SPF') := 1;
                ProductsUsed_PrGrp('Xall', gPrGrp) := 1;
                
                    empty ProducesResiduals;
                ProducesResiduals('Mill1') := 1;
                ProducesResiduals('Mill2') := 1;
                
                    empty ResidualsProduced;
                ResidualsProduced('Mill1','Pwrlog','Chips') := .67;
                ResidualsProduced('Mill2','Pwrlog','Chips') := .67;
                ResidualsProduced('Mill2','SPFlog','Chips') := .6;
                
                    empty ResidualsUsed_PrGrp;
                ResidualsUsed_PrGrp('Mill3', 'Chips') := 1;
                    ResidualsUsed_PrGrp('Xall', 'Allres') := 1;
                
                ! Mill Demand ==============================================
                empty MillDemand,MillDemand_PrGrp,MillResidualDemand_PrGrp;
                MillDemand_PrGrp('Mill1','Pwrlog',__min,_AllPeriods) := 1e2;
                MillDemand_PrGrp('Mill2','Pwrlog',__min,_AllPeriods) := 1e2;
                MillDemand_PrGrp('Mill2','SPFlog',__min,_AllPeriods) := 1e2;
                MillDemand_PrGrp('Mill3','SPF',__min,_AllPeriods) := 1e2;
                MillResidualDemand_PrGrp('Mill3','Chips',__min,_AllPeriods) := 1e2;
                
                !EquivalentProducts((prIN,prOUT) | prIN = prOUT) :=1;
                empty EquivalentProducts;
                EquivalentProducts((prIN,prOUT) | FindString(prIN,prOUT) =1) :=1 ;
            }
        }
        Procedure MainTermination {
            Body: {
                    if OptionSetString("Startup_page","Main Dashboard") <> 1 then
                            DialogMessage("The option 'Startup_page' is not valid.  Please contact WoodFlow support.","WoodFlow Internal Error");
                    endif;
                !if ( CaseSaveAll( confirm:2 ) = 1 ) then
                !    return 1;
                !else
                !    return 0;
                !endif ;
                !
                return 1;
            }
        }
        Procedure OpenMainPageByUser {
            Body: {
                InitializePageSet;
                PageClose;
                !DebuggerBreakpoint;
                !if not MainPageOpened and IsNotAuthorized(__ASolve) then
                if count(aact | IsAuthorized(aact) ) = count(aact | IsAuthorizedMatrix('MapOnly', aact))
                 and IsAuthorized(__AMap) then
                	PageOpenSingle("Map Primary");
                else
                	PageOpenSingle("NEW Main Page");
                endif;
                
                MainPageOpened := 1;
                
                !-- set the Startup Page Option so that it points to the proper page .... could be done in if statement above
                SetStartupPage;
                return 1;
            }
        }
        Procedure SetStartupPage {
            Body: {
                ! set Startup Page
                !OptionGetString("Startup_page",str);
                !DialogMessage("Current Startup Page is '" + str + "'");
                
                if count(aact | IsAuthorized(aact) ) = count(aact | IsAuthorizedMatrix('MapOnly', aact))
                 and IsAuthorized(__AMap) then
                    if OptionSetString("Startup_page","Map Primary") <> 1 then
                            DialogMessage("The option 'Startup_page' is not valid.  Please contact WoodFlow support.","WoodFlow Internal Error");
                    endif;
                else
                    if OptionSetString("Startup_page","NEW Main Page") <> 1 then
                            DialogMessage("The option 'Startup_page' is not valid.  Please contact WoodFlow support.","WoodFlow Internal Error");
                    endif;
                
                endif;
                
                !    if OptionSetString("Startup_page","MAP Main Page") <> 1 then
                !            DialogMessage("The option 'Startup_page' is not valid.  Please contact WoodFlow support.","WoodFlow Internal Error");
                !    endif;
                
                !OptionGetString("Startup_page",str);
                !DialogMessage("Current Startup Page is '" + str + "'");
            }
            StringParameter str;
        }
    }
    Section units {
        DeclarationSection Unit_Declarations {
            Quantity SI_Volume {
                BaseUnit: m3 = m^3;
                Conversions: {
                    MBM   -> m3 : # -> # * 2.359737,
                    k_m3  -> m3 : # -> # * 1000,	! '000 m3
                    ODT   -> m3 : # -> # * 2,		! Oven-dry tonnes
                    tn    -> m3 : # -> # * 2,		! Oven-dry tonnes
                    k_ODT -> m3 : # -> # * 2000,	! '000 ODT
                    MW	  -> m3 : # -> # * 1		! MegaWatt
                }
                Comment: "Expresses the value of solid content.";
            }
            Quantity SI_Length {
                BaseUnit: m;
                Comment: "Expresses the value of a distance.";
            }
            Quantity km {
                BaseUnit: m;
                Conversions: km -> m : # -> # * 1000;
            }
            Quantity kmPERm3 {
                BaseUnit: km/m3;
            }
            Quantity Wght {
                BaseUnit: -;
                Comment: "Expresses a dimensionless value.";
            }
            Quantity Unitless {
                BaseUnit: 1;
                Conversions: % -> 1 : # -> # / 100;
            }
            UnitParameter _Percent {
                Quantity: Unitless;
                InitialData: [%];
            }
            Quantity PerDistVol {
                BaseUnit: m4;
            }
            Quantity SI_Time_Duration {
                BaseUnit: s;
                Conversions: {
                    hour   -> s : # -> # * 3600,
                    minute -> s : # -> # * 60
                }
                Comment: "Expresses the value for the duration of periods.";
            }
            UnitParameter _h {
                Quantity: SI_Time_Duration;
                Property: NoSave;
                Definition: [hour];
            }
            Quantity Dollar {
                BaseUnit: $;
                Conversions: {
                    k$ -> $ : # -> # * 1000,
                    M$ -> $ : # -> # * 1000000
                }
            }
            Quantity CostPerHour {
                BaseUnit: $/hour;
            }
            Quantity CostPerM3 {
                BaseUnit: $/m3;
            }
            UnitParameter ProductUnit {
                IndexDomain: (gpr);
                Quantity: SI_Volume;
                Default: [m3];
            }
            UnitParameter ProductUnit_k {
                IndexDomain: (gpr);
                Quantity: SI_Volume;
                Default: [k_m3];
                Definition: {
                    if ProductUnit(gPr) = [m3] then [k_m3]
                    elseif ProductUnit(gPr) = [ODT] then [k_ODT]
                    else [m3] endif
                }
            }
            UnitParameter _ProductDefaultUnit {
                Quantity: SI_Volume;
                InitialData: [m3];
            }
            UnitParameter _ProductDefaultUnit_k {
                Quantity: SI_Volume;
                InitialData: [k_m3];
            }
            UnitParameter _ResidualDefaultUnit {
                InitialData: [ODT];
            }
            UnitParameter _ResidualDefaultUnit_k {
                InitialData: [k_ODT];
            }
            UnitParameter ProductGroupUnit {
                IndexDomain: (gPrGrp);
                Quantity: SI_Volume;
                Default: [m3];
            }
            UnitParameter ProductGroupUnit_k {
                IndexDomain: (gPrGrp);
                Quantity: SI_Volume;
                Default: [k_m3];
                Definition: {
                    if ProductGroupUnit(gPrGrp) = [m3] then [k_m3]
                    elseif ProductGroupUnit(gPrGrp) = [ODT] then [k_ODT]
                    else [m3] endif
                }
            }
            Assertion Assert_AllProductsHaveUnits {
                IndexDomain: gPrGrp;
                Text: "Product group gPrGrp needs a unit";
                AssertLimit: 1;
                Definition: {
                    !Warning: didn't work without FormatString()
                    FormatString("%u", ProductGroupUnit(gPrGrp)) <> ""
                }
                Action: {
                    !switch(DialogAsk(
                    !	message : FormatString("%e has no unit '%u'\n\nEdit Units?",gPrGrp, ProductGroupUnit(gPrGrp))  ,
                    !	button1 : "Yes", 	button2 : "No", button3:"Ignore", 	title : "Missing Units")) do
                    !	1: 	TabbedPage('General Data') := "Product Groups";
                    !		PageOpen("General Data");
                    !		!PageSetFocus(page : "General Data", tag : "Product Groups::UnitsOfMeasure");
                    !	2: halt;
                    !	3:
                    !endswitch;
                }
            }
            Parameter ImpedanceDistanceEquivalent {
                Range: nonnegative;
                Unit: km/m3;
                InitialData: 1;
            }
            Set LimitType {
                Index: limit;
                Parameter: __Lower, __Upper;
                InitialData: data { 'lower','upper' };
            }
        }
        Procedure CheckProductUnits {
            Body: {
                assert Assert_AllProductsHaveUnits;
            }
        }
    }
    Section QA {
        Section AddSetElementTrouble {
            Procedure QA_AddSetElement {
                Body: {
                    ! This procedure calls functions to add a new element to the set "Products"
                    ! it should also add this new element to AllProducts since Products is a subset of Products
                    ! the procedure mimics the + - buttons on various pages and dthe subsequent call to page Add_SetElement
                    DebuggerBreakpoint;
                    SetName := "Products";
                    NewElementName := "tstPrd";
                    
                    block !First we try to add the element to Products using SetElementAdd directly
                    	SetElementAdd( 	Setname : Products,  	Elempar : Current_prd, 	Newname : NewElementName);
                    
                    	! the element should exist in the root set, AllProducts
                    	if StringToElement( Set : AllProducts,	Name : NewElementName, 	Create : 0) = '' then
                    		DialogMessage(FormatString("'%s' not found in AllProducts",NewElementName),"Failure");
                    	else DialogMessage(FormatString("'%s' found in AllProducts",NewElementName),"Success");
                    		Allproducts -= ElementCast( Set : AllProducts,	Element : Current_prd,	Create : 0);
                    	endif;
                    
                    	!make sure Products contains no extra elements
                    	cleandependents AllProducts;
                    endblock;
                    
                    block !Now we try to do it using the AddSetMember function
                    	AddSetMember;
                    
                    	!check if new element in Products
                    	if StringToElement( Set : Products,	Name : NewElementName, 	Create : 0) = '' then
                    		DialogMessage(FormatString("'%s' not found in Products",NewElementName),"Failure");
                    	else DialogMessage(FormatString("'%s' found in Products",NewElementName),"Success");
                    	endif;
                    
                    	!check if new element in AllProducts (root set)
                    	if StringToElement( Set : AllProducts,	Name : NewElementName, 	Create : 0) = '' then
                    		DialogMessage(FormatString("'%s' not found in AllProducts",NewElementName),"Failure");
                    	else DialogMessage(FormatString("'%s' found in AllProducts",NewElementName),"Success");
                    		Allproducts -= ElementCast( Set : AllProducts,	Element : Current_prd,	Create : 0);
                    	endif;
                    
                    	cleandependents AllProducts;
                    endblock;
                }
            }
        }
    }
    Section WFlow_Model_Section {
        Section Section_1__Inputs {
            DeclarationSection Selectors_Declaration {
                Set Selectors {
                    Index: sel;
                    Definition: {
                        ! NOTE: If you edit the elements, you must also edit the corresponding element parameters
                        {
                        'Hide Feasible Targets'		! in infeasibility analysis, show only infeasibilities
                        ,'Include Only Available Blocks'	! InitialGS considered only for available blocks
                        ,'Include Only Available Mills'	! Exclude mills that are not IncludeMill(dest)
                        ,'Meet Volume Targets'		! include upper/lower mill demand (turn off for simulate trees
                        ,'Use Threshold Penalties'              ! Sector-based penalties for multiple thresholds
                         ,'Simulate TREES'			! include constraints related to total flow to each Dest
                        ,'Simulate TREES by MU'		! include constraints related to flow from MU to Dest
                        ,'Ignore Invalid TREES Targets'	!Too Far, wrong species, etc
                        ,'Set upper targets to lower'	! _max Trees and Mill Demand targets are set to _min unless otherwise specified
                        ,'Binary Mills'				! lp decides which mills receive wood
                        ,'Force Mills Selected'			! with 'Binary Mills', then MillAlwaysAvailable(dest) is selected
                        ,'Scale up volume in available blocks'	!only for available blocks, InitialGS multiplied by factor
                         ,'Even-Flow Delivered Volume'			! volume delivered to dest can fluctuate within certain bounds
                         ,'Value Covers Cost'			! Product Value Exceeds WoodCost
                         ,'Cost Centre Balance'	! Product Value exceeds woodcost for cost centres
                         ,'Residual Flow Targets'	! Volume of residual that must be sent from DestFrom to DestTo
                         ,'HaulTime As Cost'		! haulTimes are costs
                         ,'Uncertainty'		!uncertain GS
                        }
                    }
                }
                StringParameter SelectorDescription {
                    IndexDomain: (sel);
                    Property: NoSave;
                }
                Parameter Selectors_Order {
                    IndexDomain: sel;
                    Property: NoSave;
                    Definition: {
                          {'Include Only Available Blocks'	:	1
                        ,'Include Only Available Mills'		:	2
                        ,'Meet Volume Targets'				:	3
                        ,'Use Threshold Penalties'          :	3.1
                         ,'Residual Flow Targets'			:	4
                         ,'Simulate TREES'					:	5
                        ,'Simulate TREES by MU'				:	5.1
                        ,'Ignore Invalid TREES Targets'		:	5.2
                        ,'Set upper targets to lower'		:	3.3
                        ,'Binary Mills'						:	8
                        ,'Force Mills Selected'				:	8.1
                        ,'Scale up volume in available blocks'	:	9
                         ,'Even-Flow Delivered Volume'			:	10
                         ,'Value Covers Cost'				:	12
                         ,'Cost Centre Balance'				:	13
                         ,'HaulTime As Cost'				:	15
                        ,'Hide Feasible Targets'				: 25
                        ,'Uncertainty'						: 30
                        }
                    }
                }
                Parameter Selectors_Input {
                    IndexDomain: sel;
                    Range: binary;
                    Property: NoSave;
                    Definition: {
                        ! 1 if input not allowed
                        if sel = __EvenFlow then
                        	if exists( (dest, gPrGrp, tpM) | EvenFlowDeliver(dest, gPrGrp, tpM)) then 0 else 1 endif
                        else 0
                        endif
                    }
                }
                ElementParameter Selectors_Colour {
                    IndexDomain: (sel);
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                          {'Include Only Available Blocks'	:	'white'		! 	1
                        ,'Include Only Available Mills'		:	'white'		! 	2
                        ,'Meet Volume Targets'				:	'green'		! 	3
                        ,'Use Threshold Penalties'          :	'green'		! 	3.1
                         ,'Residual Flow Targets'			:	'white'		! 	4
                         ,'Simulate TREES'					:	'Yellow'	! 	5
                        ,'Simulate TREES by MU'				:	'Yellow'	! 	5.1
                        ,'Ignore Invalid TREES Targets'		:	'Yellow'	! 	5.2
                        ,'Set upper targets to lower'		:	'green'	! 	3.3
                        ,'Binary Mills'						:	'corresponding'	! 	8
                        ,'Force Mills Selected'				:	'corresponding'	! 	8.1
                        ,'Scale up volume in available blocks'	:	'white'	! 	9
                         ,'Even-Flow Delivered Volume'			:	'white'	! 	10
                         ,'Value Covers Cost'				:	'white'		! 	12
                         ,'Cost Centre Balance'				:	'white'		! 	13
                         ,'HaulTime As Cost'				:	'white'		! 	15
                        ,'Hide Feasible Targets'			:	'white'		!  25
                        }
                    }
                }
                Set ExecutionSelectors {
                    SubsetOf: Selectors;
                    Index: ExSel;
                    Property: NoSave;
                    OrderBy: Selectors_Order(sel);
                    Definition: {
                        Selectors - GUISelectors
                        - {__ScaleUpAvailableGs}
                        - { __ThresholdPenalties } 	$ (not IsSelected(__MeetVolumeTargets))
                        - { __ForceMillsSelected }	$ (not IsSelected(__BinaryMills))
                        - { __SetUpperTargets }		$ (not IsSelected(__MeetVolumeTargets)
                        								and not IsSelected(_SimulateTREES)
                        								and not IsSelected(__SimulateTREESByMU))
                        - { __IgnoreInvalidTreesTargets }
                        !							$ (not IsSelected(_MeetVolumeTargets)
                        !								and not IsSelected(_SimulateTREES)
                        !								and not IsSelected(_SimulateTREESByMU)
                        !								)
                        - { __SimulateTREESByMU }	$ (not IsSelected(_SimulateTREES))
                    }
                }
                Set GUISelectors {
                    SubsetOf: Selectors;
                    Property: NoSave;
                    Definition: {
                        {'Hide Feasible Targets', 'HaulTime As Cost' }
                    }
                }
                Parameter IsSelected {
                    IndexDomain: (sel);
                    Range: binary;
                }
                ElementParameter __HideFeasible {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Hide Feasible Targets';
                }
                ElementParameter _SimulateTREES {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Simulate TREES';
                }
                ElementParameter __SimulateTREESByMU {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Simulate TREES by MU';
                }
                ElementParameter __IgnoreInvalidTreesTargets {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Ignore Invalid TREES Targets';
                }
                ElementParameter __MeetVolumeTargets {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Meet Volume Targets';
                }
                ElementParameter __BinaryMills {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Binary Mills';
                }
                ElementParameter __ForceMillsSelected {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Force Mills Selected';
                }
                ElementParameter __IncludeOnlyAvailableBlocks {
                    Text: "Include Only Available Blocks";
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Include Only Available Blocks';
                }
                ElementParameter __IncludeOnlyAvailableMills {
                    Text: "Include Only Available Mills";
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Include Only Available Mills';
                }
                ElementParameter __SetUpperTargets {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Set upper targets to lower';
                }
                ElementParameter __ScaleUpAvailableGs {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Scale up volume in available blocks';
                }
                ElementParameter __ThresholdPenalties {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Use Threshold Penalties';
                }
                ElementParameter __EvenFlow {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Even-Flow Delivered Volume';
                }
                ElementParameter __ValueCoversCost {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Value Covers Cost';
                }
                ElementParameter __CostCentreBalance {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Cost Centre Balance';
                }
                ElementParameter __ResidualFlowTargets {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'Residual Flow Targets';
                }
                ElementParameter __HaulTimeAsCost {
                    Range: Selectors;
                    Property: NoSave;
                    Definition: 'HaulTime As Cost';
                }
            }
            Section Sources_Destinations_and_Supply_Routes_README {
                Comment: {
                    "different Supply Routes are defined depending on availability, haultime, and products
                    
                    PotentialSupplyRoutes		src has prd required by dest
                    AvailableSupplyRoutes		src has available prd required by dest
                    AccessibleSupplyRoutes		src has available prd within MaxHaulTime distance required by dest
                    
                    TimePermittedSupplyRoutes	src has prd within distance, but not time
                    TimePermittedRoutesForProducts
                    							src has prd within distance and time"
                }
                DeclarationSection Sources_and_Destinations {
                    Set AllLocations {
                        Text: "All Destinations and Sources";
                        Index: loc, locFrom, locTo;
                        Parameter: _loc;
                    }
                    Assertion Assert_MusPerBlock {
                        IndexDomain: blk;
                        Text: "Block \'blk\' must be associated with a single mu";
                        Definition: count(mu|MU_Block_Relation(mu,blk)) = 1;
                    }
                    Set AllSources {
                        SubsetOf: AllLocations;
                        Index: src, src1, src2;
                        Parameter: Copy_SourceFrom, Copy_SourceTo, _src;
                        Definition: {
                            !blocks + destinations | ProducesResiduals
                            { blk } + { dest | ProducesResiduals(dest) }
                        }
                    }
                    Set MUSources {
                        SubsetOf: AllSources;
                        Index: MuSrc, MuSrc1;
                        Parameter: _musrc;
                        OrderBy: musrc;
                        Definition: {
                            { blk }
                        }
                    }
                    Set MillSources {
                        SubsetOf: AllSources;
                        Index: MillSrc;
                        Definition: {
                            { dest | ProducesResiduals(dest) }
                        }
                    }
                    ElementParameter MillSector {
                        IndexDomain: (dest);
                        Range: Sectors;
                        Definition: first(sect | cMillSector(sect,dest));
                    }
                    ElementParameter _CurrentMillSector {
                        Range: Sectors;
                        Property: NoSave;
                        Definition: {
                            if current_mill then
                            	first(sect | cMillSector(sect,current_mill))
                            else
                            	first(sect)
                            endif
                        }
                    }
                    Set SourceTypes {
                        Index: iSrcType;
                        Property: NoSave;
                        Definition: data { 'MU' , 'Mill' };
                    }
                    ElementParameter SourceGrp {
                        IndexDomain: (src);
                        Range: SourceTypes;
                        Definition: {
                            if src in MUSources then 'MU'
                            elseif src in MillSources then 'Mill'
                            endif
                        }
                    }
                }
                DeclarationSection Supply_Routes_Declaration {
                    Set PotentialSupplyRoutes {
                        SubsetOf: (AllSources, Destinations);
                        Tags: (vsrc, vdest);
                        Text: "All sources that can supply destinations";
                        Index: iSrcDest;
                        Property: NoSave;
                        Definition: {
                            { (src,dest) |
                             exists (gprod |
                             ( ProductsUsed(dest,gprod) and  InitialGS(src,gProd) )   ! source has initial volume (blocks)
                            or ( ResidualsUsed(dest,gprod) and  InitialGS(src,gProd) )   ! ... for ResGrp that contain prd
                            or ( ResidualsUsed(dest,gProd)  and sum(prd,ResidualsProduced(src,prd,gProd)) ) ! source produces residuals
                            )
                            }
                        }
                    }
                    Set AvailableSupplyRoutes {
                        SubsetOf: PotentialSupplyRoutes;
                        Text: "src has AVAILBLE gProd required by dest (but not necessarily within time required)";
                        Property: NoSave;
                        Definition: {
                             { (src,dest)  | dest in AvailableDest
                            and (src in AvailableDest or src in AvailableBlocks)
                             and [ (src,dest) in PotentialSupplyRoutes ]			! <-- This should be redundant
                            
                             }
                        }
                        Comment: {
                            "!and exists (gprod |
                            !		( ProductsUsed(dest,gprod) and  GsAvailable(src,gProd) )   ! source has initial volume (blocks)
                            !		or ( ResidualsUsed(dest,gprod) and  GsAvailable(src,gProd) )   ! ... for ResGrp that contain prd
                            !		or ( ResidualsUsed(dest,gProd)  and sum(prd,ResidualsProduced(src,prd,gProd)) ) ! source produces residuals
                            !		)"
                        }
                    }
                    Set TimePermittedSupplyRoutes {
                        SubsetOf: PotentialSupplyRoutes;
                        Text: "src has gProd required by dest within time required";
                        Property: NoSave;
                        Definition: {
                            {  iSrcDest |  HaulTime(iSrcDest) $<= MaxAllowedHaultime }
                        }
                        Comment: {
                            "!and exists (gprod |
                            !		( ProductsUsed(dest,gprod) and  GsAvailable(src,gProd) )   ! source has initial volume (blocks)
                            !		or ( ResidualsUsed(dest,gprod) and  GsAvailable(src,gProd) )   ! ... for ResGrp that contain prd
                            !		or ( ResidualsUsed(dest,gProd)  and sum(prd,ResidualsProduced(src,prd,gProd)) ) ! source produces residuals
                            !		)"
                        }
                    }
                    Set XPotential_AvailableSupplyRoutes {
                        SubsetOf: PotentialSupplyRoutes;
                        Text: "src has AVAILBLE gProd required by dest (but not necessarily within time required)";
                        Property: NoSave;
                        Definition: PotentialSupplyRoutes - AvailableSupplyRoutes;
                        Comment: {
                            "!and exists (gprod |
                            !		( ProductsUsed(dest,gprod) and  GsAvailable(src,gProd) )   ! source has initial volume (blocks)
                            !		or ( ResidualsUsed(dest,gprod) and  GsAvailable(src,gProd) )   ! ... for ResGrp that contain prd
                            !		or ( ResidualsUsed(dest,gProd)  and sum(prd,ResidualsProduced(src,prd,gProd)) ) ! source produces residuals
                            !		)"
                        }
                    }
                    Set XPotential_TimePermittedSupplyRoutes {
                        SubsetOf: PotentialSupplyRoutes;
                        Text: "src has AVAILBLE gProd required by dest (but not necessarily within time required)";
                        Property: NoSave;
                        Definition: {
                            { (src,dest) | (src,dest)  in PotentialSupplyRoutes }
                            - { (src,dest) | (src,dest)  in TimePermittedSupplyRoutes }
                        }
                        Comment: {
                            "!and exists (gprod |
                            !		( ProductsUsed(dest,gprod) and  GsAvailable(src,gProd) )   ! source has initial volume (blocks)
                            !		or ( ResidualsUsed(dest,gprod) and  GsAvailable(src,gProd) )   ! ... for ResGrp that contain prd
                            !		or ( ResidualsUsed(dest,gProd)  and sum(prd,ResidualsProduced(src,prd,gProd)) ) ! source produces residuals
                            !		)"
                        }
                    }
                    Set TimePermittedRoutesForProducts {
                        SubsetOf: (AllSources,Destinations,AllProducts);
                        Property: NoSave;
                        Definition: {
                             { (src,dest,gProd)  | (src,dest) in TimePermittedSupplyRoutes and
                             (
                             ( ProductsUsed(dest,gprod) and  InitialGS(src,gProd) )   ! source has initial volume (blocks)
                            or ( ResidualsUsed(dest,gprod) and  InitialGS(src,gProd) )   ! ... for ResGrp that contain prd
                            or ( ResidualsUsed(dest,gProd)  and sum(gpr,ResidualsProduced(src,gpr,gProd)) ) ! source produces residuals
                             ) }
                        }
                    }
                    Set AvailableRoutesForProducts {
                        SubsetOf: (AllSources,Destinations,AllProducts);
                        Property: NoSave;
                        Definition: {
                             { (src,dest,gProd)  | (src,dest) in AvailableSupplyRoutes and
                             (
                             ( ProductsUsed(dest,gprod) and  InitialGS(src,gProd) )   ! source has initial volume (blocks)
                            or ( ResidualsUsed(dest,gprod) and  InitialGS(src,gProd) )   ! ... for ResGrp that contain prd
                            or ( ResidualsUsed(dest,gProd)  and sum(gpr,ResidualsProduced(src,gpr,gProd)) ) ! source produces residuals
                             ) }
                        }
                    }
                    Set AccessibleSupplyRoutes {
                        SubsetOf: AvailableSupplyRoutes;
                        Property: NoSave;
                        Definition: {
                            !{  iSrcDest |  HaulTime(iSrcDest) $<= MaxAllowedHaultime
                            !! and iSrcDest in AvailableSupplyRoutes 			! <-- This should be redundant
                            !}
                            
                            AvailableSupplyRoutes * TimePermittedSupplyRoutes
                        }
                        Comment: {
                            "SEE PAGE \'TEST Subests\'
                            ! same as ...
                             !{ (src,dest)  | ... and ( HaulTime(src,dest) ) and (HaulTime(src,dest) <= MaxAllowedHaultime ) }"
                        }
                    }
                    Set RogueSupplyRoutes {
                        SubsetOf: PotentialSupplyRoutes;
                        Property: NoSave;
                        Definition: {
                            { (src,dest)  | (src,dest) in AccessibleSupplyRoutes
                            					and ( not (src,dest) in AvailableSupplyRoutes )
                            }
                        }
                        Comment: {
                            "prod | ResidualsUsed(dest,gProd)  and sum(gpr,ResidualsProduced(src,gpr,gProd)) ) ) ! source produces residuals"
                        }
                    }
                    Parameter ValidRoutes {
                        IndexDomain: (src,dest) | HaulTime(src,dest) and [HaulTime(src,dest) <= MaxAllowedHaultime];
                        Property: NoSave;
                        Definition: 1;
                    }
                    Parameter ValidRoutesProduct {
                        IndexDomain: {
                            (src,dest,gProd)| ValidRoutes(src,dest)  and (
                             ( ProductsUsed(dest,gprod) and  InitialGS(src,gProd) )   ! source has initial volume (blocks)
                            or ( ResidualsUsed(dest,gProd)  and sum(prd,ResidualsProduced(src,prd,gProd)) ) ! source produces residuals
                             )
                        }
                        Property: NoSave;
                        Definition: 1;
                    }
                    Parameter IsValidResidualDelivery_Dom {
                        IndexDomain: {
                            (destFrom,res,DestTo,ResGrp)| (destFrom,DestTo,res)  in TimePermittedRoutesForProducts
                            !!amd [ (destFrom,DestTo) in PermittedRoutes ]
                            !!and destFrom <> DestTo
                            and destFrom in AvailableDest and DestTo in AvailableDest
                            and  if IsSelected(__IncludeOnlyAvailableMills) then IncludeMill(DestTo) else 1 endif
                            and cPrG(ResGrp,res)
                            and ProducesResiduals(destFrom)
                            and UsesResiduals(destTo)
                            and sum[ gpr,ResidualsProduced(destFrom,gpr,res)]   !DestFrom produces res
                            and  ResidualsUsed_PrGrp(DestTo,ResGrp)             !DestTo uses ResGrp
                        }
                        Property: NoSave;
                        Definition: 1;
                    }
                    Assertion Assert_NoRogueSupplyRoutes {
                        Text: "Subset problem:  RogueSupplyRoutes is not empty";
                        AssertLimit: 1;
                        Definition: card(RogueSupplyRoutes) = 0;
                    }
                }
            }
            DeclarationSection Products_and_Residuals {
                Set AllProducts {
                    Text: "Products and residuals";
                    Index: gpr, gProd, prIN, prOUT;
                    Parameter: Current_gpr;
                }
                Set AllProductGroups {
                    Index: gPrGrp, gPrGrp2;
                    Parameter: _gPrGrp;
                }
                Set AllProductGroupsSingle {
                    SubsetOf: AllProductGroups;
                    Index: gPrGrpS;
                    Definition: ProductGroupsSingle + ResidualGroupsSingle;
                }
                Set AllProductGroupsMulti {
                    SubsetOf: AllProductGroups;
                    Index: gPrGrpM;
                    Definition: AllProductGroups - AllProductGroupsSingle;
                }
                Set Products {
                    SubsetOf: AllProducts;
                    Text: "Products, not residuals";
                    Index: prd;
                    Parameter: Current_prd;
                }
                Set ProductGroups {
                    SubsetOf: AllProductGroups;
                    Index: PrGrp, PrGrp1;
                    Parameter: Current_prg, Current_PrGrp;
                    InitialData: {
                        !data { AllProd }
                    }
                }
                Set ProductGroupsSingle {
                    SubsetOf: ProductGroups;
                    Text: "Product Groups containing single Product";
                    Index: PrGrpS;
                    Parameter: Current_PrGrpS;
                    Definition: {
                        { PrGrp | exists(gpr | StringToUpper(FormatString("%e",gpr)) = StringToUpper(FormatString("%e",PrGrp))) }
                    }
                }
                Set ProductGroupsMulti {
                    SubsetOf: ProductGroups;
                    Text: "Product Groups containing multiple Products";
                    Index: PrGrpM;
                    Parameter: Current_PrGrpM;
                    Definition: productgroups - ProductGroupsSingle;
                }
                Parameter cPrG {
                    IndexDomain: (gPrGrp,gpr);
                    Text: "Product (gpr) belongs to Product Group (gPrGrp)";
                    Range: binary;
                }
                Parameter PrGrpMwithPrGrpSingle {
                    IndexDomain: (gPrGrpM,gPrGrp);
                    Text: "Multiple Product Group that has species in common with another product group";
                    Range: binary;
                    Definition: {
                        1 $
                        exists ( gpr | cPrG(gPrGrp,gpr) and cPrG(gprgrpM,gpr) )
                    }
                    Comment: "dk: This is used to set even-flow domain restrictions";
                }
                Set Residuals {
                    SubsetOf: AllProducts;
                    Index: res;
                    Parameter: Current_res;
                }
                Set ResidualGroupProducts {
                    SubsetOf: AllProducts;
                    Text: "All products that can occur in residual groups";
                    Index: gRes;
                    Definition: {
                        ! this includes Residuals (res) as well as Products (prd) in complex residual groups, e.g. AllChips incl SPF and CHips
                        
                        Residuals + { prd | exists(ResGrp | cPrG(ResGrp,prd) ) }
                    }
                }
                Set ResidualGroups {
                    SubsetOf: AllProductGroups;
                    Index: ResGrp;
                    Parameter: Current_ResGrp;
                }
                Set ResidualGroupsSingle {
                    SubsetOf: ResidualGroups;
                    Text: "Product Groups containing single Product";
                    Index: ResGrpS;
                    Parameter: Current_ResGrpS;
                    Definition: {
                        { ResGrp | exists(gpr | StringToUpper(FormatString("%e",gpr)) = StringToUpper(FormatString("%e",ResGrp))) }
                    }
                }
                Set ResidualGroupsMulti {
                    SubsetOf: ResidualGroups;
                    Text: "Product Groups containing multiple Products";
                    Index: ResGrpM;
                    Parameter: Current_ResGrpM;
                    Definition: ResidualGroups - ResidualGroupsSingle;
                }
                Set TargetType {
                    Index: tt;
                    Parameter: __min, __max, _tt;
                    InitialData: {
                        { 'Min','Max' }
                    }
                }
                Parameter EquivalentProducts {
                    IndexDomain: (prIN,prOUT);
                    Text: "units of prOUT that can be replaced by 1 unit of prIN";
                }
                Assertion Assert_EquivalentProducts {
                    IndexDomain: (prIN);
                    Text: "Conversion must equal 1 for prIN -> prIN";
                    Definition: EquivalentProducts(prIN,prIn) = 1;
                }
            }
            Procedure XX_CustomAddProductGroups {
                Body: {
                    SetElementAdd(ProductGroups,Current_PrGrp,"Log_Con");
                    SetElementAdd(ProductGroups,Current_PrGrp,"Log_Hwd");
                    
                    SetElementAdd(Residuals,Current_res,"Chip_Con");
                    SetElementAdd(Residuals,Current_res,"Chip_Hwd");
                    SetElementAdd(ResidualGroups,Current_ResGrp,"Chip_Con");
                    SetElementAdd(ResidualGroups,Current_ResGrp,"Chip_Hwd");
                    
                    
                    cPrG('Chip_con','Chip_con') := 1;
                    cPrG('Chip_hwd','Chip_hwd') := 1;
                    cPrG('Chips','Chip_con') := 1;
                    cPrG('Chips','Chip_hwd') := 1;
                    cPrG('AllRes','Chip_con') := 1;
                    cPrG('AllRes','Chip_hwd') := 1;
                    !
                    !cPrG('AllProd','Chip_con') := 1;
                    !cPrG('AllProd','Chip_hwd') := 1;
                    
                    cPrG('AllInputs','Chip_con') := 1;
                    cPrG('AllInputs','Chip_hwd') := 1;
                    
                    cPrG('Log_con','Spflog') := 1;
                    cPrG('Log_con','Pwrlog') := 1;
                    cPrG('Log_hwd','Polog') := 1;
                    cPrG('Log_hwd','Bwlog') := 1;
                    cPrG('Log_hwd','Thlog') := 1;
                }
            }
            Procedure deleteProductGroups {
                Body: {
                    !ProductGroups -= 'Logs_Con';
                    !ProductGroups -= 'LogsHwd';
                    cleandependents AllProductGroups;
                }
            }
            Procedure RemoveUnusedGpr {
                Body: {
                    TempGpr := { gpr | not (Products(gpr) or Residuals(gpr) ) };
                    
                    AllProducts -= TempGpr;
                }
                Set TempGpr {
                    SubsetOf: AllProducts;
                }
            }
            DeclarationSection HaulTime_Costs_and_Values {
                Parameter HaulTime {
                    IndexDomain: (src,dest);
                    Unit: hour;
                    Default: 0;
                }
                Parameter My_HaulTimes {
                    IndexDomain: (millsrc,dest) | ProducesResiduals(millsrc) and UsesResiduals(dest);
                    Unit: hour;
                    Definition: HaulTime(millsrc,dest);
                }
                Parameter VolumePerLoad {
                    IndexDomain: (gProd);
                    Range: (0, 300);
                    Unit: ProductUnit(gProd);
                    Default: 44;
                }
                Parameter TruckRateDefault {
                    Unit: $/hour;
                    InitialData: 96.1;
                }
                Parameter TruckRate {
                    IndexDomain: (gProd);
                    Unit: $/hour;
                    InitialData: 96.1;
                }
                Parameter LoadingCostPerLoad {
                    IndexDomain: (gProd);
                    Unit: $;
                    InitialData: 112;
                }
                Parameter HaulCostPerUnit {
                    IndexDomain: (gProd);
                    Unit: $/ProductUnit(gProd);
                }
                Parameter CalculatedTotalCostPerUnit {
                    IndexDomain: {
                        (src,dest,gProd) | (src,dest) in PotentialSupplyRoutes
                         !and ((ProductsUsed(dest,gProd) or ResidualsUsed(dest,gProd)))
                    }
                    Text: "Total cost (per m3) of loading and transporting gProd from src to dest";
                    Unit: $/ProductUnit(gProd);
                    Definition: {
                        !if HaulTime(src,dest) then
                        !if xxxx(src,dest)=1 then
                        !	if IsSelected(_HaulTimeAsCost) then
                        !		HaulTime(src,dest) * 1 [ProductUnit(gprod)] / 1 [hour]
                        !	else
                        !		2 * HaulTime(src,dest) /$ VolumePerLoad(gProd) * TruckRate(gProd)
                        !		+ LoadingCostPerLoad(gProd) /$ VolumePerLoad(gProd)
                        !	endif
                        !else
                        !	999 [$/m3]
                        !endif
                    }
                    Comment: "Now calculated in procedure AssignCalculatedTotalCostPerUnit";
                }
                Parameter MaxAllowedHaultime {
                    Text: "Maximum allowed Haultime";
                    Range: nonnegative;
                    Unit: hour;
                    InitialData: 10;
                }
                Parameter ProductValue_Default {
                    IndexDomain: (gProd);
                    Text: "Value of 1 unit of gProd";
                    Unit: $/ProductUnit(gProd);
                    InitialData: {
                        !warning: MUST FIX Product Values
                        ! now populated via assertion Assert_ValueForAllProducts
                        !data {
                        !Pwrlog	: 40
                        !,Pwr	: 25
                        !,SPFlog	: 35
                        !,SPF	: 25
                        !,OC		: 20
                        !,Polog	: 40
                        !,Po		: 20
                        !,Bwlog	: 25
                        !,Bw		: 5
                        !,Th		: 5
                        !,THLog	: 40
                        !,Chips	: 20
                        !}
                    }
                    Comment: "dk: Feb 2010";
                }
                Parameter ProductValue {
                    IndexDomain: {
                        (dest,gProd) | [ ( ProductsUsed(dest, ElementCast(Products,gProd,0) )   )
                           or (ResidualsUsed(dest, ElementCast(ResidualGroupProducts,gProd,0) ) ) ]
                    }
                    Text: "Value of 1 unit of gProd";
                    Unit: $/ProductUnit(gProd);
                    InitialData: {
                        ! now populated via assertion Assert_ValueForAllProducts
                        !data {
                        !Pwrlog	: 40
                        !,Pwr	: 25
                        !,SPFlog	: 35
                        !,SPF	: 25
                        !,OC		: 20
                        !,Polog	: 40
                        !,Po		: 20
                        !,Bwlog	: 25
                        !,Bw		: 5
                        !,Th		: 5
                        !,THLog	: 40
                        !,Chips	: 20
                        !}
                    }
                    Comment: "dk: Feb 2010";
                }
                Assertion Assert_HaultimesForAllResiduals {
                    IndexDomain: {
                        (destFrom,res) | sum[prd,ResidualsProduced(destFrom,prd,res)]
                        and (IncludeMill(destfrom) $ IsSelected(__IncludeOnlyAvailableMills)  )
                    }
                    Text: "HaulTimes Missing: DestFrom has nowhere to send res";
                    AssertLimit: 1;
                    Definition: {
                        Exists( (DestTo) | (sum [(resgrp),HaulTime(destFrom,DestTo)
                        					$ IsValidResidualDelivery_Dom(destFrom,res,DestTo,ResGrp)]
                        					)
                        		)
                    }
                    Action: {
                        switch(DialogAsk(
                        	message : FormatString("%e has nowhere to send %e\n\nEdit Haultimes?",destfrom,res) ,
                        	button1 : "Yes", 	button2 : "No", button3:"Ignore", 	title : "Haultimes missing")) do
                        	1: PageOpen("[Data Page] HaulTime");
                        	2: halt;
                        	3:
                        endswitch;
                    }
                }
                Assertion Assert_HaultimesForAllDestinations {
                    IndexDomain: (dest);
                    Text: "HaulTimes Missing: Dest has no possible supply";
                    Property: WarnOnly;
                    AssertLimit: 1;
                    Definition: Exists( (src) | HaulTime(src,Dest)	);
                    Action: {
                        switch(DialogAsk(
                        	message : FormatString("%e has no sources\n\nEdit Haultimes?",dest) ,
                        	button1 : "Yes", 	button2 : "Stop", button3:"Ignore", 	title : "Haultimes missing")) do
                        	1: 		PageSetFocus(page : "Costs", tag : "Haul Times::HaulTimesTable");
                        	2:      halt;
                        	3:
                        	default: halt;
                        endswitch;
                    }
                }
                Assertion Assert_ValueForAllProducts {
                    IndexDomain: (dest,gProd)|ProductsUsed(dest,gprod) or ResidualsUsed(dest,gprod);
                    Text: "Product Value missing for gprod (use \'zero\' for 0)";
                    Property: WarnOnly;
                    AssertLimit: 1;
                    Definition: ProductValue(dest,gProd);
                    Action: {
                        switch(DialogAsk(
                        	message : FormatString("%e has no product value at %e.",gProd,dest) ,
                        	button1 : "Edit Values", 	button3 : "Cancel", button2:"Ignore", 	title : "Product Values missing")) do
                        	1: ! tag "PP::XX" where PP is the tabbed pagename and XX is the tagname
                        
                        !		TabbedPage('Cost') := "Product Values";
                        !		!PageSetFocus(page : "Costs", tag : "Product Values::ProductValuesTable");!
                        !		PageSetCursor(page : "Costs", tag : "Costs_Tab1::ProductValuesTable", 	ProductValue( dest,gprod));
                        		!PageOpen("_Product Values");
                        		!PageSetFocus(page:"_Product Values", tag:"ProductValuesTable");
                        		PageSetCursor(page:"_Product Values", tag:"ProductValuesTable", ProductValue(dest,gprod) );
                        	2: !AssignDefaultProductValues;
                        		!ProductValue((dest, gProd) | not ProductValue(dest, gProd) ) := ProductValue_Default(gProd);
                        	3:halt;
                        
                        endswitch;
                    }
                }
            }
            Procedure AssignCalculatedTotalCostPerUnit {
                Body: {
                    !if HaulTime(src,dest) then
                    
                    ValidSupplies := { (src,dest,gProd) | (src,dest) in PotentialSupplyRoutes
                    					 !(src,dest,gProd) in TimePermittedRoutesForProducts
                    					 !and (src,dest) in AvailableSupplyRoutes
                    					 and ((ProductsUsed(dest,gProd) or ResidualsUsed(dest,gProd)))
                    					 and HaulTime(src,dest)
                    					 !and HaulTime(src,dest) < MaxAllowedHaultime
                    					 };
                    empty CalculatedTotalCostPerUnit;
                    
                    !-- Need for() because assignment with conditional tags not allowed (e.g. calc( (vsupp.vsrc ...) | condition) :=
                    for ( vsupp  ) do
                     	if HaulTime(vsupp.vsrc,vsupp.vdest) then
                    		if IsSelected(__HaulTimeAsCost) then
                    			CalculatedTotalCostPerUnit(vsupp.vsrc, vsupp.vdest, gProd)
                    				:= HaulTime(vsupp.vsrc,vsupp.vdest) * 1 [$] / 1 [ProductUnit(gprod)] / 1 [hour] ;
                    		else
                    		CalculatedTotalCostPerUnit(vsupp.vsrc, vsupp.vdest, vsupp.vProd) :=
                    			2 * HaulTime(vsupp.vsrc,vsupp.vdest) /$ VolumePerLoad(vsupp.vProd) * TruckRate(vsupp.vProd)
                    			+ LoadingCostPerLoad(vsupp.vProd) /$ VolumePerLoad(vsupp.vProd)
                    			;
                    		endif
                    	else
                    		CalculatedTotalCostPerUnit(vsupp.vsrc, vsupp.vdest, vsupp.vProd) :=  999 [$/m3] ;
                    	endif;
                    endfor;
                }
                Set ValidSupplies {
                    SubsetOf: (AllSources, Destinations, AllProducts);
                    Tags: (vsrc, vdest, vprod);
                    Index: vsupp;
                }
            }
            Procedure TEST_PageSetFocus {
                Body: {
                    		DebuggerBreakpoint;
                    		TabbedPage('Costs') := "Product Values";
                    		t:= "Costs_Tab1::ProductValuesTable";
                    		if PageSetFocus(page : "Costs", tag : t) = 0 then
                    			DialogError(formatstring("%s",CurrentErrorMessage));
                    		endif;!
                    !		if PageSetCursor(page : "Costs", tag : "Costs_Tab1::ProductValuesTable",
                    !			ProductValue( dest,prd) =0 and dest = first(dest1)  and prd='SPF') then
                    !			DialogError(formatstring("%s",CurrentErrorMessage));
                    !		endif;!
                    !		PageGetfocus(page : s, tag: t);
                    		halt;
                    		!PageOpen("[Data Page] ProductValue");
                }
                StringParameter s;
                StringParameter t;
            }
            Procedure AssignDefaultProductValues {
                Body: {
                    if DialogAsk("Do you want to assign default product values for unvalued products?",
                    button1:"Yes",button2:"No",title:"Confirm Action") <> 1 then return 0; endif;
                    
                    for (gProd|(not ProductValue_Default(gProd))) do
                    	switch (gprod) do
                    	'Pwrlog': ProductValue_Default(gProd) := 40;
                    	'Pwr'	: ProductValue_Default(gProd) := 25;
                    	'SPFlog': ProductValue_Default(gProd) := 35;
                    	'SPF'	: ProductValue_Default(gProd) := 25;
                    	'OC'	: ProductValue_Default(gProd) := 20;
                    	'Polog'	: ProductValue_Default(gProd) := 40;
                    	'Po'	: ProductValue_Default(gProd) := 20;
                    	'Bwlog'	: ProductValue_Default(gProd) := 25;
                    	'Bw'	: ProductValue_Default(gProd) := 5;
                    	'Th'	: ProductValue_Default(gProd) := 5;
                    	'THLog'	: ProductValue_Default(gProd) := 40;
                    	'Chips' : ProductValue_Default(gProd) := 10;
                    	'Chip_con' :ProductValue_Default(gProd) := 10;
                    	'Chip_hwd' :ProductValue_Default(gProd) := 10;
                    	'Sawdust' :ProductValue_Default(gProd) := 3.95;
                    	'Bark' 	:ProductValue_Default(gProd) := 1.11;
                    	endswitch;
                    endfor;
                }
            }
            Procedure AssignDefaultTruckRate {
                Body: {
                    if DialogAsk("Do you want to assign the default truck rate to all unvalued products?",
                    button1:"Yes",button2:"No",title:"Confirm Action") <> 1 then return 0; endif;
                    
                    
                    TruckRate(gProd | not TruckRate(gProd)) := TruckRateDefault;
                    
                    return 0;
                }
            }
            Procedure UseHaultimesAsHaulCosts {
                Body: {
                    !--- if HaulTime contains cost/unit, set the appropriate parameters to 1/0 so that HaulCostPerUnit is correct
                    
                    if DialogAsk("Do your HaulTimes actually represent $/unit costs?","Yes","No",title:"Confirm Action") <> 1 then
                    	return 0; endif;
                    
                    empty TruckRate, LoadingCostPerLoad;
                    
                    VolumePerLoad(gProd) := 1;
                    
                    return 1;
                }
            }
            Procedure AssignDefaultProductValuesToMills {
                Body: {
                    !--- clear product value for all species not used by dest
                    ProductValue((dest, gProd) | not gprod in AllProductsUsed(dest) ) := 0;
                    
                    switch (DialogAsk("Which default product values for do you want to assign to all mills?",
                    button1:"unvalued products?",button2:"All Products",Button3:"Cancel",title:"Specify Action")) do
                    
                    
                    	1:!Products without value
                    		ProductValue((dest,gProd) |  not ProductValue(dest,gProd) and gprod in AllProductsUsed(dest) )
                    			! lowest valued species that contributes to same species group as gProd
                    			:= min(gpr | gpr in AllProductsUsed(dest)
                    					and exists(gPrGrp | cPrG(gPrGrp, gpr) and cPrG(gPrGrp, gProd)
                    								and (ProductsUsed_PrGrp(dest, gPrGrp) or ResidualsUsed_PrGrp(dest, gPrGrp) )
                    								and gProd in AllProductsUsed(dest) )
                    			, ProductValue_Default(gpr) );
                    
                    	2:!All Products
                    !		for ( (dest,gprod) | gprod in AllProductsUsed(dest)) do
                    !			!if dest = 'Ainswor' then DebuggerBreakpoint; endif;
                    !			current_gpr := argmin(gpr | gpr in AllProductsUsed(dest)
                    !					and exists(gPrGrp | cPrG(gPrGrp, gpr) and cPrG(gPrGrp, gProd)
                    !								and (ProductsUsed_PrGrp(dest, gPrGrp) or ResidualsUsed_PrGrp(dest, gPrGrp) )
                    !								and gProd in AllProductsUsed(dest) )
                    !				, ProductValue_Default(gpr)) ;
                    !		endfor;
                    
                    		ProductValue((dest,gProd) | gprod in AllProductsUsed(dest) )
                    			! lowest valued species that contributes to same species group as gProd
                    			:= min(gpr | gpr in AllProductsUsed(dest)
                    					and exists(gPrGrp | cPrG(gPrGrp, gpr) and cPrG(gPrGrp, gProd)
                    								and (ProductsUsed_PrGrp(dest, gPrGrp) or ResidualsUsed_PrGrp(dest, gPrGrp) )
                    								and gProd in AllProductsUsed(dest) )
                    			, ProductValue_Default(gpr) );
                    
                    	default:
                    	return 0;
                    endswitch;
                    
                    return 1;
                }
            }
            Section Management_Units_DATASET {
                Set ManagementUnits {
                    Index: mu, mu1;
                    Parameter: Current_mu, _mu;
                }
                StringParameter ManagementUnits_txt {
                    IndexDomain: mu;
                }
                Set Blocks {
                    SubsetOf: AllLocations;
                    Index: blk, blk1;
                    Parameter: Current_blk, _blk, _BlkToMap;
                }
                Parameter MU_Block_Relation {
                    IndexDomain: (mu,blk);
                    Text: "blk belonging to mu";
                    Range: binary;
                }
                DeclarationSection Volumes {
                    Parameter InitialGS {
                        IndexDomain: (blk,prd);
                        Range: nonnegative;
                        Unit: ProductUnit(prd);
                    }
                    Parameter PercentBlockAvailable {
                        IndexDomain: (blk);
                        Text: "Percentage of Volume in blk that is available";
                        Range: [0, 100];
                        Unit: %;
                        Default: 100;
                        Comment: "dk: Feb 2010 - used in definition of IsAvailable(blk)";
                    }
                    Parameter GsAvailable {
                        IndexDomain: (blk,prd) |IsAvailable(blk);
                        Range: nonnegative;
                        Unit: ProductUnit(prd);
                        Definition: {
                            InitialGS(blk,prd) *
                            if IsSelected(__IncludeOnlyAvailableBlocks) then PercentBlockAvailable(blk) else 1 endif
                        }
                    }
                    Parameter difGS {
                        IndexDomain: (blk,prd)|InitialGS(blk,prd);
                        Definition: GsAvailable(blk,prd) /$ InitialGS(blk,prd);
                    }
                    Parameter AvailableGsFactor {
                        Text: "Increase GS in available blocks by ...";
                        Range: [0, 100];
                        Unit: %;
                    }
                    Parameter InitialGS_mu {
                        IndexDomain: (mu,prd);
                        Text: "Volume of prd in mu";
                        Range: nonnegative;
                        Unit: ProductUnit(prd);
                        Definition: {
                            sum(blk , GsAvailable(blk,prd)$ MU_Block_Relation(mu,blk))
                            	*( if  IsSelected(__IncludeOnlyAvailableBlocks) then  (1 + AvailableGsFactor) else 1 endif 	 )
                        }
                    }
                    Parameter InitialGS_PrGrp {
                        IndexDomain: (blk,PrGrp);
                        Text: "Volume of prd in mu";
                        Range: nonnegative;
                        Unit: ProductGroupUnit(PrGrp);
                        Definition: sum(prd | cPrG(PrGrp,prd), InitialGS(blk,prd));
                    }
                    Parameter TotalInitialGS {
                        IndexDomain: (prd);
                        Range: nonnegative;
                        Unit: ProductUnit(prd);
                        Definition: sum(blk,InitialGS(blk,prd));
                    }
                    Parameter TotalInitialGS_PrGrp {
                        IndexDomain: (PrGrp);
                        Range: nonnegative;
                        Unit: ProductGroupUnit(PrGrp);
                        Definition: sum((blk,prd),InitialGS(blk,prd) $ cPrG(PrGrp,prd));
                    }
                    Parameter InitialPotentialProduct {
                        IndexDomain: (blk,prOUT);
                        Range: nonnegative;
                        Unit: m3;
                        Definition: sum(prin,InitialGS(blk,prIN) * EquivalentProducts(prIN,prOUT));
                    }
                    Parameter InitialPotentialProduct_mu {
                        IndexDomain: (mu,prOUT);
                        Range: nonnegative;
                        Unit: m3;
                        Definition: sum(blk | MU_Block_Relation(mu,blk),InitialPotentialProduct(blk,prOUT));
                    }
                }
            }
            Section Mill_Definitions_DATASET {
                Set Sectors {
                    Text: "Product Sector (Mill Type)";
                    Index: sect;
                    Parameter: _Sect;
                    InitialData: {
                        data {
                        Biomass
                        ,Chipper
                        ,Composite
                        ,Fuel
                        ,Other
                        ,Paper
                        ,Pulp
                        ,Sawmill
                        ,Veneer
                        ,Yard
                        }
                    }
                }
                Set Destinations {
                    SubsetOf: AllLocations;
                    Index: dest, dest1, destFrom, DestTo;
                    Parameter: Current_dest, Current_Mill, Copy_DestTo, Copy_DestFrom, _Dest_Sel;
                }
                Set Destinations_Included {
                    SubsetOf: Destinations;
                    Index: dest_incl;
                    Property: NoSave;
                    Definition: {
                        { dest | if IsSelected(__IncludeOnlyAvailableMills) then IncludeMill(dest) else 1 endif}
                    }
                }
                Set CostCentres {
                    Text: "Groups of Destinations across which revenues must exceed costs";
                    Index: iCost;
                    Parameter: _Cost;
                }
                Parameter cMillCostCentre {
                    IndexDomain: (dest,iCost);
                    Text: "Dest is part of cost centre iCost";
                    Range: binary;
                }
                Parameter cMillSector {
                    IndexDomain: (sect,dest);
                }
                Parameter ProductsUsed {
                    IndexDomain: (dest,prd);
                    Text: "Product prd is used by Mill dest";
                    Range: binary;
                    Definition: {
                        !1 $ !sum(PrGrp, ProductsUsed_PrGrp(dest,PrGrp) $ cPrG(PrGrp,prd))
                        exists(PrGrp | ProductsUsed_PrGrp(dest,PrGrp) and cPrG(PrGrp,prd) )
                    }
                }
                Parameter UsesProducts {
                    IndexDomain: (dest);
                    Text: "Mill dest process products";
                    Range: binary;
                }
                Parameter UsesResiduals {
                    IndexDomain: (dest);
                    Range: binary;
                }
                Parameter ResidualsProduced {
                    IndexDomain: {
                        (dest,gpr,res) | ResidualsProduced_Dom(dest, gpr, res)
                        !ProducesResiduals(dest)
                        !and [ ( ProductsUsed(dest, ElementCast(Products,gpr,0) )   )
                        !   or (ResidualsUsed(dest, ElementCast(ResidualGroupProducts,gpr,0) ) ) ]
                    }
                    Text: "amount of res produced for each unit of gpr";
                    Range: nonnegative;
                    Unit: ProductUnit(res)/ProductUnit(gpr);
                    Definition: {
                        
                        !OLD - residuals produced only from products (prd->res)
                        !PARAMETER:
                        !   identifier   :  ResidualsProduced
                        !   index domain :  (dest,prd,res) | ProductsUsed(dest,prd) $ ProducesResiduals(dest)
                        !   text         :  "amount of res produced for each unit of prd"
                        !   range        :  nonnegative
                        !   unit         :  ProductUnit(res)/ProductUnit(prd)
                    }
                    Comment: {
                        "! warning: How to handle conversion from one product to another
                        ! Warning: Need to allow production of residuals from other residuals, e.g. pellet->energy"
                    }
                }
                Parameter ResidualsProduced_Dom {
                    IndexDomain: (dest,gpr,res);
                    Range: binary;
                    Definition: {
                        1 $
                        ProducesResiduals(dest)
                        and gpr in AllProductsUsed(dest)
                    }
                }
                Parameter ProductsUsed_PrGrp {
                    IndexDomain: (dest,PrGrp);
                    Range: binary;
                }
                Parameter ResidualsUsed {
                    IndexDomain: (dest,gRes);
                    Range: binary;
                    Definition: {
                        ! Because ResGrp can represent prd and res, must use gpr as index (instead of res)
                        1 $ sum(ResGrp, ResidualsUsed_PrGrp(dest,ResGrp) $ cPrG(ResGrp,gRes))
                    }
                }
                Parameter ResidualsUsed_PrGrp {
                    IndexDomain: (dest,ResGrp);
                    Range: binary;
                }
                Set ProductsAllUsed_PrGrp {
                    IndexDomain: (dest);
                    SubsetOf: AllProductGroups;
                    Definition: {
                        { gPrGrp | ProductsUsed_PrGrp(dest,gPrGrp) }
                         +
                         {gPrGrp | ResidualsUsed_PrGrp(dest,gPrGrp)  }
                    }
                }
                Set ProductsUsed_Set {
                    SubsetOf: Products;
                    Text: "Products used by Current_Mill";
                    Index: Cur_prd_Used;
                    Definition: {
                        { prd | ProductsUsed(Current_Mill,prd) }
                    }
                }
                Set AllProductsUsed_Set {
                    SubsetOf: AllProducts;
                    Text: "Products used by Current_Mill";
                    Index: Cur_gpr_Used;
                    Definition: {
                        { gpr | ProductsUsed(Current_Mill,gpr) or ResidualsUsed(Current_Mill,gpr) }
                    }
                }
                Set AllProductsUsed {
                    IndexDomain: (dest);
                    SubsetOf: AllProducts;
                    Text: "Products used by Current_Mill";
                    Property: NoSave;
                    Definition: {
                        { gpr | ProductsUsed(dest,gpr) or ResidualsUsed(dest,gpr) }
                    }
                }
                Parameter ProducesResiduals {
                    IndexDomain: (dest) | UsesProducts(dest);
                    Text: "true if dest produces residuals";
                    Range: binary;
                }
                Parameter MillDemand {
                    IndexDomain: (dest,gpr,tt,tp)|ProductsUsed(dest,gpr) or ResidualsUsed(dest,gpr);
                    Text: "Volume limit (tt) by Mill (Dest) of Product(gpr) during period tp";
                    Range: nonnegative;
                    Unit: ProductUnit(gpr);
                }
                Parameter MillDemand_PrGrp {
                    IndexDomain: (dest,PrGrp,tt,tp)| ProductsUsed_PrGrp(dest,PrGrp);
                    Text: "Volume limit (tt) by Mill (Dest) of Product(prg) during period tp";
                    Range: nonnegative;
                    Unit: ProductGroupUnit(PrGrp);
                }
                Parameter MillResidualDemand_PrGrp {
                    IndexDomain: (dest,ResGrp,tt,tp)| ResidualsUsed_PrGrp(dest,ResGrp);
                    Text: "Volume limit (tt) by Mill (Dest) of Residual (ResGrp) during period tp";
                    Range: nonnegative;
                    Unit: m3;
                }
            }
            Section Targets_and_Strategies {
                DeclarationSection Mill_Demand_Targets {
                    Parameter IncludeMill {
                        IndexDomain: (dest);
                        Text: "dest is available to receive products";
                        Range: binary;
                        Default: 1;
                    }
                    Parameter MillAlwaysAvailable {
                        IndexDomain: (dest);
                        Text: "dest is forced to receive products";
                        Range: binary;
                        Comment: "used to set NonVar Status";
                    }
                    Parameter MillDemand_PrGrp_AllTerms {
                        IndexDomain: (dest,PrGrp)| ProductsUsed_PrGrp(dest,PrGrp);
                        Text: "Volume limit (tt) by Mill (Dest) of Product(prgrp) during period tp";
                        Range: nonnegative;
                        Unit: ProductGroupUnit(PrGrp);
                        Definition: {
                            !sum((tt,tp)| tt = __min,MillDemand_PrGrp(dest,PrGrp,tt,tp))
                            sum[term , max((tp) | tp.ts <= term <= tp.tf 	,MillDemand_PrGrp(dest,PrGrp,__min,tp)) ]
                        }
                    }
                    Parameter MillAllDemand_PrGrp {
                        IndexDomain: (dest,gPrGrp,tt,tp)| ResidualsUsed_PrGrp(dest,gPrGrp) or ProductsUsed_PrGrp(dest,gPrGrp);
                        Text: "Volume limit (tt) by Mill (Dest) of Product (gPrGrp) during period tp";
                        Range: nonnegative;
                        Unit: m3;
                        Definition: MillDemand_PrGrp(dest,gPrGrp,tt,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp);
                    }
                    Assertion Assert_MillAllDemandTargets {
                        IndexDomain: (dest,gPrGrp,tp) | MillAllDemand_PrGrp(dest,gPrGrp,__min,tp) and MillAllDemand_PrGrp(dest,gPrGrp,__max,tp);
                        Text: "Minimum target must be <= Maximum target";
                        Definition: MillAllDemand_PrGrp(dest,gPrGrp,__max,tp) >= MillAllDemand_PrGrp(dest,gPrGrp,__min,tp);
                    }
                    Parameter TotalDemand_term {
                        IndexDomain: (term,PrGrp);
                        Range: nonnegative;
                        Unit: m3;
                        Definition: {
                            sum((dest,tt,tp) | tt = __min and term >= tp.ts and term <= tp.tf
                            ,MillDemand_PrGrp(dest,PrGrp,tt,tp) )
                        }
                    }
                    Parameter TotalDemand {
                        IndexDomain: (PrGrp);
                        Range: nonnegative;
                        Unit: m3;
                        Definition: sum((term,prd),TotalDemand_term(term,PrGrp) $cPrG(PrGrp,prd));
                    }
                    Parameter PotentialExcessSupply {
                        IndexDomain: (PrGrp);
                        Unit: m3;
                        Definition: {
                            sum((blk,prd),InitialPotentialProduct(blk,prd) $ cPrG(PrGrp,prd) ) -
                            TotalDemand(PrGrp)
                        }
                    }
                    Parameter ExcessSupply {
                        IndexDomain: (PrGrp);
                        Unit: m3;
                        Definition: TotalInitialGS_PrGrp(PrGrp) -  TotalDemand(PrGrp);
                    }
                    Parameter PotentialAvailableSupply_Blocks {
                        IndexDomain: (PrGrp,dest) | ProductsUsed_PrGrp(dest,PrGrp) and dest in AvailableDest;
                        Unit: ProductGroupUnit(PrGrp);
                        Definition: {
                            sum[(blk) | (blk,dest) in TimePermittedSupplyRoutes
                            	and blk in AvailableBlocks
                            , InitialGS_PrGrp(blk,PrGrp)]
                        }
                    }
                    Parameter PotentialAvailableSupply_Residuals {
                        IndexDomain: (ResGrp,dest, destfrom) | ResidualsUsed_PrGrp(dest,ResGrp);
                        Definition: {
                            !sum((destFrom) ! $ (destFrom,dest) in PermittedRoutes
                            !,
                              sum((prd,res) ,ResidualsProduced(destFrom,prd,res)  $  cPrG(ResGrp,res) )
                            
                            !)
                            
                            !Warning: Must fix this ...
                        }
                    }
                    Parameter MillDemandWithoutSupply {
                        IndexDomain: {
                            (PrGrp,dest_incl) | ProductsUsed_PrGrp(dest_incl,PrGrp)
                            and ( PotentialAvailableSupply_Blocks(PrGrp,dest_incl) < MillDemand_PrGrp_AllTerms(dest_incl,PrGrp) )
                        }
                        Text: "Shortfall in available supply of \'PrGrp\' for \'dest_incl\'";
                        Unit: ProductGroupUnit(PrGrp);
                        Definition: MillDemand_PrGrp_AllTerms(dest_incl,PrGrp) - PotentialAvailableSupply_Blocks(PrGrp,dest_incl);
                    }
                    Assertion Assert_MillDemandWithoutSupply {
                        IndexDomain: {
                            (PrGrp,dest) | ProductsUsed_PrGrp(dest,PrGrp)
                            and dest in AvailableDest
                            and ( PotentialAvailableSupply_Blocks(PrGrp,dest) < MillDemand_PrGrp_AllTerms(dest,PrGrp) )
                        }
                        Text: "Mill \'dest\' does not have enough potential supplly for \'PrGrp\'";
                        Definition: MillDemandWithoutSupply(PrGrp,dest) = 0 [m3];
                    }
                    StringParameter FilenameDemand;
                    Parameter PercentOverDemand {
                        IndexDomain: PrGrp | TotalDemand(PrGrp) > TotalInitialGS_PrGrp(PrGrp);
                        Definition: TotalInitialGS_PrGrp(PrGrp) / TotalDemand(PrGrp);
                    }
                    File File_FileDemand {
                        Name: FilenameDemand;
                    }
                }
                Procedure WriteMillDemand {
                    Body: {
                        write UsesProducts,UsesResiduals,ProducesResiduals,
                                        ProductsUsed_PrGrp, ResidualsUsed_PrGrp, ResidualsProduced,
                        
                                        MillDemand_PrGrp, MillResidualDemand_PrGrp
                        
                                        To file "testMillDemand.txt"; !file_FileDemand;
                    }
                }
                Procedure ReadMillDemand {
                    Body: {
                        empty MillDemand_PrGrp;
                        read UsesProducts,UsesResiduals,ProducesResiduals,
                                        ProductsUsed_PrGrp, ResidualsUsed_PrGrp, ResidualsProduced,
                        
                                        MillDemand_PrGrp, MillResidualDemand_PrGrp
                        
                                        from file "testMillDemand.txt"; !file_FileDemand;
                    }
                }
                Procedure AdjustMillDemand {
                    Body: {
                        if dialogAsk("Do you want to adjust demand targets to meet Initial GS?","Yes","No"
                                ,title:"Confirm Action") <> 1 then return 0; endif;
                        
                        MillDemand_PrGrp((dest,PrGrp,tt,tp) | PercentOverDemand(PrGrp))
                                := MillDemand_PrGrp(dest,PrGrp,tt,tp) * PercentOverDemand(PrGrp) * 0.999;
                    }
                }
                Procedure DivideTreesFlowByFour {
                    Body: {
                        if DialogAsk(
                        	message : "Do you wish to divide Trees targets by 4?",
                        	button1 : "Yes",
                        	button2 : "No",
                        	button3 : "Cancel",
                        	title : "Confirm Action") = 1 then
                        
                        	TreesFlow(term,mu,dest,prd,tt) $/= 4;
                        endif;
                    }
                }
                Procedure SetUpperTargetsEqualLower {
                    Body: {
                        if not IsSelected(__SetUpperTargets) then return 0; endif;
                        
                        block ! Meet Volume Targets
                        	if IsSelected(__MeetVolumeTargets) then
                        		MillDemand_PrGrp(dest,PrGrp,__max,tp) 	:=$  MillDemand_PrGrp(dest,PrGrp,__min,tp);
                        	endif
                        endblock;
                        
                        block !Simulate Trees
                        	if (IsSelected(_SimulateTREES)) then
                        		TreesFlow(term,mu,dest,prd,__max)  :=$  TreesFlow(term,mu,dest,prd,__min);
                        	endif;
                        endblock;
                    }
                }
                DeclarationSection Threshold_Related {
                    Set Thresholds {
                        Index: thr;
                        Definition: {
                            data {
                            Low, Moderate, Significant, High
                            }
                        }
                    }
                    ElementParameter __thrLow {
                        Range: Thresholds;
                        Definition: 'low';
                    }
                    ElementParameter __thrMod {
                        Range: Thresholds;
                        Definition: 'Moderate';
                    }
                    ElementParameter __thrSig {
                        Range: Thresholds;
                        Definition: 'Significant';
                    }
                    ElementParameter __thrHigh {
                        Range: Thresholds;
                        Definition: 'High';
                    }
                    Parameter ThresholdStart {
                        IndexDomain: (sect,thr);
                        Text: "Threshold thr for sect begins at ... proportion of demand";
                        Range: [0, 1];
                        InitialData: {
                            {
                            ('Biomass','Low') :     0
                            ,('Biomass','Moderate') :       0
                            ,('Biomass','Significant') :    0
                            ,('Biomass','High') :   0
                            ,('Chipper','Low') :    0
                            ,('Chipper','Moderate') :       0
                            ,('Chipper','Significant') :    0
                            ,('Chipper','High') :   0
                            ,('Composite','Low') :  1
                            ,('Composite','Moderate') :     0.95
                            ,('Composite','Significant') :  0.6
                            ,('Composite','High') : 0.4
                            ,('Fuel','Low') :       0
                            ,('Fuel','Moderate') :  0
                            ,('Fuel','Significant') :       0
                            ,('Fuel','High') :      0
                            ,('Other','Low') :      0
                            ,('Other','Moderate') : 0
                            ,('Other','Significant') :      0
                            ,('Other','High') :     0
                            ,('Paper','Low') :      1
                            ,('Paper','Moderate') : 0.95
                            ,('Paper','Significant') :      0.9
                            ,('Paper','High') :     0.85
                            ,('Pulp','Low') :       1
                            ,('Pulp','Moderate') :  0.95
                            ,('Pulp','Significant') :       0.9
                            ,('Pulp','High') :      0.85
                            ,('Sawmill','Low') :    1
                            ,('Sawmill','Moderate') :       0.95
                            ,('Sawmill','Significant') :    0.6
                            ,('Sawmill','High') :   0.4
                            ,('Veneer','Low') :     1
                            ,('Veneer','Moderate') :        0.95
                            ,('Veneer','Significant') :     0.6
                            ,('Veneer','High') :    0.4
                            ,('Yard','Low') :       0
                            ,('Yard','Moderate') :  0
                            ,('Yard','Significant') :       0
                            ,('Yard','High') :      0
                            
                            }
                        }
                    }
                    Parameter ThresholdPenalties {
                        IndexDomain: (thr);
                        Text: "Penalty for not meeting thr threshhold target in sect sector";
                        Range: nonnegative;
                        InitialData: {
                            data {
                            'Low' : 1,      'moderate' : 3,         'significant' : 8,       'High' : 100
                            }
                        }
                    }
                    Parameter MillThresholdValues {
                        IndexDomain: (dest,gPrGrp,thr,tp)| ( MillDemand_PrGrp(dest,gPrGrp,__min,tp) or MillResidualDemand_PrGrp(dest,gPrGrp,__min,tp));
                        Text: "Vomume of gPrGrp required by dest to meet threshold thr in timeperiod tp";
                        Unit: ProductGroupUnit(gPrGrp);
                        Definition: {
                            ! Onset level of each threshold : Demand * ProoirtionWhereThreshold (thr) Starts (Sector)
                            [ MillDemand_PrGrp(dest,gPrGrp,__min,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,__min,tp) ]
                            * sum [(sect) |  cMillSector(sect,dest), ThresholdStart(sect,thr) ]
                        }
                    }
                    ElementParameter ThresholdColours {
                        IndexDomain: (thr);
                        Range: AllColors;
                        Property: NoSave;
                        Definition: {
                            if thr = 'High' then 'Threshold High'
                            elseif thr = 'Significant' then  'Threshold Significant'
                            elseif thr = 'Moderate' then  'Threshold Moderate'
                            elseif thr = 'Low' then  'Threshold Low'
                            else 'white' endif
                        }
                    }
                    Parameter ReductionInWoodSupply {
                        IndexDomain: (term,dest,gPrGrp);
                        Unit: ProductGroupUnit(gPrGrp);
                        Definition: {
                            ! if Mill is not selected (available) then 100% reduction
                            if MillIsAvailable(dest) = 0 then 1
                            
                            elseif !Delivered Volume > Minimum Demand
                            	DeliveredAllVolume_PrGrp(term,dest,gPrGrp)
                            	>
                                sum [ tp  | term >= tp.ts and term <= tp.tf   , MillDemand_PrGrp(dest,gPrGrp,__min,tp)
                                		+ MillResidualDemand_PrGrp(dest,gPrGrp,__min,tp)	]
                                then 0
                            
                            else ! Demand > Delivered Volume
                            	(
                                sum [ tp  | term >= tp.ts and term <= tp.tf   , MillDemand_PrGrp(dest,gPrGrp,__min,tp)
                                		+ MillResidualDemand_PrGrp(dest,gPrGrp,__min,tp) 	]
                            	 - DeliveredAllVolume_PrGrp(term,dest,gPrGrp)
                                )
                            endif
                        }
                    }
                    ElementParameter RiskOfClosure_term {
                        IndexDomain: (term,dest,gPrGrp);
                        Range: Thresholds;
                        Definition: {
                            last(thr |
                            
                                sum[(tp) | tp.ts <= term <= tp.tf
                                		, MillThresholdValues(dest, gPrGrp, thr, tp) ]
                                	> 	DeliveredAllVolume_PrGrp(term,dest,gPrGrp)
                                	!<= ReductionInWoodSupply(term, dest, gPrGrp)
                                )
                        }
                    }
                    ElementParameter RiskOfClosure {
                        IndexDomain: dest;
                        Text: "Risk that dest must close for 1 term";
                        Range: Thresholds;
                        Property: NoSave;
                        Definition: {
                            
                            max((term,gPrGrp),RiskOfClosure_term(term, dest, gPrGrp) )
                            !    )
                        }
                    }
                    Parameter Copy_RiskOfClosure {
                        IndexDomain: (dest,thr);
                        Unit: m3;
                        Definition: {
                            sum[(tp,term,gPrGrp) | tp.ts <= term <= tp.tf
                            		, MillThresholdValues(dest, gPrGrp, thr, tp) ]
                        }
                    }
                }
                DeclarationSection Other_Targets {
                    Parameter EvenFlowDeliver {
                        IndexDomain: {
                            (dest,gPrGrp,tpM) |  gPrGrp in ProductsAllUsed_PrGrp(dest) ! Uses Product
                            ! or the product group has species in common with another product group used by the mill
                            or (exists(gprgrp2 | (PrGrpMwithPrGrpSingle(gPrGrp,gPrGrp2) and gPrGrp2 in ProductsAllUsed_PrGrp(dest) ) ) )
                        }
                        Text: "Allowed fluctuation in volume of gPrGrp delivered to dest during timeperiod tpM";
                        Range: [0, 1];
                        Unit: 1;
                    }
                }
                Procedure SetEvenFlowRate {
                    Body: {
                        switch ( dialogAsk("Do you wish to clear existing flow rates?","Yes","No") ) do
                        	1: boolDoClear := 1;
                        	2: boolDoClear := 0;
                        	default: return -1;
                        endswitch;
                        
                        if DialogGetNumber("Enter EvenFlow Rate (0.1 means 10% flow)",EvenFlow_Rate,1,title:"Enter Value") = 0
                        	then return -1; endif;
                        
                        if EvenFlow_Rate =0 then EvenFlow_Rate :=zero; endif;
                        
                        !DebuggerBreakpoint;
                        switch (DialogAsk("To which Timeperiods do you wish to apply the flow constraint:",
                        	button1:"First To last",button2:"Those with targets",title:"Enter Choice")) do
                        	1:
                        		if boolDoClear then  empty EvenFlowDeliver; endif;
                        		EvenFlowDeliver((dest,gPrGrp,tpM) | not EvenFlowDeliver(dest,gPrGrp,tpM)
                        			and gprgrp in ProductsAllUsed_PrGrp(dest)
                        			and tpm.ts = first(term) and tpm.tf = last(term))
                        			:= EvenFlow_Rate;
                        	2:
                        		if boolDoClear then  empty EvenFlowDeliver; endif;
                        		EvenFlowDeliver((dest,gPrGrp,tpM) | not EvenFlowDeliver(dest,gPrGrp,tpM)
                        			and sum [(tt), MillAllDemand_PrGrp(dest,gPrGrp,tt,tpM)])
                        			:= EvenFlow_Rate;
                        	default:
                        		return 0;
                        endswitch;
                        
                        return 1;
                    }
                    Parameter EvenFlow_Rate {
                        Range: [0, 1];
                    }
                    Parameter boolDoClear {
                        Range: binary;
                    }
                }
                Procedure InitializeMillSectorRelation {
                    Body: {
                        ! from qryAIMMS_MillAndSector
                        DialogError("Procedure InitializeMillSectorRelation has been commented out");
                        return 0;
                        !cMillSector(sect,dest) := data {
                        !!('Pulp','4229') : 1,
                        !('Pulp','ACC_FF')  : 1,
                        !('Paper','ACC_IF')  : 1,
                        !('Paper','ACC_Ken')  : 1,
                        !('Paper','ACC_TB')  : 1,
                        !('Sawmill','AFP')  : 1,
                        !('Composite','Ainswor')  : 1,
                        !('Sawmill','BNH')  : 1,
                        !('Sawmill','Bonifer')  : 1,
                        !('Pulp','BowP_TB')  : 1,
                        !('Sawmill','BowS_Ig')  : 1,
                        !('Sawmill','BowS_TB')  : 1,
                        !('Sawmill','CarsonL')  : 1,
                        !('Paper','Cascades')  : 1,
                        !('Sawmill','Cheminis')  : 1,
                        !('Sawmill','CommonS')  : 1,
                        !('Sawmill','Dament')  : 1,
                        !('Sawmill','Devlin')  : 1,
                        !('Sawmill','Dom_Chap')  : 1,
                        !('Paper','Dom_Corn')  : 1,
                        !('Pulp','Dom_Dry')  : 1,
                        !('Sawmill','Dom_Ear')  : 1,
                        !('Sawmill','Dom_Elk')  : 1,
                        !('Pulp','Dom_Esp')  : 1,
                        !('Sawmill','Dom_Nair')  : 1,
                        !('Sawmill','Dom_Tim')  : 1,
                        !('Sawmill','Dom_WR')  : 1,
                        !('Chipper','DubreuiC')  : 1,
                        !('Sawmill','Dubreuil')  : 1,
                        !('Sawmill','Excel')  : 1,
                        !('Composite','Fibratec')  : 1,
                        !('Veneer','Forestpl')  : 1,
                        !('Chipper','Frey_Ch')  : 1,
                        !('Sawmill','Frey_S')  : 1,
                        !('Sawmill','Gervais')  : 1,
                        !('Sawmill','Gogama')  : 1,
                        !('Sawmill','Goulard')  : 1,
                        !('Composite','Grant_En')  : 1,
                        !('Composite','Grant_Ti')  : 1,
                        !('Sawmill','GreatWes')  : 1,
                        !('Sawmill','HerbShaw')  : 1,
                        !('Chipper','HokumCh')  : 1,
                        !('Sawmill','HokumS')  : 1,
                        !('Sawmill','HRChart')  : 1,
                        !('Sawmill','IsaRoy')  : 1,
                        !('Sawmill','JanLum')  : 1,
                        !('Sawmill','KenForPr')  : 1,
                        !('Sawmill','Lahaie')  : 1,
                        !('Sawmill','Lecours')  : 1,
                        !('Veneer','LevV_He')  : 1,
                        !('Veneer','LevV_Nip')  : 1,
                        !('Sawmill','Lheidem')  : 1,
                        !('Sawmill','Liskeard')  : 1,
                        !('Sawmill','LongLake')  : 1,
                        !('Composite','LWI_C')  : 1,
                        !('Veneer','LWI_V')  : 1,
                        !('Sawmill','Manitou')  : 1,
                        !('Pulp','Marathon')  : 1,
                        !('Sawmill','Mckenzie')  : 1,
                        !('Sawmill','McRea')  : 1,
                        !('Sawmill','Midway')  : 1,
                        !('Sawmill','MurrayBr')  : 1,
                        !('Sawmill','Muskoka')  : 1,
                        !('Sawmill','NakinaFP')  : 1,
                        !('Sawmill','NickelL')  : 1,
                        !('Pulp','Noram_RR')  : 1,
                        !('Pulp','Noram_Tr')  : 1,
                        !('Veneer','Norboard')  : 1,
                        !('Sawmill','NorPreTr')  : 1,
                        !('Sawmill','NorSaw')  : 1,
                        !('Sawmill','Ohaavald')  : 1,
                        !('Chipper','Pennock')  : 1,
                        !('Sawmill','Precut')  : 1,
                        !('Sawmill','Rfryer')  : 1,
                        !('Paper','SpFallsP')  : 1,
                        !('Sawmill','SpFallsS')  : 1,
                        !('Paper','StMary')  : 1,
                        !('Pulp','Sturgeon')  : 1,
                        !('Sawmill','Tem_Ch')  : 1,
                        !('Sawmill','Tem_Co')  : 1,
                        !('Sawmill','Tem_He')  : 1,
                        !('Sawmill','Tem_Hunt')  : 1,
                        !('Sawmill','Tem_KL')  : 1,
                        !('Sawmill','Tem_Mat')  : 1,
                        !('Pulp','Tem_SR')  : 1,
                        !('Sawmill','Tem_Tim')  : 1,
                        !('Pulp','TerrBay')  : 1,
                        !('Sawmill','TJNeuman')  : 1,
                        !('Composite','Wey_Ken')  : 1,
                        !('Composite','Wey_Wawa')  : 1
                        !}
                        !
                    }
                }
                Section FLOW_Targets_Section {
                    DeclarationSection Simulate_TREES {
                        Parameter TreesFlow {
                            IndexDomain: (term,mu,dest,prd, tt);
                            Text: "Volume of \'prd\' shipped from \'mu\' to \'dest\' during \'term\'";
                            Unit: m3;
                        }
                        Parameter TreesTotalFlow {
                            IndexDomain: (term,dest,prd, tt);
                            Text: "Total Volume of \'prd\' recrived by \'dest\' during \'term\'";
                            Unit: m3;
                            Definition: sum [(mu), TreesFlow(term,mu,dest,prd,tt)];
                        }
                        Parameter TreesInvalidFlows {
                            IndexDomain: (term,mu,dest,prd,tt) | not [(mu,dest) in TREES_ValidFlows];
                            Unit: ProductUnit(prd);
                            Definition: TreesFlow(term,mu,dest,prd,tt);
                        }
                    }
                    DeclarationSection Simulate_Residuals {
                        Parameter ResidualFlow {
                            IndexDomain: (term,DestFrom,DestTo,res,tt);
                            Text: "Volume of res that DestFrom must ship to DestTo";
                            Range: nonnegative;
                            Unit: ProductUnit(res);
                        }
                    }
                }
                DeclarationSection Future_items {
                    Parameter MillDemandPercent {
                        IndexDomain: (dest,gpr,tt)|ProductsUsed(dest,gpr) or ResidualsUsed(dest,gpr);
                        Range: (0, 1);
                    }
                }
            }
        }
        Section Section_2_Mathematical_Model {
            DeclarationSection MainModel {
                Set Obj_Identifiers {
                    SubsetOf: AllIdentifiers;
                    Index: objId;
                    Parameter: __HarvestVolume,__DeliveredVolume,__ProcessedVolume,__HaulCost,__OperatingMills,__ProcessedValue;
                    InitialData: {
                        data {
                                obj_HarvestVolume,
                               ! obj_ConvertedVolume,
                                obj_DeliveredVolume,
                                obj_ProcessedVolume,
                                obj_HaulCost,
                                obj_OperatingMills,
                                obj_ProcessedValue
                        }
                    }
                }
                Variable Obj_WFlow {
                    Text: "Overall objective of WFlow Model";
                    Definition: sum(objid | obj_Selected(objId), Obj_Contribution(objId));
                }
                Set WFlowVariables {
                    SubsetOf: AllVariables;
                    Definition: {
                        AllVariables * Section_2_Mathematical_Model
                         !-   data { MillIsAvailable }
                        
                        ! - AllVariables * TREES_Related 			$ (not IsSelected(_SimulateTREES) )
                        ! - AllVariables * Residual_Flow_Related 	$ (not IsSelected(__ResidualFlowTargets) )
                        ! - AllVariables * MIP_Formulation 			$ (not IsSelected(__BinaryMills) )
                        ! - AllVariables * Threshold_Section 		$ (not IsSelected( __ThresholdPenalties ) )
                        ! - AllVariables * Even_Flow_Declarations 	$ (not IsSelected( __EvenFlow ) )
                        
                         - AllVariables * Unused_Section
                         !- AllVariables * FlowRO_Library
                        /*
                        
                        */
                    }
                }
                Set WFlowConstraints {
                    SubsetOf: AllConstraints;
                    Text: "Constraints included in Tenure model";
                    Index: iSC;
                    Definition: {
                        AllConstraints * Section_2_Mathematical_Model
                        
                        ! - AllConstraints * TREES_Related 			$ (not IsSelected(_SimulateTREES) )
                        ! - AllConstraints * Residual_Flow_Related 	$ (not IsSelected(__ResidualFlowTargets) )
                        ! - AllConstraints * MIP_Formulation 		$ (not IsSelected(__BinaryMills) )
                        ! - AllConstraints * Threshold_Section 		$ (not IsSelected( __ThresholdPenalties ) )
                        ! - AllConstraints * Even_Flow_Declarations 	$ (not IsSelected( __EvenFlow ) )
                        
                        
                        - AllConstraints * Unused_Section
                         !- AllConstraints * FlowRO_Library
                        - data {
                        		'XXMeetMillDemandPrimary_Lower'  ! these may be redundant with ..._PrGrp
                                ,'XXMeetMillDemandResidualPrGrp_Lower'    ! covered by MeetMillAllDemandPrGrp_Lower
                                ,'XXSelectAvailableMill'			! Changed to NonVar Status of MillIsAvailable
                        } /**/
                    }
                }
                MathematicalProgram Optimize_WithSlack {
                    Objective: Obj_WFlow;
                    Direction: maximize;
                    Constraints: WFlowConstraints;
                    Variables: WFlowVariables;
                    Text: "Optimize Wood Flow";
                    ViolationPenalty: ViolationPenalty_NEW;
                    Comment: {
                        "! type set in solve statement
                        MATHEMATICAL PROGRAM:
                           identifier        :  Optimize_WithSlack
                           objective         :  Obj_WFlow
                           direction         :  maximize
                           constraints       :  WFlowConstraints
                           variables         :  WFlowVariables
                           text              :  \"Optimize Wood Flow\"
                           violation penalty :  ViolationPenalty_NEW
                           comment           :  \"! type set in solve statemen"
                    }
                }
                MathematicalProgram OptimizeWFlow {
                    Objective: Obj_WFlow;
                    Direction: maximize;
                    Constraints: WFlowConstraints;
                    Variables: WFlowVariables;
                    Text: "Optimize Wood Flow";
                    ViolationPenalty: ViolationPenalty_NEW;
                }
                ElementParameter LP_type {
                    Range: AllMathematicalProgrammingTypes;
                    Definition: if IsSelected(__BinaryMills) then 'mip' else 'lp' endif;
                }
                StringParameter Obj_Identifiers_txt {
                    IndexDomain: objId;
                    Property: NoSave;
                    Definition: {
                        data {
                                'obj_HarvestVolume'     : "Harvest Volume (block)"
                                !,'OLDobj_ConvertedVolume'   : "Converted Block Volume (product)"
                                ,'obj_DeliveredVolume'  : "Delivered Volume"
                                ,'obj_ProcessedVolume'  : "Processed Volume"
                                ,obj_HaulCost           : "Haul + Loading Cost"
                                ,'obj_OperatingMills'	: "Number of Operating Mills"
                                ,'obj_ProcessedValue'	: "Value of processed products"
                        }
                    }
                }
                Parameter obj_Weights {
                    IndexDomain: (objId);
                    Range: nonnegative;
                    InitialData: data { obj_HaulCost: 5 };
                }
                ElementParameter obj_Type {
                    IndexDomain: (objId);
                    Text: "either maximize or minimize";
                    Range: TargetType;
                    InitialData: {
                         {
                        'obj_HarvestVolume'			: 'Max'
                        ,'obj_DeliveredVolume'		:  'Max'
                        ,'obj_ProcessedVolume'		: 'Max'
                        ,'obj_HaulCost'				: 'Min'
                        ,'obj_OperatingMills'		: 'Max'
                        ,'obj_ProcessedValue'		: 'Max'
                        }
                        
                        !if objid='obj_HaulCost' then 'Min' else 'Max' endif
                    }
                }
                Parameter obj_Selected {
                    IndexDomain: (objId);
                }
                Variable Obj_Contribution {
                    IndexDomain: (objId);
                    Unit: 1;
                    Definition: {
                        !if (objid = _HarvestVolume)	then obj_HarvestVolume
                        !elseif (objid = _DeliveredVolume) then obj_DeliveredVolume
                        !elseif (objid = _ProcessedVolume) then obj_ProcessedVolume
                        !elseif (objid = _HaulCost) 			then obj_HaulCost
                        !elseif (objid = _OperatingMills) 	then obj_OperatingMills
                        !elseif (objid = _ProcessedValue) 	then obj_ProcessedValue
                        !endif
                        obj_Values(objId) 	* obj_Weights(objid)
                        	* ( if obj_Type(objid) = __min  then -1 else 1 endif )
                    }
                }
                Variable obj_Values {
                    IndexDomain: (objId);
                    Range: free;
                    Definition: {
                        if (objid = __HarvestVolume)	then obj_HarvestVolume / 1 [k_m3]
                        elseif (objid = __DeliveredVolume) then obj_DeliveredVolume / 1 [k_m3]
                        elseif (objid = __ProcessedVolume) then obj_ProcessedVolume / 1 [k_m3]
                        elseif (objid = __HaulCost) 			then obj_HaulCost / 1 [$]
                        elseif (objid = __OperatingMills) 	then obj_OperatingMills
                        elseif (objid = __ProcessedValue) 	then obj_ProcessedValue / 1 [$]
                        endif
                    }
                }
                Variable obj_HarvestVolume {
                    Range: nonnegative;
                    Unit: k_m3;
                    Definition: sum( (term,blk,prd), HarvestVolume(term,blk,prd));
                }
                Variable obj_DeliveredVolume {
                    Unit: _ProductDefaultUnit;
                    Definition: {
                        sum((term,blk,dest,gProd) , DeliveredVolume(term,blk,dest,gProd))
                        +
                        sum((term,destFrom,DestTo,gProd) , DeliveredResidualVolume(term,destFrom,DestTo,gProd))
                    }
                }
                Variable obj_convertedvolume {
                    IndexDomain: (term,blk,prOUT) | blk in AvailableBlocks;
                    Range: free;
                    Unit: k_m3;
                }
                Variable obj_ProcessedVolume {
                    Unit: k_m3;
                    Definition: sum((term,dest,gpr), ProcessedVolume(term,dest,gpr)  );
                }
                Variable obj_HaulCost {
                    Range: nonnegative;
                    Unit: 1000 * $;
                    Definition: sum((term,src,dest,gProd), DeliveredHaulCost(term,src,dest,gProd)  );
                }
                Variable obj_ProcessedValue {
                    Range: nonnegative;
                    Unit: 1000 * $;
                    Definition: sum [(term,dest,gpr), ProcessedVolume(term,dest,gpr) * ProductValue(dest,gpr)];
                }
                Variable obj_OperatingMills {
                    Range: free;
                    Unit: 1;
                    Definition: sum [(dest),MillIsAvailable(dest) ];
                }
                Assertion Assert_SelectedObjHaveWeight {
                    IndexDomain: objId | obj_Selected(objId);
                    Property: WarnOnly;
                    AssertLimit: 1;
                    Definition: obj_Weights(objId) > 0;
                }
                Set AvailableBlocks {
                    SubsetOf: Blocks;
                    Index: aBlk;
                    Property: NoSave;
                    OrderBy: aBlk;
                    Definition: {
                        { blk | if IsSelected(__IncludeOnlyAvailableBlocks)  then IsAvailable(blk) else 1 endif }
                    }
                }
                Set AvailableDest {
                    SubsetOf: Destinations;
                    Index: aDest, aDest1;
                    Property: NoSave;
                    Definition: {
                        { dest | if IsSelected(__IncludeOnlyAvailableMills) then IncludeMill(dest) else 1 endif }
                    }
                }
            }
            Procedure InitializeObjidElementParameters {
                Body: {
                    __HarvestVolume 	:= 'obj_HarvestVolume';
                    __DeliveredVolume := 'obj_DeliveredVolume';
                    __ProcessedVolume := 'obj_ProcessedVolume';
                    __HaulCost 		:= 'obj_HaulCost';
                    __OperatingMills := 'obj_OperatingMills';
                    __ProcessedValue := 'obj_ProcessedValue';
                }
            }
            DeclarationSection Decision_Variables {
                Parameter MapResultsOnly {
                    Text: "Map results, but prohibit solving model";
                    Range: binary;
                    Default: 0;
                    Definition: {
                        ! used to set non-var status of decision variables
                    }
                }
                Variable DeliveredBlockVolume_VAR {
                    IndexDomain: {
                        (term,blk,prd,dest,gPrGrp)| [ (blk,dest) in TimePermittedSupplyRoutes ]
                        and  GSAvailable(blk,prd)
                        and dest in AvailableDest
                        and blk in AvailableBlocks
                        and UsesProducts(dest)
                        and ProductsUsed_PrGrp(dest,gPrGrp)
                        and ProductsUsed(dest,prd) ! this may be redundant
                        and cPrG(gPrGrp,prd)
                    }
                    Text: "Volume of Prd delivered from blk to Dest in term to meet demand for gPrGrp";
                    Range: nonnegative;
                    Unit: ProductUnit(prd);
                    NonvarStatus: MapResultsOnly;
                    Comment: "prd is primary product (not residuals)";
                }
                Parameter DeliveredBlockVolume_VAR_DOM {
                    IndexDomain: {
                        (term,blk,prd,dest,gPrGrp)| 1
                        !and [ (blk,dest) in PermittedRoutes ] and  GSAvailable(blk,prd)
                        !and if IsSelected(_IncludeOnlyAvailableMills) then IncludeMill(dest) else 1 endif
                        !and UsesProducts(dest)
                        !and ProductsUsed_PrGrp(dest,gPrGrp)
                        !and ProductsUsed(dest,prd) ! this may be redundant
                        !and cPrG(gPrGrp,prd)
                    }
                    Text: "Volume of Prd delivered from blk to Dest in term to meet demand for gPrGrp";
                    Range: nonnegative;
                    Unit: 1;
                    Property: NoSave;
                    Definition: {
                        1$
                        [ (blk,dest) in TimePermittedSupplyRoutes ]
                        and  GSAvailable(blk,prd)
                        and blk in AvailableBlocks
                        and dest in AvailableDest
                        and UsesProducts(dest)
                        and ProductsUsed_PrGrp(dest,gPrGrp)
                        and ProductsUsed(dest,prd) ! this may be redundant
                        and cPrG(gPrGrp,prd)
                    }
                    Comment: "prd is primary product (not residuals)";
                }
                Parameter DeliveredBlockVolume_PARAM {
                    IndexDomain: {
                        (term,blk,prd,dest,gPrGrp)| 1
                        !and [ (blk,dest) in PermittedRoutes ] and  GSAvailable(blk,prd)
                        !and if IsSelected(_IncludeOnlyAvailableMills) then IncludeMill(dest) else 1 endif
                        !and UsesProducts(dest)
                        !and ProductsUsed_PrGrp(dest,gPrGrp)
                        !and ProductsUsed(dest,prd) ! this may be redundant
                        !and cPrG(gPrGrp,prd)
                    }
                    Text: "Volume of Prd delivered from blk to Dest in term to meet demand for gPrGrp";
                    Range: nonnegative;
                    Unit: ProductUnit(prd);
                    Property: NoSave;
                    Definition: {
                        ! Warning: This works but need to automate index domain
                    }
                    Comment: "prd is primary product (not residuals)";
                }
                Variable DeliveredResidualVolume_VAR {
                    IndexDomain: {
                        (term,src,gres,DestTo,ResGrp)| IsValidResidualDelivery_Dom(src,gres,DestTo,ResGrp)
                        !dk: Jan 2010: Not sure why this is here or [ (src,DestTo) in PermittedRoutes ]
                    }
                    Text: "Volume of gRes delivered from DestFrom in term to DestTo to meet demand for ResGrp";
                    Range: nonnegative;
                    Unit: ProductUnit(gRes);
                    NonvarStatus: MapResultsOnly;
                    Definition: {
                        /* OLD INdex Domain
                        (destFrom,DestTo,res)  in PermittedRoutesForProducts and destFrom <> DestTo
                        and cPrG(ResGrp,res)                                ! res contributes to ResGrp
                        !and ProducesResiduals(destFrom)
                        and sum[ prd,ResidualsProduced(destFrom,prd,res)]   !DestFrom produces res
                        and  ResidualsUsed_PrGrp(DestTo,ResGrp)             !DestTo uses ResGrp
                        !and ResidualsUsed(DestTo,res)                       ! this may be redundant
                        */
                    }
                }
                Parameter DeliveredResidualVolume_VAR_DOM {
                    IndexDomain: {
                        (term,destFrom,res,DestTo,ResGrp)!| IsValidResidualDelivery_Dom(src,gres,DestTo,ResGrp)
                        !dk: Jan 2010: Not sure why this is here or [ (src,DestTo) in PermittedRoutes ]
                    }
                    Text: "Volume of gRes delivered from DestFrom in term to DestTo to meet demand for ResGrp";
                    Range: nonnegative;
                    Unit: 1;
                    Property: NoSave;
                    Definition: {
                        1$  (destFrom,DestTo,res)  in TimePermittedRoutesForProducts
                        !!amd [ (destFrom,DestTo) in PermittedRoutes ]
                        !!and destFrom <> DestTo
                        and  if IsSelected(__IncludeOnlyAvailableMills) then IncludeMill(DestTo) else 1 endif
                        and cPrG(ResGrp,res)
                        and ProducesResiduals(destFrom)
                        and UsesResiduals(destTo)
                        and sum[ gpr,ResidualsProduced(destFrom,gpr,res)]   !DestFrom produces res
                        and  ResidualsUsed_PrGrp(DestTo,ResGrp)             !DestTo uses ResGrp
                    }
                }
                Parameter DeliveredResidualVolume_PARAM {
                    IndexDomain: {
                        (term,dest,res,DestTo,ResGrp)!| IsValidResidualDelivery_Dom(src,gres,DestTo,ResGrp)
                        !dk: Jan 2010: Not sure why this is here or [ (src,DestTo) in PermittedRoutes ]
                    }
                    Text: "Volume of gRes delivered from DestFrom in term to DestTo to meet demand for ResGrp";
                    Range: nonnegative;
                    Unit: ProductUnit(res);
                    Property: NoSave;
                    Definition: {
                        /* OLD INdex Domain
                        (destFrom,DestTo,res)  in PermittedRoutesForProducts and destFrom <> DestTo
                        and cPrG(ResGrp,res)                                ! res contributes to ResGrp
                        !and ProducesResiduals(destFrom)
                        and sum[ prd,ResidualsProduced(destFrom,prd,res)]   !DestFrom produces res
                        and  ResidualsUsed_PrGrp(DestTo,ResGrp)             !DestTo uses ResGrp
                        !and ResidualsUsed(DestTo,res)                       ! this may be redundant
                        */
                    }
                }
            }
            Procedure MainTenureModelProcedure {
                Arguments: (PresolveDumpFilename,QAmode);
                Body: {
                    block ! initialization
                            CheckBeforeSolve;
                    	! debuggerbreakpoint;
                    	empty AllVariables;
                    	cleandependents AllLocations;
                    endblock;
                    
                    block !set upper targets = to lower
                    	if IsSelected(__SetUpperTargets) then
                    		!SetUpperTargetsEqualLower;! - but uses temp parameters
                    		if IsSelected(__MeetVolumeTargets) then
                    			Temp_MillDemand_PrGrp(dest,PrGrp,tp) 	:=$  MillDemand_PrGrp(dest,PrGrp,__max,tp);
                    			MillDemand_PrGrp(dest,PrGrp,__max,tp) 	:=$  MillDemand_PrGrp(dest,PrGrp,__min,tp);
                    		endif;
                    
                    		if (IsSelected(_SimulateTREES)) then
                    			Temp_TreesFlow(term,mu,dest,prd)  :=$  TreesFlow(term,mu,dest,prd,__max);
                    			TreesFlow(term,mu,dest,prd,__max)  :=$  TreesFlow(term,mu,dest,prd,__min);
                    		endif;
                    	endif;
                    endblock;
                    
                    block ! set NonVarstatus unless MIP (select mills available to receive wood)
                    	if IsSelected(__BinaryMills) = 0 then 		!... not a binary model
                    		MillIsAvailable(dest) := 1;			! all destinations are available
                    	endif;
                    endblock;
                    
                    block ! ***** SOLVE MODEL ******
                    	! Note that LP_type is determined by 'Binary Mills" option and defined in LP_type
                    	if QAmode  then qapreslv(PresolveDumpFilename); endif;
                    
                    	if (1) then !allow violations
                    		SetViolationPenalties;
                    		!solve Optimize_WithSlack where type :=  LP_type;
                    		solve OptimizeWFlow where type :=  LP_type;
                    		i := count(isc | Card(iSC, 'violation'));	! count the number of violations (isc is index into 'WFlowConstraints')
                    		if i>0  then
                    			empty s;
                    			for (isc | Card(iSC, 'violation')) do
                    				s += FormatString("%e\n",isc);
                    			endfor;
                    
                    			if not QAmode then dialogMessage(
                    				FormatString("The following %i constraints were violated\n\n%s",i,s)
                    				!formatstring("Programstatus:\t%s\nInfeasibilities:\t%i", ""+Optimize_WithSlack.programstatus,i)
                    					 ,"Solution Status");
                    			endif;
                    		endif;
                    	else
                    		block ! Necessary to make sure no .violations hang around
                    			MeetMillAllDemandPrGrp_Lower.Violation (term,dest,gPrGrp,tt,tp) := 0;
                    			MeetMillAllDemandPrGrp_Upper.Violation (term,dest,gPrGrp,tt,tp) := 0;
                    		endblock;
                    
                    		if not QAmode and  OptimizeWFlow.programstatus <> 'Optimal' then
                    			DialogMessage(
                    				FormatString("Programstatus:\t%s\nInfeasibilities:\t%i", ""+OptimizeWFlow.programstatus
                    					,OptimizeWFlow.NumberOfInfeasibilities) ,"Solution Status");
                    		endif;
                    	endif;
                    endblock;
                    
                    block !reset upper targets
                    	if IsSelected(__SetUpperTargets) then
                    		!SetUpperTargetsEqualLower;! - but uses temp parameters
                    		if IsSelected(__MeetVolumeTargets) then
                    			empty MillDemand_PrGrp(dest,PrGrp,__max,tp);
                    			MillDemand_PrGrp(dest,PrGrp,__max,tp) 	:=$  Temp_MillDemand_PrGrp(dest,PrGrp,tp);
                    		endif;
                    		if (IsSelected(_SimulateTREES)) then
                    			empty TreesFlow(term,mu,dest,prd,__max);
                    			TreesFlow(term,mu,dest,prd,__max)  :=$ Temp_TreesFlow(term,mu,dest,prd) ;
                    		endif;
                    	endif;
                    endblock;
                    
                    pageRefreshAll;
                }
                Parameter Temp_MillDemand_PrGrp {
                    IndexDomain: (dest,PrGrp,tp);
                    Unit: ProductGroupUnit(PrGrp);
                }
                Parameter Temp_TreesFlow {
                    IndexDomain: (term,mu,dest,prd);
                    Unit: m3;
                }
                Parameter i;
                StringParameter s;
                StringParameter PresolveDumpFilename {
                    Property: Input;
                }
                Parameter QAmode {
                    Range: binary;
                    Property: Input;
                }
            }
            Procedure InfeasibleWoodFlowExecution {
                Body: {
                    CheckBeforeSolve;
                    
                    SetViolationPenalties;
                    
                    if IsSelected(__BinaryMills) = 0 then
                    	MillIsAvailable(dest) := 1;
                    endif;
                    
                    solve Optimize_WithSlack where type :=  LP_type;
                }
            }
            Procedure SetViolationPenalties {
                Body: {
                    block !Initialization
                        !--- set penalties only for commitments not met
                        !empty ViolationPenalty_NEW;
                        if IsSelected(__MeetVolumeTargets) then
                    	!ViolationPenalty_NEW('MeetMillAllDemandPrGrp_Lower') |(not ViolationPenalty_NEW('MeetMillAllDemandPrGrp_Lower')) := 100;
                    	!ViolationPenalty_NEW('MeetMillAllDemandPrGrp_Upper') |( not ViolationPenalty_NEW('MeetMillAllDemandPrGrp_Upper')) := 100;
                    	SetThresholdViolationPenalties;
                        endif;
                    
                        if IsSelected(_SimulateTREES) then
                        	ViolationPenalty_NEW('MeetTreesTotalFlow_Lower')|(not ViolationPenalty_NEW('MeetTreesTotalFlow_Lower')) := 100;
                        	ViolationPenalty_NEW('MeetTreesTotalFlow_Upper')|(not ViolationPenalty_NEW('MeetTreesTotalFlow_Upper')) := 100;
                    
                        	if IsSelected(__SimulateTREESByMU) then
                    		ViolationPenalty_NEW('MeetTreesFlow_Lower')|(not ViolationPenalty_NEW('MeetTreesFlow_Lower'))  		:= 100;
                    		ViolationPenalty_NEW('MeetTreesFlow_Upper')|(not ViolationPenalty_NEW('MeetTreesFlow_Upper'))		:= 100;
                        	endif;
                        endif;
                    endblock;
                }
            }
            Procedure MIPWoodFlowExecution {
                Body: {
                    CheckBeforeSolve;
                    !DebuggerBreakpoint;
                    empty Allconstraints,allvariables;
                    block !Initialization
                        !--- set penalties only for commitments not met
                    !    !empty ViolationPenalty_NEW;
                    !    ViolationPenalty_NEW('MeetMillAllDemandPrGrp_Lower') := 100;
                    !    ViolationPenalty_NEW('MeetMillAllDemandPrGrp_Upper') := 100;
                        if IsSelected('Simulate TREES') then
                        	! let model slack off MU-level targets
                    !    	ViolationPenalty_NEW('MeetTreesFlow_Lower')|(ViolationPenalty_NEW('MeetTreesFlow_Lower')=0)  		:= 100;
                    !    	ViolationPenalty_NEW('MeetTreesFlow_Upper')|(ViolationPenalty_NEW('MeetTreesFlow_Upper')=0)			:= 100;
                        	ViolationPenalty_NEW('MeetTreesFlow_Lower')  	:= 0;
                        	ViolationPenalty_NEW('MeetTreesFlow_Upper')		:= 0;
                        	ViolationPenalty_NEW('MeetTreesTotalFlow_Lower') := 0;
                        	ViolationPenalty_NEW('MeetTreesTotalFlow_Upper') := 0;
                    !    	ViolationPenalty_NEW('MeetTreesTotalFlow_Lower')|(ViolationPenalty_NEW('MeetTreesTotalFlow_Lower')=0) := 100;
                    !    	ViolationPenalty_NEW('MeetTreesTotalFlow_Upper')|(ViolationPenalty_NEW('MeetTreesTotalFlow_Upper')=0) := 100;
                        endif;
                    endblock;
                    
                    ! --- ensure binary is selected
                    if (IsSelected(__BinaryMills) = 0) then
                    	IsSelected(__BinaryMills) :=1; endif;
                    
                    if NonVarStatus_BinaryVar = 1 then
                    	MillIsAvailable(dest) := 1;
                    	!MillIsAvailable(dest).nonvar := 1;
                    else
                    	empty MillIsAvailable;
                    	!MillIsAvailable(dest).nonvar := 0;
                    endif;
                    
                    empty 	MeetTreesFlow_lower.Violation,		MeetTreesFlow_upper.Violation,
                    		MeetTreesTotalFlow_lower.Violation,	MeetTreesTotalFlow_upper.Violation;
                    
                    
                    ! Set upper targets equal to lower
                    TreesFlow(term,mu,dest,prd,__max)		:=$  TreesFlow(term,mu,dest,prd,__min);
                    MillDemand_PrGrp(dest,PrGrp,__max,tp) 	:=$  MillDemand_PrGrp(dest,PrGrp,__min,tp);
                    
                    ! dk: Feb 2010 - remove ViolationPenalty_NEW from Model
                    solve MIPTenure ! where type :=  LP_type;
                }
            }
            Procedure EmptyUpperTargets {
                Body: {
                    block !reset upper targets
                    
                    				empty MillDemand_PrGrp(dest,PrGrp,__max,tp),TreesFlow(term,mu,dest,prd,__max);
                    
                    endblock;
                }
            }
            DeclarationSection InfeasibleModel {
                Parameter NumberOfInfeasibilities {
                    Definition: {
                        CountOfViolations
                        !Optimize_WithSlack.NumberOfInfeasibilities
                    }
                }
                Parameter SumOfInfeasibilities {
                    Unit: _ProductDefaultUnit;
                    Definition: {
                        SumOfViolations
                        !Optimize_WithSlack.SumOfInfeasibilities
                    }
                }
                Set ConstraintsWithPenalties {
                    SubsetOf: AllVariablesConstraints;
                    Text: "Constraints for which users can set violation penalties";
                    Index: ivp;
                    Definition: {
                        ! MILL Demand
                         { 'MeetMillAllDemandPrGrp_Lower'		,		'MeetMillAllDemandPrGrp_Upper' } ! $ IsSelected(_MeetVolumeTargets)
                        ! Mill Demand Thresholds
                        + ThresholdVariablesConstraints
                        
                        !TREES related
                        + {'MeetTreesTotalFlow_Lower'		,		'MeetTreesTotalFlow_Upper'} !$ IsSelected(_SimulateTREES)
                        + {'MeetTreesFlow_Lower'			,		'MeetTreesFlow_Upper' } 	!$ IsSelected(_SimulateTREESbyMu)
                        
                        ! Residual Flow
                        + { 'MeetResidualFlow_lower'  ,   'MeetResidualFlow_upper' } !$ IsSelected(_ResidualFlowTargets)
                        
                        ! Cost Balance
                        + { 'ProductValueExceedsHaulCost' , 'CostCentreBalance'  } !$ IsSelected(_CostCentreBalance)
                    }
                }
                Set GUIVariablesConstraintsWithViolationPenalties {
                    SubsetOf: AllVariablesConstraints;
                    Text: "Constraints for which users can set violation penalties";
                    Index: GUIivp;
                    Property: NoSave;
                    Definition: {
                        ! MILL Demand
                         { 'MeetMillAllDemandPrGrp_Lower'		,		'MeetMillAllDemandPrGrp_Upper' }  $ IsSelected(__MeetVolumeTargets)
                        ! Mill Demand Thresholds
                        + ThresholdVariablesConstraints
                        
                        !TREES related
                        + {'MeetTreesTotalFlow_Lower'		,		'MeetTreesTotalFlow_Upper'} $ IsSelected(_SimulateTREES)
                        + {'MeetTreesFlow_Lower'			,		'MeetTreesFlow_Upper' } 	$ IsSelected(__SimulateTREESByMU)
                        
                        ! Residual Flow
                        + { 'MeetResidualFlow_lower'  ,   'MeetResidualFlow_upper' } $ IsSelected(__ResidualFlowTargets)
                        
                        ! Cost Balance
                        + { 'ProductValueExceedsHaulCost' , 'CostCentreBalance'  } $ IsSelected(__CostCentreBalance)
                    }
                }
                Set ThresholdVariablesConstraints {
                    SubsetOf: AllVariablesConstraints;
                    Text: "Threshold Constraints for which users can set violation penalties";
                    Property: NoSave;
                    Definition: {
                        ! Threshold related
                        ThresholdConstraints $ IsSelected(__ThresholdPenalties)
                        !{ 'MeetThresholdDemand_High' , 'MeetThresholdDemand_Low' ,
                        !	'MeetThresholdDemand_Mod'	, 'MeetThresholdDemand_Sig'} 		$ IsSelected(_ThresholdPenalties)
                    }
                }
                Set BindingConstraints {
                    SubsetOf: ConstraintsWithPenalties;
                    Property: NoSave;
                    Definition: {
                        {ivp |
                           [ ivp ='MeetMillAllDemandPrGrp_Lower' and count[ (term, dest, gPrGrp, tt, tp)
                        	| MeetMillAllDemandPrGrp_Lower(term, dest, gPrGrp, tt, tp).basic = 'Nonbasic' ] ]
                        or [ ivp ='MeetMillAllDemandPrGrp_Upper' and count[ (term, dest, gPrGrp, tt, tp)
                        	| MeetMillAllDemandPrGrp_Upper(term, dest, gPrGrp, tt, tp).basic = 'Nonbasic' ] ]
                        
                        or [ ivp ='MeetThresholdDemand_High' and count[ (term, dest, thr, gPrGrp, tp)
                        	| MeetThresholdDemand_High(term, dest, thr, gPrGrp, tp).basic = 'Nonbasic' ] ]
                        or [ ivp ='MeetThresholdDemand_Sig' and count[ (term, dest, thr, gPrGrp, tp)
                        	| MeetThresholdDemand_Sig(term, dest, thr, gPrGrp, tp).basic = 'Nonbasic' ] ]
                        or [ ivp ='MeetThresholdDemand_Mod' and count[ (term, dest, thr, gPrGrp, tp)
                        	| MeetThresholdDemand_Mod(term, dest, thr, gPrGrp, tp).basic = 'Nonbasic' ] ]
                        or [ ivp ='MeetThresholdDemand_Low' and count[ (term, dest, thr, gPrGrp, tp)
                        	| MeetThresholdDemand_Low(term, dest, thr, gPrGrp, tp).basic = 'Nonbasic' ] ]
                        
                        or [ ivp ='MeetTreesTotalFlow_Lower' and count[ (term, dest, prd)
                        	| MeetTreesTotalFlow_lower(term, dest, prd).basic = 'Nonbasic' ] ]
                        or [ ivp ='MeetTreesTotalFlow_Upper' and count[ (term, dest, prd)
                        	| MeetTreesTotalFlow_Upper(term, dest, prd).basic = 'Nonbasic' ] ]
                        or [ ivp ='MeetTreesFlow_Lower' and count[ (term, mu, dest, prd)
                        	| MeetTreesFlow_lower(term, mu, dest, prd).basic = 'Nonbasic' ] ]
                        or [ ivp ='MeetTreesFlow_Upper' and count[ (term, mu, dest, prd)
                        	| MeetTreesFlow_Upper(term, mu, dest, prd).basic = 'Nonbasic' ] ]
                        
                        or [ ivp ='MeetResidualFlow_lower' and count[ (term, destFrom, DestTo, res)
                        	| MeetResidualFlow_lower(term, destFrom, DestTo, res).basic = 'Nonbasic' ] ]
                        or [ ivp ='MeetResidualFlow_upper' and count[ (term, destFrom, DestTo, res)
                        	| MeetResidualFlow_upper(term, destFrom, DestTo, res).basic = 'Nonbasic' ] ]
                        
                        or [ ivp ='ProductValueExceedsHaulCost' and count[ (dest)
                        	| ProductValueExceedsHaulCost(dest).basic = 'Nonbasic' ] ]
                        or [ ivp ='CostCentreBalance' and count[ (iCost)
                        	| CostCentreBalance(iCost).basic = 'Nonbasic' ] ]
                        }
                    }
                }
                Set ViolatedConstraints {
                    SubsetOf: ConstraintsWithPenalties;
                    Property: NoSave;
                    Definition: {
                        {ivp |
                           [ ivp ='MeetMillAllDemandPrGrp_Lower' and count[ (term, dest, gPrGrp, tt, tp)
                        	| MeetMillAllDemandPrGrp_Lower(term, dest, gPrGrp, tt, tp).violation ] ]
                        or [ ivp ='MeetMillAllDemandPrGrp_Upper' and count[ (term, dest, gPrGrp, tt, tp)
                        	| MeetMillAllDemandPrGrp_Upper(term, dest, gPrGrp, tt, tp).violation ] ]
                        
                        or [ ivp ='MeetThresholdDemand_High' and count[ (term, dest, thr, gPrGrp, tp)
                        	| MeetThresholdDemand_High(term, dest, thr, gPrGrp, tp).violation ] ]
                        or [ ivp ='MeetThresholdDemand_Sig' and count[ (term, dest, thr, gPrGrp, tp)
                        	| MeetThresholdDemand_Sig(term, dest, thr, gPrGrp, tp).violation ] ]
                        or [ ivp ='MeetThresholdDemand_Mod' and count[ (term, dest, thr, gPrGrp, tp)
                        	| MeetThresholdDemand_Mod(term, dest, thr, gPrGrp, tp).violation ] ]
                        or [ ivp ='MeetThresholdDemand_Low' and count[ (term, dest, thr, gPrGrp, tp)
                        	| MeetThresholdDemand_Low(term, dest, thr, gPrGrp, tp).violation ] ]
                        
                        or [ ivp ='MeetTreesTotalFlow_Lower' and count[ (term, dest, prd)
                        	| MeetTreesTotalFlow_lower(term, dest, prd).violation ] ]
                        or [ ivp ='MeetTreesTotalFlow_Upper' and count[ (term, dest, prd)
                        	| MeetTreesTotalFlow_Upper(term, dest, prd).violation ] ]
                        or [ ivp ='MeetTreesFlow_Lower' and count[ (term, mu, dest, prd)
                        	| MeetTreesFlow_lower(term, mu, dest, prd).violation ] ]
                        or [ ivp ='MeetTreesFlow_Upper' and count[ (term, mu, dest, prd)
                        	| MeetTreesFlow_Upper(term, mu, dest, prd).violation ] ]
                        
                        or [ ivp ='MeetResidualFlow_lower' and count[ (term, destFrom, DestTo, res)
                        	| MeetResidualFlow_lower(term, destFrom, DestTo, res).violation ] ]
                        or [ ivp ='MeetResidualFlow_upper' and count[ (term, destFrom, DestTo, res)
                        	| MeetResidualFlow_upper(term, destFrom, DestTo, res).violation ] ]
                        
                        or [ ivp ='ProductValueExceedsHaulCost' and count[ (dest)
                        	| ProductValueExceedsHaulCost(dest).violation ] ]
                        or [ ivp ='CostCentreBalance' and count[ (iCost)
                        	| CostCentreBalance(iCost).violation ] ]
                        }
                    }
                }
                Parameter ViolationPenalty {
                    IndexDomain: (ivp);
                    Definition: {
                        !formerly IndexVariablesConstraints
                    }
                }
                Parameter ViolationPenalty_NEW {
                    IndexDomain: (ivp);
                    Definition: {
                        !formerly IndexVariablesConstraints
                    }
                }
                Parameter SumOfViolations {
                    Unit: _ProductDefaultUnit;
                    Definition: {
                        !sum(IndexVariablesConstraints | ViolationPenalty_NEW(IndexVariablesConstraints)
                        !, Abs(IndexVariablesConstraints.violation))
                        
                        abs(sum((term,dest,gPrGrp,tt,tp),MeetMillAllDemandPrGrp_Lower.Violation(term,dest,gPrGrp,tt,tp)))
                        +
                        abs(sum((term,dest,gPrGrp,tt,tp),MeetMillAllDemandPrGrp_Upper.Violation(term,dest,gPrGrp,tt,tp)))
                    }
                }
                Parameter CountOfViolations {
                    Property: NoSave;
                    Definition: {
                        !sum(IndexVariablesConstraints | ViolationPenalty_NEW(IndexVariablesConstraints)
                        !, Abs(IndexVariablesConstraints.violation))
                        
                        (count((term,dest,gPrGrp,tt,tp) | MeetMillAllDemandPrGrp_Lower.Violation(term,dest,gPrGrp,tt,tp)))
                        +
                        (count((term,dest,gPrGrp,tt,tp) | MeetMillAllDemandPrGrp_Upper.Violation(term,dest,gPrGrp,tt,tp)))
                    }
                }
            }
            DeclarationSection Domain_Identifiers {
                Parameter IsAvailable {
                    IndexDomain: (blk);
                    Text: "Volume in blk is available";
                    Range: binary;
                    Property: NoSave;
                    Definition: {
                        if IsSelected(__IncludeOnlyAvailableBlocks) then
                        	1 $ PercentBlockAvailable(blk) > 0
                        
                        else ! include all InitialGS in block
                         1
                        endif
                    }
                    Comment: "dk: Feb 2010";
                }
                Parameter SectorHasDemand {
                    IndexDomain: (sect);
                    Range: binary;
                    Property: NoSave;
                    Definition: {
                        1 $ sum [(dest)  | cMillSector(sect,dest), DestHasDemand(dest) ]
                        
                        !1 $ sum[(dest,gPrGrp,tt,tp) | MillSectorRelation(sect,dest), (MillDemand_PrGrp(dest,gPrGrp,tt,tp)
                        !		+ MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp))
                        !		]
                    }
                }
                Parameter DestHasDemand {
                    IndexDomain: dest;
                    Range: binary;
                    Property: NoSave;
                    Definition: {
                        1 $ sum[(gPrGrp,tt,tp) , (MillDemand_PrGrp(dest,gPrGrp,tt,tp)
                        		+ MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp))
                        		]
                    }
                }
                Parameter MillDemand_DOM {
                    IndexDomain: {
                        (term,dest,gPrGrp,tt,tp) |
                        ( MillDemand_PrGrp(dest,gPrGrp,tt,tp) $ [UsesProducts(dest) and ProductsUsed_PrGrp(dest,gPrGrp)] )
                         or
                         ( [MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp)]  $ [UsesResiduals(dest) and ResidualsUsed_PrGrp(dest,gPrGrp)] )
                    }
                    Range: binary;
                    Unit: 1;
                    Property: NoSave;
                    Definition: 1;
                }
            }
            DeclarationSection Landbase_and_HarvestVolumes {
                Variable GrowingStock {
                    IndexDomain: (term,blk,prd) | GSAvailable(blk,prd) and blk in AvailableBlocks;
                    Range: nonnegative;
                    Unit: ProductUnit(prd);
                    Property: ReducedCost;
                    Definition: {
                        ! changed to constraint
                        !if ord(term) = 1 then
                        !        GSAvailable(blk,prd)
                        !else
                        !        GrowingStock(term-1,blk,prd) - HarvestVolume(term-1,blk,prd)
                        !endif
                    }
                }
                Constraint GrowingStock_Def {
                    IndexDomain: (term,blk,prd) | GSAvailable(blk,prd) and blk in AvailableBlocks;
                    Unit: ProductUnit(prd);
                    Definition: {
                        GrowingStock(term, blk, prd)
                        =
                        if ord(term) = 1 then
                        	GsAvailable(blk,prd)
                        else
                        	GrowingStock(term-1,blk,prd) - HarvestVolume(term-1, blk, prd)
                        endif
                    }
                }
                Variable HarvestVolume {
                    IndexDomain: (term,blk,prd) | GSAvailable(blk,prd) and blk in AvailableBlocks;
                    Range: nonnegative;
                    Unit: ProductUnit(prd);
                    Property: ReducedCost;
                }
                Variable VolumeNotHarvested {
                    IndexDomain: (blk,prd) | GSAvailable(blk,prd) and blk in AvailableBlocks;
                    Range: nonnegative;
                    Unit: m3;
                    Definition: GSAvailable(blk,prd) - sum [(term),HarvestVolume(term,blk,prd) ];
                }
                Parameter FinalGrowingStock {
                    IndexDomain: {
                        (term,blk,prd) | InitialGS(blk,prd) !and ord(term) = card(term)
                    }
                    Unit: ProductUnit(prd);
                    Property: NoSave;
                    Definition: {
                        !sum( term | ord(term) = card(term),      ! for last term, Start GS - harvestVolume
                        
                         GrowingStock(term,blk,prd) - HarvestVolume(term,blk,prd)
                         !)
                    }
                }
                Constraint NoOverHarvest {
                    IndexDomain: (term,blk,prd) | GSAvailable(blk,prd) and blk in AvailableBlocks;
                    Unit: ProductUnit(prd);
                    Definition: HarvestVolume(term,blk,prd) <= GrowingStock(term,blk,prd);
                }
            }
            DeclarationSection Delivered_and_Processed_Volume {
                Variable DeliveredVolume {
                    IndexDomain: {
                        (term,blk,dest,prd) | [ (blk,dest) in TimePermittedSupplyRoutes ] and UsesProducts(dest)
                        and ProductsUsed(dest,prd) and GSAvailable(blk,prd)
                        and blk in AvailableBlocks
                        and dest in AvailableDest
                    }
                    Text: "Volume of prd deliered to Dest in term";
                    Range: nonnegative;
                    Unit: ProductUnit(prd);
                    Definition: sum [(gPrGrp), DeliveredBlockVolume_VAR(term,blk,prd,dest,gPrGrp)];
                    Comment: "prd is primary product (not residuals)";
                }
                Variable DeliveredAllVolume_PrGrp {
                    IndexDomain: {
                        (term,adest,gPrGrp) | ProductsUsed_PrGrp(adest,gPrGrp) or ResidualsUsed_PrGrp(adest,gPrGrp)
                        !and adest in AvailableDest
                    }
                    Text: "Volume of gPrGrp deliered to Dest in term";
                    Range: nonnegative;
                    Unit: ProductGroupUnit(gPrGrp);
                    Definition: {
                        sum [(blk,prd), DeliveredBlockVolume_VAR(term,blk,prd,adest,gPrGrp)]
                        +
                        sum [(destFrom,res), DeliveredResidualVolume_VAR(term,destFrom,res,adest,gPrGrp)]
                        !sum((prd,blk),DeliveredVolume(term,blk,dest,prd) $ cPrG(gPrGrp,prd))
                        !+
                        !sum((res,DestFrom), DeliveredResidualVolume(term,destFrom,dest,res)
                        !	 $ cPrG(gPrGrp,res))
                    }
                    Comment: "prd is primary product (not residuals)";
                }
                Parameter TEST_DeliveredAllVolume_PrGrp {
                    IndexDomain: {
                        (term,dest,gPrGrp) !| ProductsUsed_PrGrp(dest,gPrGrp) or ResidualsUsed_PrGrp(dest,gPrGrp)
                    }
                    Text: "Volume of gPrGrp deliered to Dest in term";
                    Range: nonnegative;
                    Unit: ProductGroupUnit(gPrGrp);
                    Definition: {
                        /*sum [(blk,prd), DeliveredBlockVolume_VAR(term,blk,prd,dest,gPrGrp)]
                        + */
                        sum [(destFrom,res), DeliveredResidualVolume_VAR(term,destFrom,res,dest,gPrGrp)]
                        !cPrG
                    }
                    Comment: "prd is primary product (not residuals)";
                }
                Parameter DeliveredAllVolume_PrGrp_Detail {
                    IndexDomain: {
                        (term,dest,gPrGrp) | ProductsUsed_PrGrp(dest,gPrGrp) or ResidualsUsed_PrGrp(dest,gPrGrp)
                        and dest in AvailableDest
                    }
                    Text: "Volume of gPrGrp deliered to Dest in term";
                    Range: nonnegative;
                    Unit: ProductGroupUnit_k(gPrGrp);
                    Definition: {
                        sum [(blk,prd), DeliveredBlockVolume_VAR(term,blk,prd,dest,gPrGrp)]
                        +
                        sum [(destFrom,res), DeliveredResidualVolume_VAR(term,destFrom,res,dest,gPrGrp)]
                        !sum((prd,blk),DeliveredVolume(term,blk,dest,prd) $ cPrG(gPrGrp,prd))
                        !+
                        !sum((res,DestFrom), DeliveredResidualVolume(term,destFrom,dest,res)
                        !	 $ cPrG(gPrGrp,res))
                    }
                    Comment: "prd is primary product (not residuals)";
                }
                Variable DeliveredTotalVolume {
                    IndexDomain: {
                        (term,src,dest,gProd) | (src,dest,gprod) in TimePermittedRoutesForProducts
                        and dest in AvailableDest
                    }
                    Text: "Volume of gProd deliered to dest from src in term";
                    Range: nonnegative;
                    Unit: ProductUnit(gProd);
                    Definition: {
                        DeliveredVolume(term,src,dest,gProd)
                        +
                        DeliveredResidualVolume(term,src,dest,gProd)
                    }
                    Comment: "prd is primary product (not residuals)";
                }
                Constraint NoWoodToUnavailableMills {
                    IndexDomain: {
                        dest | IsSelected(__BinaryMills)! and dest in AvailableDest
                    }
                    Text: "no wood can be delivered to unavailable mills";
                    Unit: _ProductDefaultUnit;
                    Definition: {
                        sum((term,src,gProd), DeliveredTotalVolume(term,src,dest,gProd) ) 	! tot vol delivered to dest
                        	- HugeNumber * MillIsAvailable(dest)							! minus huge number
                        	<= 0 [m3]															! negative only if mill available
                    }
                }
                Constraint MeetMillAllDemandPrGrp_Lower {
                    IndexDomain: {
                        (term,dest,gPrGrp,tt,tp)| IsSelected(__MeetVolumeTargets) and
                        [ ! Generate if 'Low' threshold does not start at mill demand
                        not IsSelected(__ThresholdPenalties)
                        OR ( IsSelected(__ThresholdPenalties) AND ThresholdStart(MillSector(dest), __thrLow) < 1  )
                        ]
                         and tt = __min
                        and term >= tp.ts and term <= tp.tf  ! timperiod.start to timeperiod.finish
                        and MillDemand_DOM(term, dest, gPrGrp, tt, tp)
                        and dest in AvailableDest
                        !([ MillDemand_PrGrp(dest,gPrGrp,tt,tp) $ [UsesProducts(dest) and ProductsUsed_PrGrp(dest,gPrGrp)] ]
                        ! or [MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp)] $ [UsesResiduals(dest) and ResidualsUsed_PrGrp(dest,gPrGrp)])
                    }
                    Text: "Meet Mill Demand (minimum volume)";
                    Unit: ProductGroupUnit(gPrGrp);
                    Definition: {
                        DeliveredAllVolume_PrGrp(term,dest,gPrGrp)
                        
                        >=
                        [ MillDemand_PrGrp(dest,gPrGrp,tt,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp)
                        ] * MillIsAvailable(dest)
                    }
                }
                Constraint MeetMillAllDemandPrGrp_Upper {
                    IndexDomain: {
                        (term,dest,gPrGrp,tt,tp)| IsSelected(__MeetVolumeTargets)
                        and tt = __max
                        and term >= tp.ts and term <= tp.tf  ! timperiod.start to timeperiod.finish
                        and MillDemand_DOM(term, dest, gPrGrp, tt, tp)
                        and dest in AvailableDest
                        ! and ([ MillDemand_PrGrp(dest,gPrGrp,tt,tp) $ [UsesProducts(dest) and ProductsUsed_PrGrp(dest,gPrGrp)] ]
                        ! or [MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp)] $ [UsesResiduals(dest) and ResidualsUsed_PrGrp(dest,gPrGrp)])
                    }
                    Text: "Meet Mill Demand (maximum volume)";
                    Unit: ProductGroupUnit(gPrGrp);
                    Definition: {
                        DeliveredAllVolume_PrGrp(term,dest,gPrGrp)
                        
                        <=
                        [ MillDemand_PrGrp(dest,gPrGrp,tt,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp)
                         ] * MillIsAvailable(dest)
                    }
                }
                Constraint NoOverDelivery {
                    IndexDomain: {
                        (term,blk,prd) | GSAvailable(blk,prd)
                        and blk in AvailableBlocks
                    }
                    Text: "Delivered volume <= equivalent block volume";
                    Unit: ProductUnit(prd);
                    Definition: {
                        sum(dest,DeliveredVolume(term,blk,dest,prd))
                        <=
                        HarvestVolume(term,blk,prd)
                    }
                }
                Constraint NoOverDeliveryResidual {
                    IndexDomain: (term,destFrom,res) | destFrom in AvailableDest;
                    Text: "Delivered volume <= volume of residuals produced";
                    Unit: ProductUnit(res);
                    Definition: {
                        sum((destTo),DeliveredResidualVolume(term,destFrom,destTo,res))
                        =
                        ResidualVolumeProduced(term,destFrom,res)
                    }
                }
                Variable ProcessedVolume {
                    IndexDomain: {
                        (term,adest,gpr) | ProductsUsed(adest,gpr) or ResidualsUsed(adest,gpr)
                        !and dest in AvailableDest
                    }
                    Text: "volume of gpr processed at dest during term";
                    Range: nonnegative;
                    Unit: ProductUnit(gpr);
                    Definition: {
                        sum((blk,prd)| (gpr = prd),DeliveredVolume(term,blk,adest,prd) )
                        +
                        sum((destFrom,res) | (gpr = res), DeliveredResidualVolume(term,destFrom,adest,res))
                    }
                }
                Variable ResidualVolumeProduced {
                    IndexDomain: {
                        (term,dest,res) | sum(prd,ResidualsProduced(dest,prd,res))
                        and dest in AvailableDest
                    }
                    Text: "Volume of res produced at dest";
                    Range: nonnegative;
                    Unit: ProductUnit(res);
                    Definition: sum( prd, ProcessedVolume(term,dest,prd) * ResidualsProduced(dest,prd,res) );
                }
                Variable DeliveredResidualVolume {
                    IndexDomain: {
                        (term,destFrom,DestTo,res) | (destFrom,DestTo,res)  in TimePermittedRoutesForProducts
                        and destFrom <> DestTo and ResidualsUsed(DestTo,res)
                        
                        and destfrom in AvailableDest and destto in AvailableDest
                    }
                    Text: "Volume of res deliered to DestTo from DestFrom in term";
                    Range: nonnegative;
                    Unit: ProductUnit(res);
                    Definition: sum [(ResGrp), DeliveredResidualVolume_VAR(term,destFrom,res,DestTo,ResGrp)];
                }
                Variable DeliveredResidualVolume_PrGrp {
                    IndexDomain: {
                        (term,DestTo,ResGrp)| ResidualsUsed_PrGrp(DestTo,ResGrp)
                        and destto in AvailableDest
                    }
                    Text: "Volume of residual ResGrp deliered to DestTo from DestFrom in term";
                    Range: nonnegative;
                    Unit: ProductGroupUnit(ResGrp);
                    Definition: {
                        sum [(destFrom,Res), DeliveredBlockVolume_VAR(term,destFrom,res,DestTo,ResGrp)]
                        !sum((destFrom,res), DeliveredResidualVolume(term,destFrom,DestTo,res) $ cPrG(ResGrp,res))
                    }
                    Comment: "prd is primary product (not residuals)";
                }
            }
            DeclarationSection TREES_Related {
                Set TREES_ValidFlows {
                    SubsetOf: (ManagementUnits,Destinations);
                    Definition: {
                        { (mu,dest) |  exists[ blk | blk in AvailableBlocks and ( ValidRoutes(blk,dest) $ MU_Block_Relation(mu,blk)) ]
                        				and dest in AvailableDest
                        
                        }
                    }
                }
                Constraint MeetTreesFlow_lower {
                    IndexDomain: {
                        (term,mu,dest,prd) | TreesFlow(term,mu,dest,prd,__min)
                        and IsSelected(_SimulateTREES) and IsSelected(__SimulateTREESByMU)
                        and [ (mu,dest) in TREES_ValidFlows ]
                        !and InitialGS_mu(mu,prd) ! not generated if no GS in MU
                    }
                    Text: "Meet lower TREES flow targets (by MU)";
                    Unit: ProductUnit(prd);
                    Definition: {
                        sum(blk, DeliveredVolume(term,blk,dest,prd)$ MU_Block_Relation(mu,blk))
                        >= TreesFlow(term,mu,dest,prd,__min) * MillIsAvailable(dest)
                    }
                }
                Constraint MeetTreesFlow_upper {
                    IndexDomain: {
                        (term,mu,dest,prd) | TreesFlow(term,mu,dest,prd,__max)
                        and IsSelected(_SimulateTREES) and IsSelected(__SimulateTREESByMU)
                          and [ (mu,dest) in TREES_ValidFlows ]
                    }
                    Text: "Meet upper TREES flow targets (by MU)";
                    Unit: ProductUnit(prd);
                    Definition: {
                        sum(blk, DeliveredVolume(term,blk,dest,prd)$ MU_Block_Relation(mu,blk))
                        <= TreesFlow(term,mu,dest,prd,__max) * MillIsAvailable(dest)
                    }
                }
                Constraint MeetTreesTotalFlow_lower {
                    IndexDomain: {
                        (term,dest,prd) | TreesTotalFlow(term,dest,prd,__min) and IsSelected(_SimulateTREES)
                        and dest in AvailableDest
                    }
                    Text: "Meet lower TREES flow targets (all MUs)";
                    Unit: ProductUnit(prd);
                    Definition: {
                        sum(blk, DeliveredVolume(term,blk,dest,prd) )
                        >= TreesTotalFlow(term,dest,prd,__min) * MillIsAvailable(dest)
                    }
                }
                Constraint MeetTreesTotalFlow_upper {
                    IndexDomain: {
                        (term,dest,prd) | TreesTotalFlow(term,dest,prd,__max) and IsSelected(_SimulateTREES)
                        and dest in AvailableDest
                    }
                    Text: "Meet upper TREES flow targets (all MUs)";
                    Unit: ProductUnit(prd);
                    Definition: {
                        sum(blk, DeliveredVolume(term,blk,dest,prd))
                        >= TreesTotalFlow(term,dest,prd,__max) * MillIsAvailable(dest)
                    }
                }
            }
            DeclarationSection Residual_Flow_Related {
                Constraint MeetResidualFlow_lower {
                    IndexDomain: {
                        (term,destFrom,DestTo,res) | ResidualFlow(term,destFrom,DestTo,res,__min)
                        and IsSelected(__ResidualFlowTargets)
                        and [ ValidRoutes(destfrom,DestTo) ]
                        and destFrom in AvailableDest and DestTo in AvailableDest
                    }
                    Text: "Meet minimum targets for resdual flow";
                    Unit: ProductUnit(res);
                    Definition: {
                        DeliveredResidualVolume(term,destfrom,DestTo,res)
                        >= ResidualFlow(term,destfrom,DestTo,res,__min) * MillIsAvailable(destto)
                    }
                }
                Constraint MeetResidualFlow_upper {
                    IndexDomain: {
                        (term,destFrom,DestTo,res) | ResidualFlow(term,destFrom,DestTo,res,__max)
                        and IsSelected(__ResidualFlowTargets)
                        and [ ValidRoutes(destfrom,DestTo) ]
                        and destFrom in AvailableDest and DestTo in AvailableDest
                    }
                    Text: "Meet maximum targets for resdual flow";
                    Unit: ProductUnit(res);
                    Definition: {
                        DeliveredResidualVolume(term,destfrom,DestTo,res)
                        <= ResidualFlow(term,destfrom,DestTo,res,__min) * MillIsAvailable(DestTo)
                    }
                }
            }
            DeclarationSection MIP_Formulation {
                MathematicalProgram MIPTenure {
                    Objective: Obj_WFlow;
                    Direction: maximize;
                    Constraints: WFlowConstraints;
                    Variables: WFlowVariables;
                    Text: "Select Operating Mills";
                    Type: MIP;
                }
                Parameter HugeNumber {
                    Unit: _ProductDefaultUnit;
                    Definition: 9e9;
                }
                Parameter NonVarStatus_BinaryVar {
                    Range: binary;
                    Definition: 1 $ (IsSelected(__BinaryMills) = 0);
                    Comment: "dk: Jan 2010 - controls NonVarStatus of binary Variables (MillIsAvailable) 1 if not a MIP";
                }
                Parameter NonVarStatusDest_BinaryVar {
                    IndexDomain: adest;
                    Range: binary;
                    Definition: {
                        
                        if (IsSelected(__BinaryMills) = 0) then 1
                        elseif IsSelected(__ForceMillsSelected) then MillAlwaysAvailable(adest)
                        endif
                    }
                    Comment: "dk: Jan 2010 - controls NonVarStatus of binary Variables (MillIsAvailable) 1 if not a MIP";
                }
                Variable MillIsAvailable {
                    IndexDomain: {
                        adest | (UsesProducts(adest) or UsesResiduals(adest))
                        !and dest in AvailableDest
                    }
                    Text: "Destination is capable of receiving products";
                    Range: binary;
                    NonvarStatus: NonVarStatusDest_BinaryVar(aDest);
                    Definition: {
                        !nonvar status set to 1 unless model is MIP (select mills)
                        !NonVarStatus_BinaryVar
                        
                        !NonVarStatusDest_BinaryVar(dest) allows individual destinations to be pre-selected (forced to be pre-selected0
                        !LP_type
                    }
                    Comment: "See constraint NoWoodToUnavailableMills";
                }
                Constraint XXSelectAvailableMill {
                    IndexDomain: dest | IsSelected(__BinaryMills) = 0 and dest in AvailableDest;
                    Definition: {
                        ! if the option to choose which mills receive wood is NOT selected (index domain) then all
                        ! mills are available (=1)
                        ! CONSTRAINT CHANGED TO NONVAR STATUS of MillIsAvailable
                        
                        MillIsAvailable(dest) = 1
                    }
                    Comment: {
                        "dk: Jan 2010 - not needed ...     	ViolationPenalty_NEW(\'MeetTreesFlow_Lower\') := 100;"
                    }
                }
            }
            DeclarationSection Haul_Cost_and_time {
                Variable DeliveredHaulTime {
                    IndexDomain: {
                        (term,src,dest,gProd) | (src,dest,gprod) in TimePermittedRoutesForProducts
                        and dest in AvailableDest
                    }
                    Text: "m3-hours used to transport gProd from src to dest during period term";
                    Range: nonnegative;
                    Unit: hour*ProductUnit(gProd);
                    Definition: DeliveredTotalVolume(term,src,dest,gProd) * HaulTime(src,dest);
                }
                Variable DeliveredHaulCost {
                    IndexDomain: {
                        (term,src,dest,gProd) | (src,dest,gprod) in TimePermittedRoutesForProducts
                        and dest in AvailableDest
                        !and [src in AvailableBlocks or src in AvailableDest]
                    }
                    Text: "cost of transporting gProd from src to dest during period term";
                    Range: nonnegative;
                    Unit: $;
                    Definition: DeliveredTotalVolume(term,src,dest,gProd) * CalculatedTotalCostPerUnit(src,dest,gProd);
                }
                Parameter DeliveredHaulCost_DOM {
                    IndexDomain: (term,src,dest,gProd);
                    Property: NoSave;
                    Definition: {
                        1 $
                         (src,dest,gprod) in TimePermittedRoutesForProducts
                        and dest in AvailableDest
                        and [src in AvailableBlocks or src in AvailableDest]
                    }
                }
                Constraint ProductValueExceedsHaulCost {
                    IndexDomain: {
                        (dest) | IsSelected(__ValueCoversCost)
                        and ! ignore if cost control at cost centre
                        not [ IsSelected(__CostCentreBalance) and exists(iCost | cMillCostCentre(dest, iCost))]
                        and dest in AvailableDest
                    }
                    Text: "Product value (mill gate) exceeds Transportation cost for each destination";
                    Unit: $;
                    Definition: {
                        sum [(term,gpr),ProcessedVolume(term,dest,gpr) * ProductValue(dest,gpr) ]
                        >=
                        sum[(term,src,gProd),DeliveredHaulCost(term,src,dest,gProd)]
                    }
                }
                Constraint CostCentreBalance {
                    IndexDomain: {
                        (iCost) | IsSelected(__CostCentreBalance)
                        and exists(dest | cMillCostCentre(dest, iCost) and dest in AvailableDest )
                    }
                    Text: "Product value exceeds transportation costs for cost centre iCost";
                    Unit: $;
                    Definition: {
                        sum [(dest,term,gpr) | cMillCostCentre(dest, iCost),ProcessedVolume(term,dest,gpr) * ProductValue(dest,gpr) ]
                        >=
                        sum[(dest,term,src,gProd) | cMillCostCentre(dest, iCost),DeliveredHaulCost(term,src,dest,gProd)]
                    }
                }
            }
            Section Threshold_Section {
                DeclarationSection Threshold_Penalty_Related {
                    Set ThresholdConstraints {
                        SubsetOf: AllVariablesConstraints;
                        Text: "used to set violation penalties";
                        Index: thrCst;
                        Definition: {
                            { IndexVariablesConstraints
                            	| IndexVariablesConstraints in (AllVariablesConstraints  * Threshold_Section)
                            	and
                            	FindString(FormatString("%e",IndexVariablesConstraints),"MeetThreshold") >0
                            }
                            
                            !data { !'MeetThresholdDemand',
                            !MeetThresholdDemand_Low,
                            !MeetThresholdDemand_Mod,
                            !MeetThresholdDemand_Sig,
                            !MeetThresholdDemand_High
                            !}
                        }
                    }
                    Constraint MeetThresholdDemand_Low {
                        IndexDomain: {
                            (term,dest,thr,gprgrp,tp) | IsSelected(__ThresholdPenalties)
                            and dest in AvailableDest
                            and thr = __thrLow
                            and term >= tp.ts and term <= tp.tf  ! timperiod.start to timeperiod.finish
                            and IsSelected(__MeetVolumeTargets)
                            and MillDemand_DOM(term, dest, gPrGrp, __min, tp)
                            !and (  MillDemand_PrGrp(dest,gPrGrp,_min,tp) or MillResidualDemand_PrGrp(dest,gPrGrp,_min,tp))
                        }
                        Text: "Apply penalty if LOW threshold cannot be met";
                        Unit: ProductGroupUnit(gPrGrp);
                        Definition: {
                            !Allocation >= Threshold% of Demand
                            DeliveredAllVolume_PrGrp(term,dest,gPrGrp)
                            >=
                            [ MillDemand_PrGrp(dest,gPrGrp,__min,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,__min,tp) ]
                            * sum [(sect) |  cMillSector(sect,dest), ThresholdStart(sect,thr) ]
                             * MillIsAvailable(dest)
                        }
                    }
                    Constraint MeetThresholdDemand_Mod {
                        IndexDomain: {
                            (term,dest,thr,gprgrp,tp) | IsSelected(__ThresholdPenalties)
                            and dest in AvailableDest
                            and thr = __thrMod
                            and term >= tp.ts and term <= tp.tf  ! timperiod.start to timeperiod.finish
                            and IsSelected(__MeetVolumeTargets)
                            and MillDemand_DOM(term, dest, gPrGrp, __min, tp)
                            !and (  MillDemand_PrGrp(dest,gPrGrp,_min,tp) or MillResidualDemand_PrGrp(dest,gPrGrp,_min,tp))
                        }
                        Text: "Apply penalty if MODERATE threshold cannot be met";
                        Unit: ProductGroupUnit(gPrGrp);
                        Definition: {
                            !Allocation >= Threshold% of Demand
                            DeliveredAllVolume_PrGrp(term,dest,gPrGrp)
                            >=
                            [ MillDemand_PrGrp(dest,gPrGrp,__min,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,__min,tp) ]
                            * sum [(sect) |  cMillSector(sect,dest), ThresholdStart(sect,thr) ]
                             * MillIsAvailable(dest)
                        }
                    }
                    Constraint MeetThresholdDemand_Sig {
                        IndexDomain: {
                            (term,dest,thr,gprgrp,tp) | IsSelected(__ThresholdPenalties)
                            and dest in AvailableDest
                            and thr = __thrSig
                            and term >= tp.ts and term <= tp.tf  ! timperiod.start to timeperiod.finish
                            and IsSelected(__MeetVolumeTargets)
                            and MillDemand_DOM(term, dest, gPrGrp, __min, tp)
                            !and (  MillDemand_PrGrp(dest,gPrGrp,_min,tp) or MillResidualDemand_PrGrp(dest,gPrGrp,_min,tp))
                        }
                        Text: "Apply penalty if SIGNIFICANT threshold cannot be met";
                        Unit: ProductGroupUnit(gPrGrp);
                        Definition: {
                            !Allocation >= Threshold% of Demand
                            DeliveredAllVolume_PrGrp(term,dest,gPrGrp)
                            >=
                            [ MillDemand_PrGrp(dest,gPrGrp,__min,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,__min,tp) ]
                            * sum [(sect) |  cMillSector(sect,dest), ThresholdStart(sect,thr) ]
                             * MillIsAvailable(dest)
                        }
                    }
                    Constraint MeetThresholdDemand_High {
                        IndexDomain: {
                            (term,dest,thr,gprgrp,tp) | IsSelected(__ThresholdPenalties)
                            and dest in AvailableDest
                            and thr = __thrHigh
                            and term >= tp.ts and term <= tp.tf  ! timperiod.start to timeperiod.finish
                            and IsSelected(__MeetVolumeTargets)
                            and MillDemand_DOM(term, dest, gPrGrp, __min, tp)
                            !and (  MillDemand_PrGrp(dest,gPrGrp,_min,tp) or MillResidualDemand_PrGrp(dest,gPrGrp,_min,tp))
                        }
                        Text: "Apply penalty if HIGH threshold cannot be met";
                        Unit: ProductGroupUnit(gPrGrp);
                        Definition: {
                            !Allocation >= Threshold% of Demand
                            DeliveredAllVolume_PrGrp(term,dest,gPrGrp)
                            >=
                            [ MillDemand_PrGrp(dest,gPrGrp,__min,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,__min,tp) ]
                            * sum [(sect) |  cMillSector(sect,dest), ThresholdStart(sect,thr) ]
                             * MillIsAvailable(dest)
                        }
                    }
                }
            }
            DeclarationSection Even_Flow_Declarations {
                Variable EvenFlowDeliver_Max {
                    IndexDomain: {
                        (dest,gPrGrp,tpM) | IsSelected(__EvenFlow) and EvenFlowDeliver(dest,gPrGrp,tpM)
                        and dest in AvailableDest
                    }
                    Range: free;
                    Unit: ProductGroupUnit(gPrGrp);
                    Property: NoSave;
                }
                Constraint EvenFlowDeliver_MaxDef {
                    IndexDomain: {
                        (dest,gPrGrp,tpM,term) |  IsSelected(__EvenFlow) and EvenFlowDeliver(dest,gPrGrp,tpM)
                        and dest in AvailableDest
                        and (tpM.ts <= term <= tpM.tf)
                    }
                    Unit: ProductGroupUnit(gPrGrp);
                    Definition: EvenFlowDeliver_Max(dest,gPrGrp,tpM) >= DeliveredAllVolume_PrGrp(term,dest,gPrGrp);
                }
                Constraint EvenFlowDeliver_MinDef {
                    IndexDomain: {
                        (dest,gPrGrp,tpM,term) | IsSelected(__EvenFlow) and EvenFlowDeliver(dest,gPrGrp,tpM)
                        and dest in AvailableDest
                        and (tpM.ts <= term <= tpM.tf)
                    }
                    Unit: ProductGroupUnit(gPrGrp);
                    Definition: EvenFlowDeliver_Max(dest,gPrGrp,tpM) <= DeliveredAllVolume_PrGrp(term,dest,gPrGrp);
                }
                Constraint EvenFlowDeliverVariability {
                    IndexDomain: {
                        (dest,gPrGrp,tpM)| IsSelected(__EvenFlow) and EvenFlowDeliver(dest,gPrGrp,tpM)
                        and dest in AvailableDest
                    }
                    Unit: ProductGroupUnit(gPrGrp);
                    Definition: {
                        EvenFlowDeliver_Max(dest,gPrGrp,tpM) * (1-EvenFlowDeliver(dest,gPrGrp,tpM))
                        >= EvenFlowDeliver_Min(dest,gPrGrp,tpM)
                    }
                }
                Variable EvenFlowDeliver_Min {
                    IndexDomain: {
                        (dest,gPrGrp,tpM) |IsSelected(__EvenFlow) and  EvenFlowDeliver(dest,gPrGrp,tpM)
                        and dest in AvailableDest
                    }
                    Range: free;
                    Unit: ProductGroupUnit(gPrGrp);
                    Property: NoSave;
                }
            }
            DeclarationSection QA_Declaration {
                Parameter MaxHarvestVol {
                    IndexDomain: prd;
                    Unit: ProductUnit(prd);
                    Definition: [ Max(term, sum(blk,HarvestVolume(term,blk,prd) )) ];
                }
                Parameter MinHarvestVol {
                    IndexDomain: prd;
                    Unit: ProductUnit(prd);
                    Definition: [ Min(term, sum(blk,HarvestVolume(term,blk,prd) )) ];
                }
                Parameter TotalHarvestVolume {
                    IndexDomain: (prd);
                    Unit: ProductUnit(prd);
                    Definition: sum((term,blk),HarvestVolume(term,blk,prd));
                }
                Parameter TotalVolumeConversions {
                    IndexDomain: (prIN,prOUT);
                    Definition: {
                        !sum((term,blk),OLDBlockVolumeConversions(term,blk,prIN,prOUT))
                    }
                }
                Parameter TotalConvertedVolume {
                    IndexDomain: (prd);
                    Definition: {
                        !sum((term,blk),OLDConvertedVolume(term,blk,prd))
                    }
                }
                Parameter CheckHaulTime {
                    IndexDomain: (src,dest) | HaulTime(src,dest);
                    Property: NoSave;
                    Definition: 1;
                }
            }
            Section Unused_Section {
                Constraint AllHarvestDelivered {
                    IndexDomain: (term,prd);
                    Text: "Delivered volume = Harvested Volume";
                    Unit: ProductUnit(prd);
                    Definition: {
                        sum((blk,dest)| dest in AvailableDest , DeliveredVolume(term,blk,dest,prd))
                        =
                        sum[blk | blk in AvailableBlocks ,HarvestVolume(term,blk,prd)]
                    }
                }
                Variable ThresholdSlack {
                    IndexDomain: {
                        (term,dest,thr,gPrGrp,tt,tp)| IsSelected(__ThresholdPenalties) and IsSelected(__MeetVolumeTargets)
                         and tt = __min
                        and term >= tp.ts and term <= tp.tf  ! timperiod.start to timeperiod.finish
                        and MillDemand_DOM(term, dest, gPrGrp, tt, tp)
                        and dest in AvailableDest
                        !and ( MillDemand_PrGrp(dest,gPrGrp,tt,tp) or MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp))
                    }
                    Text: "For dest, The amount by which allocation exceeds thr threshold demand for gPrGrp in timeperiod tp";
                    Unit: ProductGroupUnit(gPrGrp);
                    Definition: {
                        !Allocation = demand * thresholdstart * MillIsAvailable(dest)
                        DeliveredAllVolume_PrGrp(term,dest,gPrGrp)
                        -
                        ! Onset level of each threshold : Demand * ProoirtionWhereThreshold (thr) Starts (Sector)
                        [ MillDemand_PrGrp(dest,gPrGrp,tt,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp) ]
                        * sum [(sect) |  cMillSector(sect,dest), ThresholdStart(sect,thr) ]
                         * MillIsAvailable(dest)
                    }
                }
            }
        }
        Section For_GUI {
            Section General_Pages {
                Set Blocks_Sorted {
                    SubsetOf: Blocks;
                    Index: blk_s;
                    Parameter: _blk_s;
                    Property: NoSave;
                    OrderBy: blk_s;
                    Definition: {
                        { blk }
                    }
                }
                Set ManagementUnits_Sorted {
                    SubsetOf: ManagementUnits;
                    Index: mu_s;
                    Parameter: _mu_s;
                    Property: NoSave;
                    OrderBy: mu;
                    Definition: {
                        { mu }
                    }
                }
                Set AllProducts_Sorted {
                    SubsetOf: AllProducts;
                    Index: gpr_s;
                    Parameter: _gpr_s;
                    Property: NoSave;
                    OrderBy: gpr_s;
                    Definition: {
                        { gpr }
                    }
                }
                Set AllProductGroups_Sorted {
                    SubsetOf: AllProductGroups;
                    Index: gPrGrp_s;
                    Parameter: _gPrGrp_s;
                    Property: NoSave;
                    OrderBy: gPrGrp_s;
                    Definition: {
                        {gPrGrp}
                    }
                }
                ElementParameter ProductColours {
                    IndexDomain: gpr;
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        if gpr in Products then 'product'
                        elseif gpr in residuals then 'residual'
                        else 'white'
                        endif
                    }
                }
                ElementParameter ProductGroupColours {
                    IndexDomain: gPrGrp;
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        if gPrGrp in ProductGroups then 'product'
                        elseif gPrGrp in ResidualGroups then 'residual'
                        else 'white'
                        endif
                        
                        !if gPrGrp in ProductGroups then 'product' else 'residual' endif
                        
                        !Text Colour
                        !if gPrGrp in ProductGroupsSingle then 'res3'
                        !elseif gPrGrp in ResidualGroupsSingle then 'red'
                        !endif
                    }
                }
                ElementParameter ProductGroupTextColours {
                    IndexDomain: gPrGrp;
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        !Text Colour
                        if gPrGrp in ProductGroupsSingle then 'res3'
                        elseif gPrGrp in ResidualGroupsSingle then 'red'
                        endif
                    }
                }
                ElementParameter ProductTextColours {
                    IndexDomain: (gpr);
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        !Text Colour
                        if gpr in Products then 'res3'
                        elseif gpr in Residuals then 'red'
                        endif
                    }
                }
                Parameter TableShowAllBlocks {
                    Text: "Show all blocks";
                    Range: binary;
                    Property: NoSave;
                }
                Set BlkBaseNames {
                    Text: "Unique block base codes";
                    Index: blkbase, blkbase1;
                    Parameter: _blkbase;
                    Property: NoSave;
                }
                Set MuBlkCheck {
                    IndexDomain: (mu);
                    SubsetOf: BlkBaseNames;
                    Text: "Unique block base codes";
                    Property: NoSave;
                    Definition: {
                        {
                        blkbase | MuBlkbaseRelation(mu, blkbase)
                        and count(mu1 | MuBlkbaseRelation(mu1, blkbase)) >1
                        }
                    }
                }
                Parameter MuBlkbaseRelation {
                    IndexDomain: (mu,blkbase);
                    Range: binary;
                    Property: NoSave;
                }
                Parameter MUSelection {
                    IndexDomain: (mu);
                    Range: binary;
                    Unit: 1;
                    Property: NoSave;
                }
                ElementParameter MUForBlock {
                    IndexDomain: (blk_s);
                    Range: ManagementUnits_Sorted;
                    Property: NoSave;
                }
                Parameter UnusedBlocks {
                    IndexDomain: (blk_s);
                    Range: binary;
                    Unit: 1;
                    Definition: {
                        if not exists(dest | (blk_s,dest) in PotentialSupplyRoutes ) then 1 endif
                        !if not exists(dest | (blk_s,dest) in AvailableSupplyRoutes ) then 1 endif
                        !if not exists(dest | (blk_s,dest) in AccessibleSupplyRoutes ) then 1 endif
                        !
                    }
                }
                Procedure MakeSet_MuBlkCheck {
                    Body: {
                        empty BlkBaseNames, MuBlkbaseRelation;
                        
                        !for (mu,blk) | MU_Block_Relation(mu, blk) do
                        for blk  do !| blk = 'afa10'
                        	BlkName := FormatString("%e",blk);
                        
                        	!---look for base name ... before final digit string e.g. nnn in AB4_nnn
                        	pos := FindAnyString(FormatString("%e",blk),"0123456789",1) ;
                        	if pos > 1 then
                        		BlkName := SubString(BlkName,1,pos-1);
                        	else
                        		BlkName := FormatString("%e",blk);
                        	endif;
                        
                        	!SetElementAdd(MuBlkCheck,,BlkName;
                        	_blkbase := StringToElement(BlkBaseNames, BlkName, 1);
                        	if _blkbase = '' then
                        		halt with "Can't add element to BlkBaseNames";
                        		return 0;
                        	endif;
                        
                        	MuBlkbaseRelation((mu, _blkbase) | MuBlkbaseRelation(mu, _blkbase) =0) :=$ MU_Block_Relation(mu, blk);
                        endfor;
                        
                        return 1;
                    }
                    StringParameter BlkName;
                    Parameter pos;
                }
                Procedure SetMuBlksAvailability {
                    Body: {
                        i := count(mu | MUSelection(mu));
                        if i = 0 then
                        	DialogError("No MUs selected");
                        	return 0;
                        endif;
                        
                        i := DialogAsk(FormatString("What do you want to do for all blocks in %i selected MUs?\n\n 1. 100%% available\n 2. 0%% available\n%s", i,"")
                        	,"1", "2", "Cancel");
                        switch i do
                        1:	PercentBlockAvailable(blk | exists(mu | MU_Block_Relation(mu, blk) and MUSelection(mu)) ) := 1;
                        2:	PercentBlockAvailable(blk | exists(mu | MU_Block_Relation(mu, blk) and MUSelection(mu)) ) := 0;
                        3: return 0;
                        default:
                        	return 0;
                        endswitch;
                        
                        i := count  (blk | exists(mu | MU_Block_Relation(mu, blk) and MUSelection(mu)) ) ;
                        DialogMessage(FormatString("%i blocks adjusted", i));
                         return 1;
                    }
                    Parameter i {
                        Range: integer;
                    }
                }
                Procedure RemoveUnusedMusAndBlocks {
                    Body: {
                        ! remove MU and blk  which are not available
                        if not IsSelected(__IncludeOnlyAvailableBlocks) then
                        	DialogMessage("Cleanup works only if you've selected 'Include Only Available Blocks'","");
                        	return 0;
                        endif;
                        
                        !--- MUs with unavailable blks
                        UnNeededMUs := { mu | (exists(blk | MU_Block_Relation(mu, blk)
                        								and if IsSelected(__IncludeOnlyAvailableBlocks) then not IsAvailable(blk) else 0 endif )
                        								) };
                        
                        !--- MUs with no associated blocks
                        UnNeededMUs += { mu | not exists(blk | MU_Block_Relation(mu, blk) ) };
                        
                        !-- blocks associated with unneeded MUs
                        UnNeededBlocks := { blk | exists(mu | mu in UnNeededMUs and MU_Block_Relation(mu, blk) ) };
                        
                        !--- blocks not associated with MUs and without initial GS
                        UnNeededBlocks += { blk | [not exists(mu | MU_Block_Relation(mu, blk) )]
                        							and [not exists(prd | InitialGS(blk, prd) )] };
                        
                        if  count(mu | mu in UnNeededMUs) =0 and  count(blk | blk in UnNeededBlocks) =0 then
                        	DialogMessage("No MUs or Blocks to remove");
                        	return 1;
                        endif;
                        
                        i := DialogAsk(FormatString("Do you wish to remove %i MUs and %i Blocks?"
                        				, count(mu | mu in UnNeededMUs)
                        				, count(blk | blk in UnNeededBlocks))
                        		, "Yes", "No", "Show MUs and Blocks", "Confirm Action");
                        !DebuggerBreakpoint;
                        switch (i) do
                        	1:
                        		ManagementUnits -= UnNeededMUs;
                        		AllLocations -= UnNeededBlocks;
                        		cleandependents ManagementUnits, AllLocations;
                        	2:
                        		return 1;
                        	3:
                        		put console;
                        		display UnNeededMUs, UnNeededBlocks;
                        		putclose;
                        	default:
                        		return 0;
                        endswitch;
                    }
                    Set UnNeededMUs {
                        SubsetOf: ManagementUnits;
                        OrderBy: mu;
                    }
                    Set UnNeededBlocks {
                        SubsetOf: Blocks;
                        OrderBy: blk;
                    }
                    Parameter i {
                        Range: integer;
                    }
                    File Console {
                        Name: "Console";
                        Device: window;
                        Mode: replace;
                    }
                }
                Procedure RandomlyRemoveBlocks {
                    Body: {
                        block ! randomly remove blocks
                        	IsSelected(__IncludeOnlyAvailableBlocks) := 1;
                        
                        	n := count(blk | AvailableBlocks(blk) ) ;
                        
                        	if DialogGetNumber(
                        		FormatString("How many of the %n blocks do you want to keep?",n)
                        		,i,0) = 0 then return 0; endif;
                        
                        	if i >= n or i=0 then
                        		return 1;
                        		endif;
                        
                        	while i < n do
                        		j := Floor( Uniform( 1, n) ) ;
                        		_blk := First(blk | ord(blk,AvailableBlocks) = j );
                        		Blocks -= _blk ;
                        		n -= 1;
                        	endwhile;
                        
                        	empty _blk;
                        	cleandependents Blocks;
                        endblock;
                        
                        !-- remove MUs with no associated blocks
                        !--- MUs with no associated blocks
                        ManagementUnits -= { mu | not exists(blk | MU_Block_Relation(mu, blk) ) };
                        
                        !-- remove mills with no supply
                        !DebuggerBreakpoint;
                        UnNeededMills := { dest | not exists( blk | (blk,dest) in AvailableSupplyRoutes ) };
                        Destinations -= UnNeededMills;
                    }
                    Set UnNeededMills {
                        SubsetOf: Destinations;
                        OrderBy: dest;
                    }
                    Set UnNeededBlocks {
                        SubsetOf: Blocks;
                        OrderBy: blk;
                    }
                    Set ValidSupplyRoutes {
                        SubsetOf: (AllSources,Destinations,AllProducts);
                    }
                    Set SoleSupplyRoutes {
                        SubsetOf: (AllSources,Destinations,AllProducts);
                    }
                    Parameter i {
                        Range: integer;
                    }
                    Parameter n {
                        Range: integer;
                    }
                    Parameter j {
                        Range: integer;
                    }
                    File Console {
                        Name: "Console";
                        Device: window;
                        Mode: replace;
                    }
                }
                Procedure RemoveUnusedMills {
                    Body: {
                        ! remove dest  which are not available
                        
                        UnNeededMills := { dest | if IsSelected(__IncludeOnlyAvailableMills) then not IncludeMill(dest) else 0 endif };
                        
                        if count(dest | dest in UnNeededMills) =0 then
                        	DialogMessage("No Mills to remove");
                        	return 1;
                        endif;
                        
                        i := DialogAsk(FormatString("Do you wish to remove %i Mills?"
                        				, count(dest | dest in UnNeededMills))
                        		, "Yes", "Show Mills", "Cancel", "Confirm Action");
                        !DebuggerBreakpoint;
                        switch (i) do
                        	1:
                        		AllLocations -= UnNeededMills;
                        		cleandependents AllLocations;
                        	3:
                        		return 1;
                        	2:
                        		put console;
                        		display UnNeededMills;
                        		putclose;
                        	default:
                        		return 0;
                        endswitch;
                    }
                    Set UnNeededMills {
                        SubsetOf: Destinations;
                        OrderBy: dest;
                    }
                    Set UnNeededBlocks {
                        SubsetOf: Blocks;
                        OrderBy: blk;
                    }
                    Parameter i {
                        Range: integer;
                    }
                    File Console {
                        Name: "Console";
                        Device: window;
                        Mode: replace;
                    }
                }
                Procedure RemoveUnusedLocations {
                    Body: {
                        ! remove loc  which are not destinations or blocks
                        
                        UnNeededLocations := { loc | not Destinations(loc) and not blocks(loc)  };
                        
                        if count(loc | loc in UnNeededLocations) =0 then
                        	DialogMessage("No Locations to remove");
                        	return 1;
                        endif;
                        
                        
                        		AllLocations -= UnNeededLocations;
                        		cleandependents AllLocations;
                    }
                    Set UnNeededLocations {
                        SubsetOf: AllLocations;
                        OrderBy: loc;
                    }
                    Set UnNeededBlocks {
                        SubsetOf: Blocks;
                        OrderBy: blk;
                    }
                    Parameter i {
                        Range: integer;
                    }
                    File Console {
                        Name: "Console";
                        Device: window;
                        Mode: replace;
                    }
                }
                Procedure RandomlyExcludeMills {
                    Body: {
                        ! remove dest  which are not available
                        block ! solesupplyroutes
                        	ValidSupplyRoutes := AvailableRoutesForProducts * TimePermittedRoutesForProducts;
                        	SoleSupplyRoutes := { (destFrom, dest,res) |
                        		(destFrom,dest,res) in ValidSupplyRoutes
                        !		and count (DestTo | (destFrom,DestTo,res) in ValidSupplyRoutes) = 1
                        	};
                        
                        endblock;
                        
                        
                        IsSelected(__IncludeOnlyAvailableMills) := 1;
                        
                        n := count(dest | AvailableDest(dest) ) ;
                        
                        if DialogGetNumber(
                        	FormatString("How many of the %n mills do you want to include?",n)
                        	,i,0) = 0 then return 0; endif;
                        
                        if i >= n or i=0 then
                        	return 1;
                        	endif;
                        
                        
                        while i < n do
                        	ValidSupplyRoutes := AvailableRoutesForProducts * TimePermittedRoutesForProducts;
                        	SoleSupplyRoutes := { (destFrom, dest,res) |
                        		(destFrom,dest,res) in ValidSupplyRoutes
                        !		and count (DestTo | (destFrom,DestTo,res) in ValidSupplyRoutes) = 1
                        	};
                        
                        	j := Floor( Uniform( 1, n) ) ;
                        	_dest_s := First(dest | ord(dest,AvailableDest) = j );
                        
                        	!--- Do not exclude mills that others depend on
                        	! if there is a mill that produces residuals that can be sent only to dest ... don't remove
                        	if exists ( (destFrom,res) | (destFrom,_dest_s,res) in ValidSupplyRoutes
                        		and count (DestTo | (destFrom,DestTo,res) in ValidSupplyRoutes) = 1 ) then
                        		; !skip
                        		DialogMessage(FormatString("%e is the sole destionation for someone's residue",_dest_s));
                        	else
                        		IncludeMill( _dest_s ) := 0;
                        		n -= 1 ;
                        	endif;
                        endwhile;
                        
                        empty _dest_s;
                    }
                    Set UnNeededMills {
                        SubsetOf: Destinations;
                        OrderBy: dest;
                    }
                    Set UnNeededBlocks {
                        SubsetOf: Blocks;
                        OrderBy: blk;
                    }
                    Set ValidSupplyRoutes {
                        SubsetOf: (AllSources,Destinations,AllProducts);
                    }
                    Set SoleSupplyRoutes {
                        SubsetOf: (AllSources,Destinations,AllProducts);
                    }
                    Parameter i {
                        Range: integer;
                    }
                    Parameter n {
                        Range: integer;
                    }
                    Parameter j {
                        Range: integer;
                    }
                    File Console {
                        Name: "Console";
                        Device: window;
                        Mode: replace;
                    }
                }
                Procedure InitializeMUForBlock {
                    Body: {
                        MUForBlock(blk_s) := first(mu_s | MU_Block_Relation(mu_s, blk_s) );
                    }
                }
                Procedure RemoveOrphanProducts {
                    Body: {
                        if DialogAsk("Do you wish to remove orphan products?","Yes","No","Cencel","Confirm Action") <> 1 then return 0; endif;
                        
                        ProductsToRemove := { gpr | not Products(gpr) and not Residuals(gpr) };
                        
                        AllProducts -= ProductsToRemove;
                    }
                    Set ProductsToRemove {
                        SubsetOf: AllProducts;
                    }
                }
                Procedure RemoveOrphanProductGroups {
                    Body: {
                        if DialogAsk("Do you wish to product groups not associated with any products?","Yes","No","Cencel","Confirm Action") <> 1 then return 0; endif;
                        
                        ProductsGroupsToRemove := { gPrGrp | not ProductGroups(gPrGrp) and not ResidualGroups(gPrGrp) };
                        
                        ProductsGroupsToRemove  += { gprgrp | not exists(gpr | cPrG(gPrGrp, gpr) )};
                        
                        AllProductGroups -= ProductsGroupsToRemove;
                    }
                    Set ProductsGroupsToRemove {
                        SubsetOf: AllProductGroups;
                    }
                }
                Procedure Update_MU_Block_Relation {
                    Body: {
                        MU_Block_Relation((mu_s, _blk_s) ) := 0;
                        MU_Block_Relation((mu_s, _blk_s) | mu_s = MUForBlock(_blk_s)) := 1;
                    }
                }
                Procedure Update_AllMU_Block_Relation {
                    Body: {
                        !MU_Block_Relation((mu_s, _blk_s) ) := 0;
                        empty MU_Block_Relation;
                        MU_Block_Relation((mu_s, blk_s) | mu_s = MUForBlock(blk_s)) := 1;
                    }
                }
                Procedure RemoveNonContributingBlocks {
                    Body: {
                        i := 0;
                        s := "Which group of blocks do you wish to remove?";
                        
                        
                        repeat
                        	if DialogGetNumber(s,i,0,"Input Choice") = 0
                        		then return 0; endif;
                        	break when (1<=i<=3);
                        	s := "You must enter a nubmer between 1 and 3\n\n"+"Which group of blocks do you wish to remove?";
                        endrepeat;
                        
                        
                        switch (i) do
                        	1:
                        	Blocks -= { blk | not exists(dest | (blk,dest) in PotentialSupplyRoutes ) } ;
                        
                        	2:
                        	Blocks -= { blk | not exists(dest | (blk,dest) in AvailableSupplyRoutes ) } ;
                        
                        	3:
                        	Blocks -= { blk | not exists(dest | (blk,dest) in AccessibleSupplyRoutes ) } ;
                        
                        	default:
                        
                        endswitch;
                        
                        return 1;
                    }
                    Parameter i {
                        Range: integer;
                    }
                    StringParameter s;
                }
                Section Shapefile_Section {
                    DeclarationSection Shapefile_Declaration {
                        Set ShapefileTypes {
                            Index: ishp;
                            Parameter: _ishp;
                            Property: NoSave;
                            Definition: {
                                {'Block' , 'MU'}
                            }
                        }
                        Parameter UseShapefileBackgrounds {
                            Text: "Use Shapefiles as background to maps";
                            Range: binary;
                        }
                        Parameter CanDisplayShapefile {
                            IndexDomain: (ishp);
                            Text: "Ensures that shapefile can be displayed";
                            Range: binary;
                            Default: 0;
                            Property: NoSave;
                        }
                        Parameter CanShowNetworkObject {
                            Range: binary;
                            Property: NoSave;
                            Definition: count(ishp | CanDisplayShapefile(ishp) ) = card(ishp);
                        }
                        StringParameter ShapefileNames {
                            IndexDomain: (ishp);
                        }
                        StringParameter GUI_ShapefileNames {
                            IndexDomain: (ishp);
                            Default: "<prj>:Shapefiles\\MU_Sim1.gml";
                            Property: NoSave;
                        }
                        StringParameter GUI_ShapefileFormat {
                            IndexDomain: (ishp);
                            Default: "GML";
                            Definition: {
                                if StringToUpper( SubString(GUI_ShapefileNames(ishp),-3,-1)) = "SHP" then "ESRI"
                                elseif StringToUpper( SubString(GUI_ShapefileNames(ishp),-3,-1)) = "GML" then "GML"
                                endif
                            }
                        }
                        Parameter ShowShapefile {
                            IndexDomain: (ishp);
                            Default: 0;
                            Property: NoSave;
                        }
                        StringParameter DefaultShapefile {
                            InitialData: "<prj>:Shapefiles\\MU_Sim1.gml";
                        }
                    }
                    Procedure GetShapefileName {
                        Body: {
                            if _ishp='' then
                            	DialogGetElement("Which shapefile are you specifying?",_ishp);
                            endif;
                            
                            if FileSelect(
                            	filename  :  sFile,
                            	directory :  ,
                            	extension :  "gml",
                            	title     :  FormatString("Select %e Shapefile",_ishp)
                            	) = 0 then return 0;
                            endif;
                            
                            ShapefileNames(_ishp) := sFile;
                            
                            SetCanDisplayShapefile;
                            
                            return 1;
                        }
                        StringParameter sFile;
                    }
                    Procedure SetCanDisplayShapefile {
                        Body: {
                            for ishp do
                            	if FileExists(filename :  ShapefileNames(ishp)) then
                            		CanDisplayShapefile(ishp) := 1;
                            		GUI_ShapefileNames(ishp) := ShapefileNames(ishp);
                            	else
                            		CanDisplayShapefile(ishp) := 0;
                            		GUI_ShapefileNames(ishp) := DefaultShapefile ;
                            	endif;
                            endfor;
                        }
                    }
                    Procedure EmptyShapefileNames {
                        Body: {
                            empty ShapefileNames;
                            SetCanDisplayShapefile;
                        }
                    }
                }
            }
            Section Supply_Pages {
                ElementParameter SectorColourRamp {
                    IndexDomain: sect;
                    Range: AllColors;
                    Property: NoSave;
                }
                Parameter HIDEMillNames {
                    Text: "Hide Mill Names";
                    Range: binary;
                    Property: NoSave;
                }
            }
            Section Mills_Pages {
                ElementParameter TreeTargetColours {
                    IndexDomain: (dest,mu,prd)| sum[(term,tt),TreesFlow(term, mu, dest, prd, tt)];
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        !--- Valid Targets
                        if not (dest,mu,prd) in InvalidTreesTargets then 'product'
                        
                        !--- Non-Valid Targets
                        !Product not used by dest
                        elseif not ProductsUsed(dest,prd) then 'NoDemand'
                        !MU has not supply of prd
                        elseif not InitialGS_mu(mu, prd) then 'NoSupply'
                        !MU too far from dest
                        elseif not exists[blk | MU_Block_Relation(mu, blk) and ( (blk,dest) in TimePermittedSupplyRoutes  ) ]
                        		then 'TooFar'
                        !Darned if I know
                        else  'button error'
                        endif
                    }
                }
                Set InvalidTreesTargets {
                    SubsetOf: (Destinations,ManagementUnits,Products);
                    Definition: {
                        { (dest,mu,prd) |
                        sum[(term,tt),TreesFlow(term, mu, dest, prd, tt) ] !Trees target specified
                        and
                        [
                        count[blk | MU_Block_Relation(mu, blk) $ ( [(blk,dest) in PotentialSupplyRoutes ] ) ]=0
                        or
                        count[blk | MU_Block_Relation(mu, blk) $ ( [(blk,dest) in TimePermittedSupplyRoutes ] ) ]=0
                        ]
                        }
                    }
                }
                Parameter ShowOnlyInvalidTargets {
                    Text: "Show only invalid targets";
                    Range: binary;
                    Property: NoSave;
                }
                Parameter TreesFlow_DOMAIN {
                    IndexDomain: {
                        (term, mu, dest, prd, tt) | TreesFlow(term, mu, dest, prd, tt) and
                        if ShowOnlyInvalidTargets then InvalidTreesTargets(dest,mu,prd) else 1 endif
                    }
                    Property: NoSave;
                    Definition: 1;
                }
                Set Destinations_Sorted {
                    SubsetOf: Destinations;
                    Index: dest_sort;
                    Parameter: _dest_s;
                    OrderBy: {
                        if substring(FormatString("%e",dest),1,1) <> "_" then dest
                        else "ZZZZZZ"+FormatString("%e",dest)
                        endif
                    }
                    Definition: {
                        { dest }
                    }
                    Comment: {
                        "! If Destinations_Sorted is NoSave ... can get error on opening a case."
                    }
                }
                Set Destinations_Valid {
                    SubsetOf: Destinations_Sorted;
                    Index: dvalid, dvalid1;
                    Parameter: _dvalid;
                    Definition: {
                        { dest |	[ UsesProducts(dest) or UsesResiduals(dest)]
                        		and [ exists(gPrGrp | [ ProductsUsed_PrGrp(dest, gPrGrp) or ResidualsUsed_PrGrp(dest, gPrGrp)] ) ]
                        }
                    }
                }
                Parameter MillEdit_On {
                    Text: "Mill Page is Read-only";
                    Range: binary;
                    Unit: 1;
                    Default: 1;
                    Property: NoSave;
                }
                Parameter Destinations_Selected {
                    IndexDomain: (dest);
                    Range: binary;
                    Property: NoSave;
                }
                Procedure RemoveSourcesAndDestinations {
                    Body: {
                        if (dialogAsk("Do you wish to remove mills?","Yes","No") = 2 ) then return 0; endif;
                        
                        for (dest) do
                                Current_dest := stringtoelement(Destinations,"Mill1",0);
                                if Current_dest then            AllLocations -= Current_dest;   endif;
                                Current_dest := stringtoelement(Destinations,"Mill2",0);
                                if Current_dest then            AllLocations -= Current_dest;   endif;
                                Current_dest := stringtoelement(Destinations,"Mill3",0);
                                if Current_dest then            AllLocations -= Current_dest;   endif;
                        endfor;
                        
                        
                        HaulTime((src,dest)| dest = 'Xall' and HaulTime(src,dest) = 0 [hour]) := 0.1e-3 [hour];
                        
                        /*  Used to make model smaller /**/
                        NumberOfMills := card(Destinations);
                        
                        if dialogGetNumber(
                                FormatString("The model currently has %n mills.\n\nHow many do you want to remove?",NumberOfMills),
                                NumberToRemove,0,"Make Model Smaller") = 0 then
                                        return 0;
                        endif;
                        
                        if NumberToRemove >= NumberOfMills then
                                dialogError("You have asked to remove too many mills","Error");
                                return 0;
                        endif;
                        
                        i := 0; s := "";
                        !debuggerbreakpoint;
                        while ( NumberToRemove>0 and i < NumberToRemove) do
                                xx := round( Uniform(1,card(Destinations)) ,0);
                                ThisMill := element(destinations,xx);
                                s += FormatString("%e\n",thismill);
                                if thismill <> 'Xall' then
                                        AllLocations -= thismill;
                                        Destinations -= thismill;
                                i += 1;
                                endif
                        endwhile;
                        cleandependents AllLocations;
                        dialogMessage(s,"Mills Removed");
                    }
                    Parameter NumberOfMills {
                        Range: integer;
                    }
                    Parameter NumberToRemove {
                        Range: integer;
                    }
                    Parameter i;
                    ElementParameter ThisMill {
                        Range: Destinations;
                    }
                    Parameter xx;
                    StringParameter s;
                }
                Procedure DeleteUnNeededMills {
                    Body: {
                        
                        numMills := count(dest);
                        numValidMills := count(dvalid);
                        numMillsIncluded := count (dest | if IsSelected(__IncludeOnlyAvailableMills) then IncludeMill(dest) else 1 endif );
                        
                        
                        if numMills = numMillsIncluded and numMills=numValidMills then
                        	DialogMessage("No mills will be removed","All Mills Valid and Included");
                        	return 1;
                        endif;
                        
                        !s := FormatString("%n Mills: %n are valid, %n are included\n",numMills,numValidMills,numMillsIncluded);
                        s := FormatString("1. Unincluded (%n)-Mills that are not 'Included'?\n",numMills - numMillsIncluded);
                        s := FormatString("%s2. Invalid (%n) -Mills that use no products or residuals?\n",s,numMills-numValidMills);
                        s := FormatString("%s3. Both -Unincluded and Invalid?\n",s);
                        s := FormatString("%s4. Show a list of Unincluded and Invalid mills?",s);
                        
                        if DialogGetNumber(s,Choice,0,FormatString("Enter Mills(%n) to Remove (%n Valid, %n Included)",numMills,numValidMills,numMillsIncluded)
                        	) = 0 then
                        	return 0; endif;
                        
                        MyDest := Destinations_sorted;
                         IsSelected(__IncludeOnlyAvailableMills) :=1;
                        
                        switch (Choice) do
                        	1: !Unincluded
                        		MyDest -= { dest | Not [ IsSelected(__IncludeOnlyAvailableMills) and IncludeMill(dest) ] };
                        
                        	2: !InValid
                        		MyDest := Destinations_Valid;
                        
                        	3: !Both
                        		MyDest := Destinations_Valid;
                        		MyDest -= { dest | Not [ IsSelected(__IncludeOnlyAvailableMills) and IncludeMill(dest) ] };
                        
                        	4: !Show
                        		Put console;
                        
                        		! not included -------------
                        		MyDest := {dest | IsSelected(__IncludeOnlyAvailableMills) and [not IncludeMill(dest) ] };
                        		if count(dest in MyDest) = 0 then
                        			put "ALL Mills are Included"//;
                        		else
                        			put "--- List of UnIncluded Mills ---"/;
                        			display MyDest;
                        			put //;
                        		endif;
                        
                        		! Invalid -------------
                        		MyDest := Destinations - Destinations_Valid;
                        		if count(dest in MyDest) = 0 then
                        			put "ALL Mills are Valid"//;
                        		else
                        			put "--- List of  Mills for which no products or residuals have been specified ---"/;
                        			display MyDest;
                        		endif;
                        
                        		putclose;
                        
                        	default:
                        		return 0;
                        endswitch;
                        
                        Destinations := MyDest;
                        CleanupLocations;
                        return 1;
                    }
                    Set MyDest {
                        SubsetOf: Destinations;
                        OrderBy: dest;
                    }
                    StringParameter s;
                    Parameter numMills;
                    Parameter numMillsIncluded;
                    Parameter numValidMills;
                    Parameter Choice {
                        Range: integer;
                    }
                    File Console {
                        Name: "Console";
                        Device: window;
                        Mode: replace;
                    }
                }
                Procedure DeleteSelectedMills {
                    Body: {
                        n := count(dest | Destinations_Selected(dest) );
                        if n = 0 then
                        	DialogMessage("No Destionations Selected");
                        	return 0;
                        endif;
                        
                        !--- Confirm deletion
                        s:= FormatString("Do you want delete %n (of %n) destionations?", n, card(dest));
                        if DialogAsk( s,"Yes","No","Cancel","Enter Choice") <> 1 then return 0 ; endif;
                        
                        AllLocations -= { dest | Destinations_Selected(dest) };
                        cleandependents AllLocations ;
                    }
                    StringParameter s;
                    Parameter n {
                        Range: integer;
                    }
                }
                Procedure CleanupLocations {
                    Body: {
                        AllLocations -= { loc | (not loc in Destinations ) and ( not loc in blocks ) };
                        
                        !Remove any mills that use neither products nor residuals
                        AllLocations -= { dest | not dest in Destinations_Valid };
                        
                        cleandependents AllLocations;
                    }
                }
            }
            Section Cost_Pages {
                Section Haultimes {
                    Parameter rank {
                        IndexDomain: {
                            (src,dest) | (src,dest) in PotentialSupplyRoutes
                            and HaulTime(src,dest)
                        }
                        Property: NoSave;
                        Definition: {
                            !count(src1 | (src1,dest) in SrcCanSupplyDest
                            !			and AvgHaulCost(src1,dest) < AvgHaulCost(src,dest) ) +1
                        }
                    }
                    Parameter xxx {
                        IndexDomain: (src,dest) |HaulCostQuartilesToShow( HaulCostColourRamp(src,dest));
                        Range: binary;
                        Definition: 1;
                    }
                    Parameter AvgHaulCost {
                        IndexDomain: (src,dest) | (src,dest) in PotentialSupplyRoutes;
                        Unit: $/m3;
                        Property: NoSave;
                        Definition: {
                            !sum(gprod,CalculatedTotalCostPerUnit(src,dest,gProd) $ (src,dest) in SrcCanSupplyDest )
                            !/$ count(gprod|CalculatedTotalCostPerUnit(src,dest,gProd) and (src,dest) in SrcCanSupplyDest)
                        }
                    }
                    Parameter HaulCostQuartilesToShow {
                        IndexDomain: (imqco);
                        Range: binary;
                        Default: 1;
                        Property: NoSave;
                    }
                    Set GUICostsToShow {
                        SubsetOf: (AllSources, Destinations);
                        Tags: (vsrc, vdest);
                        Index: iSrcDest_Show;
                        Property: NoSave;
                        Definition: {
                            {
                            (src,dest) |  sum(gprod,CalculatedTotalCostPerUnit(src,dest,gProd))
                            and HaulCostQuartilesToShow( HaulCostColourRamp(src,dest))
                            }
                        }
                    }
                    Parameter GUICalculatedTotalCostPerUnit {
                        IndexDomain: (src,dest,gprod) | (src,dest) in GUICostsToShow;
                        Text: "Total cost (per m3) of loading and transporting gProd from src to dest";
                        Unit: $/ProductUnit(gProd);
                        Property: NoSave;
                        Definition: CalculatedTotalCostPerUnit(src,dest,gProd);
                    }
                    Set PotentialCheaperSuppliers {
                        IndexDomain: (src,dest) | (src,dest) in PotentialSupplyRoutes;
                        SubsetOf: AllSources;
                        Property: NoSave;
                        Definition: {
                            {
                            src1 | (src1,dest) in PotentialSupplyRoutes and
                            AvgHaulCost(src1,dest) and AvgHaulCost(src1,dest) <	 AvgHaulCost(src,dest)
                            }
                        }
                    }
                    Parameter PotentialSupplierCount {
                        IndexDomain: (dest);
                        Property: NoSave;
                        Definition: count(src | (src,dest) in PotentialSupplyRoutes and HaulTime(src,dest));
                    }
                    Parameter HaulCostQuantile {
                        IndexDomain: (src,dest) | (src,dest) in PotentialSupplyRoutes and HaulTime(src,dest);
                        Property: NoSave;
                        Definition: {
                            
                            
                            !ceil( rank(src,dest) /$ PotentialSupplierCount(dest) * NumberQuantiles )
                        }
                    }
                    ElementParameter HaulCostLegendColourRamp {
                        IndexDomain: (imqco);
                        Range: MapQuantileColours_Ordered;
                        Property: NoSave;
                        Definition: {
                            !first(imqco2 | FormatString("%i",ord(imqco)) = FormatString("%i",GUIColourOrder(imqco2)))
                            first(imqco2 | ord(imqco) = ord(imqco2) )
                            !if GUIColourOrder(imqc) >0 then
                            !	first(imqc2 | FormatString("%i",ord(imqc)) = FormatString("%i",GUIColourOrder(imqc2)))
                            !else
                            !	last(imqc2)
                            !endif
                        }
                    }
                    ElementParameter HaulCostColourRamp {
                        IndexDomain: (src,dest);
                        Range: MapQuantileColours_Ordered;
                        Property: NoSave;
                        Definition: {
                            !if not (src,dest) in SrcCanSupplyDest then 'NA'
                            !elseif ValidRoutes(src,dest) <> 1 then  'TooFar'
                            !else
                            !	First(imqco | FormatString("%e",imqco)
                            !	=  FormatString("Q%n", HaulCostQuantile(src,dest) ) )
                            !endif
                        }
                    }
                    Parameter RecalculateTransportCostFLAG {
                        Range: binary;
                        Unit: 1;
                        Default: 1;
                        Comment: {
                            "! true if transport costs must be recalculated"
                        }
                    }
                    ElementParameter _MuForMuSrc {
                        IndexDomain: (MuSrc);
                        Range: ManagementUnits_Sorted;
                        Property: NoSave;
                        Definition: {
                            First(mu_s | first(blk | MU_Block_Relation(mu_s, blk)
                            	and FormatString("%e",musrc) = FormatString("%e",blk) ) )
                        }
                    }
                    ElementParameter _BlkForMuSrc {
                        IndexDomain: (MuSrc);
                        Range: Blocks_Sorted;
                        Property: NoSave;
                        Definition: first(blk_s | 	 FormatString("%e",musrc) = FormatString("%e",blk_s) );
                    }
                    Procedure DuplicateHaulTime {
                        Body: {
                            !DebuggerBreakpoint;
                            !halt with "You must first pick source and target destinations for copying"
                            !       when Copy_To = '' or Copy_From = '' ;
                            !
                            !halt with "source and target destionation cannot be the same"
                            !       when Copy_To = Copy_From        ;
                            PageGetFocus(
                                    page : ActivePageName,
                                    tag : ActivePageTagName) ;
                            
                            !need to use Findstring() because tag contains PageName::Tag if the tag is on a tabbed page
                            if FindString( 	SearchString : ActivePageTagName, 	Key : "Copy_FromDest") > 0  then
                                    block !
                                            if Copy_DestFrom = '' then DialogGetElement("Source of data to copy",Copy_DestFrom); endif;
                                            if Copy_DestTo = '' then DialogGetElement("Mill to which data should be copied",Copy_DestTo); endif;
                            
                                            while (Copy_DestFrom = Copy_DestTo) and (Copy_DestFrom = '' or Copy_DestTo = '') do
                                                            DialogMessage("Source and Target must be different");
                                                            DialogGetElement("Source of data to copy",Copy_DestFrom);
                                                            DialogGetElement("Mill to which data should be copied",Copy_DestTo);
                                            endwhile;
                            
                                            if DialogAsk(message:FormatString("Copying HaulTime data from '%e' to '%e'",Copy_DestFrom,Copy_DestTo)
                                                            ,button1:"OK", button2:"Cancel",title: "Confirm Action") = 1 then
                                                            HaulTime((src,Copy_DestTo)  ) := HaulTime(src,Copy_DestFrom);
                                                            !HaulTime((src,dest) | dest = Copy_To ) := HaulTime(src,Copy_From);
                                            endif;
                                    endblock;
                            elseif FindString( 	SearchString : ActivePageTagName, 	Key : "Copy_FromSource") > 0  then
                                block !
                                    if Copy_SourceFrom = '' then DialogGetElement("Source of data to copy",Copy_SourceFrom); endif;
                                    if Copy_SourceTo = '' then DialogGetElement("Mill to which data should be copied",Copy_SourceTo); endif;
                            
                                    while (Copy_SourceFrom = Copy_SourceTo) and (Copy_SourceFrom = '' or Copy_SourceTo = '') do
                                        DialogMessage("Source and Target must be different");
                                        DialogGetElement("Source of data to copy",Copy_SourceFrom);
                                        DialogGetElement("Mill to which data should be copied",Copy_SourceTo);
                                    endwhile;
                            
                                    Switch ( DialogAsk(message:FormatString("Copying HaulTime data from '%e' to '%e'",Copy_SourceFrom,Copy_SourceTo)
                            			,button1:"OK", button2:"Missing Values",button3:"Cancel",title: "Confirm Action")  ) do
                            			1:   HaulTime((Copy_SourceTo,dest)  ) := HaulTime(Copy_SourceFrom,dest);
                            			2:  ! copy only missing values
                            				HaulTime((Copy_SourceTo,dest) | not HaulTime(Copy_SourceTo,dest)  )
                            						:= HaulTime(Copy_SourceFrom,dest);
                            			default:
                            				return 0;
                                     endswitch;
                            !        if DialogAsk(message:FormatString("Copying HaulTime data from '%e' to '%e'",Copy_SourceFrom,Copy_SourceTo)
                            !			,button1:"OK", button2:"Cancel",title: "Confirm Action") = 1 then
                            !          HaulTime((Copy_SourceTo,dest)  ) := HaulTime(Copy_SourceFrom,dest);
                            !        endif;
                                endblock;
                            else
                                    DialogError(    message : FormatString("Undefined tag name '%s' ",      ActivePageTagName) ,    title : "Error");
                            endif;
                        }
                    }
                    Procedure EmptyHaultimes {
                        Body: {
                            DialogMessage(FormatString("%n Haultimes(src,dest) =inf",
                            count((src,dest) | HaulTime(src,dest)/1[s] = inf)
                            ));
                            
                            
                            !DialogMessage(FormatString("%n Haultimes(src,dest) <= 5.55",
                            !count[(src,dest) | HaulTime(src,dest) <= 5.56]
                            !));
                            !DebuggerBreakpoint;
                            for(src,dest) do
                            	if ( HaulTime(src,dest)/1[s] = inf )  then
                            		empty haultime(src,dest);
                            	endif;
                            endfor;
                        }
                    }
                    Procedure EstimateHaultimesForResiduals {
                        Body: {
                            /* Calculates haultime between mills using nearest MU xy data
                            /**/
                            
                            ! --- confirm selection
                            if count(dest | UsesResiduals(dest)) < 1 then
                            	t := "You have not specified any mills that use residuals";
                            	DialogMessage(t,"No Mill Defined");
                            	return 1;
                            else
                            	t := "Do you wish to estimate Haultimes between facilities (residual producers and users) using the nearest MU";
                            	if DialogAsk(t,"Yes","No",title:"Enter Choice") <> 1 then return 1; endif;
                            endif;
                            
                            t := FormatString("Do you wish to estimate haultimes for 1.  All residual routes, or \n\n2. Routes without haultimes?%s","");
                            switch DialogAsk(t,button1: "All",button2:"Missing Only",button3:"Cancel",title:"Enter Choice") do
                            	1:	empty ReplaceOnlyMissingHaultimes;
                            	2:	ReplaceOnlyMissingHaultimes := 1;
                            	default: return 0;
                            endswitch;
                            
                            
                            ! --- for each valid route along which residuals can be shipped
                             for( (src,dest)
                             	| ProducesResiduals(src) 	! src produces residuals
                             	and UsesResiduals(dest)		! dest uses residuals
                             	! and the res produced by src is used by src
                             	and exists (res | sum[prd,ResidualsProduced(src,prd,res)] and ResidualsUsed(dest,res) )
                             	and if ReplaceOnlyMissingHaultimes then HaulTime(src,dest) else 1 endif
                             	) do
                            
                            !	if src='Bonifer' and dest = 'ACC_FF' then DebuggerBreakpoint; endif;
                             	!--- find the nearest MU to src
                             	Dist := FindNearestMU(Millxy(src,ixy),NearestMU);
                            
                             	!--- calculate the average Haultime from all blocks in MU to dest
                             	if count [blk | MU_Block_Relation(NearestMU,blk) and HaulTime(blk,dest) ] then
                             		! dk:  Note: 2) Time has same units as HaulTime, 2) need "and haultime()" to exclude ineligible blocks
                             		Time := Average[(blk) | MU_Block_Relation(NearestMU,blk) and HaulTime(blk,dest), HaulTime(blk,dest) ];
                            		!--- assign average haultime to (src,dest)
                            		HaulTime(src,dest) := Time;
                            !	else
                            !		HaulTime(src,dest) := inf;
                             	endif;
                             endfor;
                        }
                        ElementParameter NearestMU {
                            Range: ManagementUnits;
                        }
                        Parameter Dist;
                        ElementParameter c_MU {
                            Range: ManagementUnits;
                        }
                        StringParameter t;
                        Parameter ReplaceOnlyMissingHaultimes {
                            Range: binary;
                        }
                        Parameter Time {
                            Unit: hour;
                        }
                    }
                    Function CalcEuclideanDistance {
                        Arguments: (Px,Py,Qx,Qy);
                        Body: {
                            CalcEuclideanDistance := Sqrt( sqr(qx-px) + sqr(qy-py) );
                        }
                        Parameter Px {
                            Property: Input;
                        }
                        Parameter Py {
                            Property: Input;
                        }
                        Parameter Qx {
                            Property: Input;
                        }
                        Parameter Qy {
                            Property: Input;
                        }
                    }
                    Procedure testeuclid {
                        Body: {
                            current_dest := first(dest | millxy(dest,'x') and  millxy(dest,'y'));
                            current_mill := last(dest | millxy(dest,'x') and  millxy(dest,'y'));
                            
                            DialogMessage(
                            FormatString("The distance between %e and %e is %n",current_dest,current_mill,
                            CalcEuclideanDistance(Millxy( current_dest,'x'),Millxy( current_dest,'y'),Millxy( current_mill,'x'),Millxy( current_mill,'y'))),
                            "Calculated Distance");
                        }
                    }
                    Procedure XXTestFindNearestMillMU {
                        Body: {
                            current_dest := first(dest | millxy(dest,'x') and  millxy(dest,'y'));
                            current_mill := last(dest | millxy(dest,'x') and  millxy(dest,'y'));
                            
                            XXtestP('x') := [ millxy(current_dest,'x') +  millxy(current_mill,'x') ] /2 ;
                            XXtestP('y') := [ millxy(current_dest,'y') +  millxy(current_mill,'y') ] /2 ;
                            
                            
                            DistMill := FindNearestMill(xxtestP,_xxmill);
                            DialogMessage(
                            FormatString("The nearest mill to P(%n,%n) is %e (%n,%n)",XXtestP('x') ,XXtestP('y'),_xxmill,Millxy( _xxmill,'x'),Millxy( _xxmill,'y')),"Find Nearest Mill");
                            
                            DistMU := FindNearestMU(xxtestP,NearestMU);
                            DialogMessage(
                            FormatString("The nearest MU to P(%n,%n) is %e (%n,%n)",XXtestP('x') ,XXtestP('y'),NearestMU,MUxy( NearestMU,'x'),MUxy( NearestMU,'y')),"Find Nearest Mill");
                            
                            if distMU < DistMill then
                            	DialogMessage(FormatString("%e is closer at %n",NearestMU,distMU));
                            else
                            	DialogMessage(FormatString("%e is closer at %n",_xxmill,distMill));
                            endif;
                        }
                        Parameter DistMU;
                        Parameter DistMill;
                        ElementParameter NearestMU {
                            Range: ManagementUnits;
                        }
                    }
                    Procedure FindNearestMill {
                        Arguments: (P,Nearest);
                        Body: {
                            /* Fiind the nearest mill Dest
                             *
                             */
                            Nearest := '';
                            
                            NearDist := inf;
                            
                            for (dest) do
                            	if Millxy(dest,'x') <> 0 and millxy(dest,'y') <> 0 then
                            		dist := CalcEuclideanDistance(p('x'),p('y'),Millxy(dest,'x'),millxy(dest,'y'));
                            		if dist < NearDist then
                            			Nearest := Dest;
                            			NearDist := Dist;
                            		endif;
                            	endif;
                            endfor;
                            return Dist;
                        }
                        Parameter P {
                            IndexDomain: ixy;
                            Property: Input;
                        }
                        ElementParameter Nearest {
                            Range: Destinations;
                            Property: Output;
                        }
                        Parameter Dist;
                        Parameter NearDist;
                    }
                    Procedure FindNearestMU {
                        Arguments: (P,Nearest);
                        Body: {
                            /* Fiind the nearest block
                             *
                             */
                            Nearest := '';
                            
                            NearDist := inf;
                            
                            for (mu) do
                            	if MUxy(mu,'x') <> 0 and MUxy(mu,'y') <> 0 then
                            		dist := CalcEuclideanDistance(p('x'),p('y'),MUxy(mu,'x'),MUxy(mu,'y'));
                            		if dist < NearDist then
                            			Nearest := mu;
                            			NearDist := Dist;
                            		endif;
                            	endif;
                            endfor;
                            return Dist;
                        }
                        Parameter P {
                            IndexDomain: ixy;
                            Property: Input;
                        }
                        ElementParameter Nearest {
                            Range: ManagementUnits;
                            Property: Output;
                        }
                        Parameter Dist;
                        Parameter NearDist;
                    }
                    Procedure RecalculateTransportCostColourRamp {
                        Body: {
                            ! Recalculate HaulCostColourRamp only if flag set
                            ! flag is set on edit
                            if RecalculateTransportCostFLAG then
                            	if DialogAsk("Do you want to update the colours?","Yes","No",title:"Cost Inputs Have Changed")
                            		<> 1 then return 0 ; endif;
                            
                            else !confirm update desired
                            	if DialogAsk("Do you want to update the colours?","Yes","No",title:"Confirm Action")
                            		<> 1 then return 0 ; endif;
                            endif;
                            
                            RecalculateTransportCostColourRamp_wrk;
                        }
                    }
                    Procedure RecalculateTransportCostColourRamp_wrk {
                        Body: {
                            	AvgHaulCost(src, dest) :=
                            		sum(gprod,CalculatedTotalCostPerUnit(src,dest,gProd) )!$ (src,dest) in SrcCanSupplyDest )
                            		/$ count(gprod|CalculatedTotalCostPerUnit(src,dest,gProd) );! and (src,dest) in SrcCanSupplyDest);
                            
                            	rank(src, dest) :=
                            		count(src1 |! (src1,dest) in SrcCanSupplyDest and
                            					AvgHaulCost(src1,dest) < AvgHaulCost(src,dest) ) +1;
                            
                            	HaulCostQuantile(src, dest) :=
                            		ceil( rank(src,dest) /$ PotentialSupplierCount(dest) * NumberQuantiles )
                            		;
                            
                            	HaulCostColourRamp(src, dest) :=
                            		if not (src,dest) in PotentialSupplyRoutes then 'NA'
                            		elseif ValidRoutes(src,dest) <> 1 then  'TooFar'
                            		else
                            			First(imqco | FormatString("%e",imqco)
                            			=  FormatString("Q%n", HaulCostQuantile(src,dest) ) )
                            		endif;
                            
                            	RecalculateTransportCostFLAG := 0;
                        }
                    }
                    Procedure SetCostInputsChanged {
                        Body: {
                            RecalculateTransportCostFLAG := 1;
                        }
                    }
                }
                ElementParameter HaulTimeSupplyZoneColourRamp {
                    IndexDomain: ( MuSrc, dest_sort );
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        ! SupplyZoneColourRamp(dest_sort,_BlkForMuSrc(MuSrc))
                        ! calculation moved to Calculate_SupplyZones_wrk
                    }
                }
                Procedure SetCurrentPrd_CurrentGpr {
                    Body: {
                        Current_prd := ElementCast(AllProducts,Current_gpr,0);
                    }
                }
            }
            Section Exec_Pages {
                Procedure UpdateSelectorDescriptions {
                    Body: {
                        SelectorDescription( __IncludeOnlyAvailableBlocks )
                        	:= FormatString("Include %n (of %n) blocks", count(ablk ) , count(blk) ) ;
                        SelectorDescription( __IncludeOnlyAvailableMills )
                        	:= FormatString("Include %n (of %n) mills", count(adest ) , count(dest) ) ;
                    }
                }
            }
            Section Explore_Pages {
                Parameter AccessibleVolume {
                    IndexDomain: {
                        (blk,dest,prd) | (blk,dest) in AvailableSupplyRoutes
                        and (blk,dest,prd) in TimePermittedRoutesForProducts
                        !and ProductsUsed(dest, prd)
                        !and HaulTime(blk, dest)
                        !and HaulTime(blk, dest) <= MaxAllowedHaultime
                    }
                    Text: "Volume of prd available to dest from blk with Max Haultime";
                    Unit: ProductUnit(prd);
                    Property: NoSave;
                    Definition: GsAvailable(blk, prd);
                }
                Parameter PercentAccessibleVolumeUtilize {
                    IndexDomain: {
                        (dest,blk) | (blk,dest) in AccessibleSupplyRoutes
                        !and (blk,dest,prd) in TimePermittedRoutesForProducts
                        !and ProductsUsed(dest, prd)
                        !and HaulTime(blk, dest)
                        !and HaulTime(blk, dest) <= MaxAllowedHaultime
                    }
                    Text: "% volume in blk that can be used by dest";
                    Unit: %;
                    Property: NoSave;
                    Definition: {
                        sum[prd | ProductsUsed(dest, prd),GsAvailable(blk, prd)]
                        /$ sum[prd,GsAvailable(blk, prd)]
                    }
                }
                Parameter MAPAccessibleVolume {
                    IndexDomain: {
                        (blk,dest) | dest = Current_dest
                        and (blk,dest) in PotentialSupplyRoutes
                        and UsesProducts(dest)
                        and HaulTime(blk, dest)
                        and HaulTime(blk, dest) <= MaxAllowedHaultime
                    }
                    Text: "Volume of prd available to dest from blk with Max Haultime";
                    Unit: _ProductDefaultUnit_k;
                    Property: NoSave;
                    Definition: sum[ prd | ProductsUsed(dest, prd), AccessibleVolume(blk, dest, prd) ];
                }
                ElementParameter BlockCostColourRamp {
                    IndexDomain: (blk,dest);
                    Range: MapQuantileColours_Ordered;
                    Property: NoSave;
                    Definition: {
                        if 1 - HaulTime(blk, dest) /$ max(blk1,haultime(blk1,dest)) < 0.25 then 'Q4'
                        elseif 1 - HaulTime(blk, dest) /$ max(blk1,haultime(blk1,dest)) < 0.5 then 'Q3'
                        elseif 1 - HaulTime(blk, dest) /$ max(blk1,haultime(blk1,dest)) < 0.75 then 'Q2'
                        else 'Q1'
                        endif
                    }
                }
                Set SupplyZones {
                    Index: zone;
                    Parameter: _zone,__LowCost,__LowLim,__Altern,__LowRec,__Recovery,__Tradeoff;
                    Property: NoSave;
                    Definition: {
                        ! Supply zones (block categories) for a given destination
                        { 'LowCost', 			! Lowest cost wood that meets mill demand <= Recovery Cost
                          'LowLim' , 			! Lowest cost wood that meeds mill demand, but COST >= RECOVERY COST
                          'Altern' ,			! cheaper than Recovery, but higher than LowPref
                          'LowRec', 			! blocks in both LowCost and Recovery
                          'Recovery', 			! Highest cost wood <= Recovery Cost, from consecutively ranked (cost) blocks
                          'Tradeoff' 			! High-cost wood that if harvested, must be balanced by low-cost volumes
                          }
                        
                          /* NOTES
                           * 1.  The usual zones are LowCost+LowRec, LowRec+Recovery, TradeOff.
                           * 2.  The LowRec element is necessary because some LowCost blocks may also occur in the Recovery Zone
                           * 3.  If a destiantion has a LowLim zone, then it cannot have { LowCost, LowRec, Recovery }
                        */
                    }
                }
                Set SupplyZones_Main {
                    Index: mzone, mzone1;
                    Parameter: _mzone,__ZLowCost,__ZAltern,__ZRecovery,__ZTradeoff,_mzone1;
                    Property: NoSave;
                    Definition: {
                        ! Supply zones (block categories) for a given destination
                        { 'LowCost', 			! Lowest cost wood that meets mill demand <= Recovery Cost
                          'Altern' ,			! cheaper than Recovery, but higher than LowPref
                          'Recovery', 			! Highest cost wood <= Recovery Cost, from consecutively ranked (cost) blocks
                          'Tradeoff' 			! High-cost wood that if harvested, must be balanced by low-cost volumes
                          }
                    }
                }
                Set SupplyZones_Xref {
                    SubsetOf: (SupplyZones_Main,SupplyZones);
                    Property: NoSave;
                    Definition: {
                        { ('LowCost', 'LowCost'),
                          ('LowCost', 'LowLim') ,
                          ('LowCost', 'LowRec'),
                          ('Altern' , 'Altern'),
                          ('Recovery', 'LowRec'),
                          ('Recovery', 'Recovery'),
                          ('Tradeoff' , 'Tradeoff' )
                          }
                    }
                }
                ElementParameter SupplyZones_Lkp {
                    IndexDomain: (zone);
                    Range: SupplyZones_Main;
                    Property: NoSave;
                    Definition: first(mzone | SupplyZones_Xref(mzone,zone) );
                }
                ElementParameter SupplyZoneColourRamp {
                    IndexDomain: (dest,blk) | (blk,dest) in PotentialSupplyRoutes;
                    Range: AllColors;
                }
                ElementParameter DestSupplyZones {
                    IndexDomain: (dest,blk) | (blk,dest) in TimePermittedSupplyRoutes;
                    Text: "For supplying dest, blk is in supplyzone zone";
                    Range: SupplyZones;
                }
                ElementParameter SupplyZoneColours {
                    IndexDomain: (zone);
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        data{
                        'LowCost'  : 'Zone LowCost' ,
                        'LowLim'   : 'Zone LowLim' ,
                        'Altern'   : 'Zone Altern' ,
                        'LowRec'   : 'Zone LowRec',
                        'Recovery' : 'Zone Recovery',
                        'Tradeoff' : 'Zone Tradeoff'
                        }
                    }
                }
                Set BlockCosts {
                    IndexDomain: (dest);
                    SubsetOf: Blocks;
                    Text: "set of blocks that can supply dest ordered by haulcost";
                    Property: NoSave;
                    OrderBy: AverageCostPerUnit(blk, dest);
                    Definition: {
                        { blk | [(blk,dest) in TimePermittedSupplyRoutes ] and [ HaulTime(blk,dest) < MaxAllowedHaultime] }
                    }
                }
                Parameter AverageCostPerUnit {
                    IndexDomain: (src,dest)|  (src,dest) in TimePermittedSupplyRoutes;
                    Text: "Total cost (per m3) of loading and transporting gProd from src to dest";
                    Unit: $/_ProductDefaultUnit;
                    Comment: "Now calculated in procedure AssignAverageCostPerUnit";
                }
                Set DestUsingProduct {
                    SubsetOf: Destinations;
                    Property: NoSave;
                    OrderBy: dest;
                    Definition: {
                        { dest | UsesProducts(dest) and  [dest in AvailableDest]  }
                    }
                }
                ElementParameter _DestTemp {
                    Range: DestUsingProduct;
                    Property: NoSave;
                }
                Set BlocksFor_DestTemp {
                    SubsetOf: Blocks_Sorted;
                    Index: blk_GUI;
                    Parameter: _blk_GUI;
                    Property: NoSave;
                    OrderBy: blk_s;
                    Definition: {
                        {blk_s | (blk_s,_DestTemp) in AvailableSupplyRoutes }
                    }
                }
                ElementParameter _RecoveryThreshold {
                    Text: "Demand Threshold used to calculate recovery zone";
                    Range: Thresholds;
                    Property: NoSave;
                }
                Parameter MinimumPercentUtilizableVolume {
                    Text: "Minimum percent of block to utilize";
                    Range: [0, 100];
                    Unit: %;
                }
                Parameter BlkVolume {
                    IndexDomain: sblk;
                    Text: "Accessible Volume in sblk";
                    Unit: k_m3;
                    Property: NoSave;
                    Definition: sum[(prd) | SelectedProducts(prd), AccessibleVolume(sblk, _DestTemp, prd)];
                }
                Parameter BlkCost {
                    IndexDomain: sblk;
                    Text: "Cost of Volume in sblk";
                    Unit: 1000 * $;
                    Property: NoSave;
                    Definition: sum[(prd) | SelectedProducts(prd) , AccessibleVolume(sblk, _DestTemp, prd) * CalculatedTotalCostPerUnit(sblk, _DestTemp, Prd)];
                }
                Parameter CumVolume {
                    IndexDomain: (sblk);
                    Text: "Cumulative Volume in sblk";
                    Unit: k_m3;
                    Property: NoSave;
                    Definition: BlkVolume(sblk) + CumVolume(sblk-1);
                }
                Parameter CumCost {
                    IndexDomain: (sblk);
                    Text: "Cumulative cost of volume in sblk";
                    Unit: 1000 * $;
                    Property: NoSave;
                    Definition: BlkCost(sblk) + Cumcost(sblk-1);
                }
                Parameter PotentialDemand {
                    IndexDomain: (sblk,mzone);
                    Unit: k_m3;
                    Property: NoSave;
                    Definition: sum [ ( dest  ) , PotentialDemand_Dest(dest, sblk, mzone) ];
                }
                Parameter PotentialDemand_Dest {
                    IndexDomain: (dest,sblk,mzone) | (sblk,dest) in AccessibleSupplyRoutes;
                    Unit: k_m3;
                    Property: NoSave;
                    Definition: {
                        sum [ (  prgrp )
                        	| SupplyZones_Lkp( DestSupplyZones(dest, sblk) ) = mzone
                        		and exists( prd |cPrG(PrGrp,prd) and SelectedProducts(prd)
                        							and ProductsUsed(_DestTemp , prd)
                        							and (sblk,dest,prd) in TimePermittedRoutesForProducts
                        					)
                        , MillDemand_PrGrp_AllTerms(dest, PrGrp)
                        ]
                    }
                }
                Set BlockColourSelector {
                    Text: "Colouring scheme to use for Blocks on Supply Zone Map";
                    Index: bcs;
                    Parameter: _bcs;
                    Property: NoSave;
                    Definition: data { 'Supply Zone' , 'Haultime' , 'Cost' };
                }
                ElementParameter BlockColourRamp {
                    IndexDomain: (blk);
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        if blk = _blk_GUI or blk = Current_blk then 'corresponding'
                        elseif _bcs = 'Haultime' or _bcs = 'Cost' then !'green'
                        	if not (blk,_DestTemp) in PotentialSupplyRoutes then 'NA'
                        	else StringToElement(AllColors,
                        		FormatString("Q%i",Ceil( HaulTime(blk, _DestTemp)* 6 / MaxAllowedHaultime ) ) )
                        	endif
                        elseif SupplyZoneColourRamp( _DestTemp ,blk) then SupplyZoneColourRamp( _DestTemp ,blk)
                        else 'blue'
                        endif
                    }
                }
                Parameter HideDemandCurve {
                    Range: binary;
                    Property: NoSave;
                }
                Procedure Calculate_SupplyZones {
                    Body: {
                        !DebuggerBreakpoint;
                        /*********DESCRIPTION ***********************************************************************************************
                         * This procedure calculates the different supply zones for each destination => DestSupplyZones(dest)
                         * __LowCost 	Lowest cost wood that meets mill demand <= Recovery Cost
                         * __LowLim 	Lowest cost wood that meeds mill demand, but COST >= RECOVERY COST
                         * __LowRec 	Blocks in both LowCost and Recovery
                         * __Recovery 	Highest cost wood <= Recovery Cost, from consecutively ranked (cost) blocks
                         * __Tradeoff 	High-cost wood that if harvested, must be balanced by low-cost volumes
                         *
                         * 1.  The usual zones are LowCost+LowRec, LowRec+Recovery, TradeOff.
                         * 2.  The LowRec element is necessary because some LowCost blocks may also occur in the Recovery Zone
                         * 3.  If a destiantion has a LowLim zone, then it cannot have { LowCost, LowRec, Recovery }
                         ********************************************************************************************************/
                        
                        !DialogMessage("Need to add additional zones and CostRecovery condition");
                        
                        !AssignAverageCostPerUnit;
                        empty DestSupplyZones;
                        _DestTemp1 := _DestTemp;
                        
                        for (dest | dest in AvailableDest and  UsesProducts(dest)
                        				and exists(PrGrp | MillDemand_PrGrp_AllTerms(dest, PrGrp) ) ) do
                        	_DestTemp := dest;
                        	Calculate_SupplyZones_wrk;
                        endfor;
                        
                        _DestTemp := _DestTemp1;
                    }
                    ElementParameter _DestTemp1 {
                        Range: DestUsingProduct;
                    }
                }
                Procedure Calculate_SupplyZones_wrk {
                    Body: {
                        /*********DESCRIPTION ***********************************************************************************************
                         * This procedure calculates the different supply zones for each destination => DestSupplyZones(dest)
                         * __LowCost 	Lowest cost wood that meets mill demand <= Recovery Cost
                         * __LowLim 	Lowest cost wood that meeds mill demand, but COST >= RECOVERY COST
                         * __LowRec 	Blocks in both LowCost and Recovery
                         * __Recovery 	Highest cost wood <= Recovery Cost, from consecutively ranked (cost) blocks
                         * __Tradeoff 	High-cost wood that if harvested, must be balanced by low-cost volumes
                         *
                         * 1.  The usual zones are LowCost+LowRec, LowRec+Recovery, TradeOff.
                         * 2.  The LowRec element is necessary because some LowCost blocks may also occur in the Recovery Zone
                         * 3.  If a destiantion has a LowLim zone, then it cannot have { LowCost, LowRec, Recovery }
                         ********************************************************************************************************/
                        
                        
                        !for (dest | UsesProducts(dest) and exists(PrGrp | MillDemand_PrGrp_AllTerms(dest, PrGrp) ) ) do
                        	! clear DestSupplyZones for _DestTemp;
                        	DestSupplyZones((dest, blk) | dest=_DestTemp) := '';
                        	SupplyZoneColourRamp((dest, blk) | dest=_DestTemp)  := '' ;
                        	HaulTimeSupplyZoneColourRamp((MuSrc, dest) | dest=_DestTemp) := '';
                        
                        	! AccessibleSupplyRoutes reflect available supply within MaxHaulTime
                        	DefineGBlocksToSearch;
                        	BlocksToSearch := gBlocksToSearch;
                        
                        	block !==== Preferred Zones =====
                        !		if _DestTemp = 'Wey_Wawa' then DebuggerBreakpoint; endif;
                        	if IsRunningAsViewer or 1 then
                        		!retval is 1 unless demand not met
                        		DemandWasMet := SearchBlocksForVolume(_DestTemp,BlocksToSearch,_cblk,CostsRecovered);
                        	else
                        		!DebuggerBreakpoint;
                        		if not _RecoveryThreshold then _RecoveryThreshold := 'Low'; endif;
                        		SupplyZone_Demand(PrGrp) := MillDemand_PrGrp_AllTerms(_DestTemp, PrGrp)
                        				* sum [(sect) |  cMillSector(sect,_DestTemp), ThresholdStart(sect,_RecoveryThreshold) ];
                        
                        		SupplyZone_CostLimit := sum[PrGrp |  SupplyZone_Demand(PrGrp), SupplyZone_Demand(PrGrp) * max[prd | cPrG(PrGrp, prd), ProductValue(_DestTemp, prd)] ];
                        
                        		empty SupplyZoneFinderConstraints, SupplyZoneFinderVariables;
                        
                        
                        		SupplyZone_PenaltyWeights('SupplyZone_MeetDemand') := 999;
                        		SupplyZone_PenaltyWeights('SupplyZone_CostConstrol') := 1;
                        
                        		SupplyZone_SolveAsMaximize := 0;
                        		solveSupplyZone_Finder;
                        
                        		DemandWasMet 			:= if exists(PrGrp | SupplyZone_MeetDemand(PrGrp).Violation ) then 0 else 1 endif ;
                        		CostsRecovered	:= if SupplyZone_CostConstrol.Violation then 0 else 1 endif ;
                        		_cblk	:= Argmax(::sblk , count(sblk1 | sblk1 <= ::sblk and SupplyZone_BlockSelected(sblk1) ) );
                        
                        		if DemandWasMet=0 or CostsRecovered=0 then
                        			put console;
                        			put "==== Minimize =====";
                        			display SupplyZone_obj, DemandWasMet,costsrecovered,_cblk,SelectedBlockNum, SupplyZone_Cost ;
                        			putclose;
                        		endif;
                        
                        		empty SupplyZoneFinderConstraints, SupplyZoneFinderVariables;
                        		SupplyZone_SolveAsMaximize := 1;
                        		solveSupplyZone_Finder ;
                        		DemandWasMet 			:= if exists(PrGrp | SupplyZone_MeetDemand(PrGrp).Violation ) then 0 else 1 endif ;
                        		CostsRecovered	:= if SupplyZone_CostConstrol.Violation then 0 else 1 endif ;
                        		_cblk	:= Argmax(::sblk , count(sblk1 | sblk1 <= ::sblk and SupplyZone_BlockSelected(sblk1) ) );
                        
                        		put console;
                        		put "==== Maximize =====";
                        		display SupplyZone_obj, DemandWasMet,CostsRecovered,_cblk,SelectedBlockNum, SupplyZone_Cost ;
                        		putclose;
                        		halt;
                        		return 0;
                        	endif;
                        	endblock;
                        
                        		DestSupplyZones((_DestTemp,sblk) | ord(sblk,BlocksToSearch) <= ord(_cblk,BlocksToSearch))
                        		!DestSupplyZones((_DestTemp,blk) | ord(blk,BlockCosts(_DestTemp)) <= ord(_cblk,BlockCosts(_DestTemp)))
                        			:= if CostsRecovered and DemandWasMet then __LowCost else __LowLim endif;
                        
                        	if not ( CostsRecovered and DemandWasMet ) then
                        		! All other blocks are __Tradeoff
                        		DestSupplyZones( (_DestTemp, sblk) | not DestSupplyZones(_DestTemp, sblk) ) := __Tradeoff;
                        	else
                        		block !Find Recovery Zone
                        !		if _DestTemp = 'Goulard' then
                        !			DebuggerBreakpoint;
                        !			put console;
                        !		else putclose;
                        !		endif;
                        		block !OLD sequential search
                        !			i := 2;
                        !			while (i <= card(BlocksToSearch) ) do
                        !				!retval = 0 if demand not met
                        !				retval := SearchBlocksForVolume(_DestTemp,BlocksToSearch,_cblk,CostsRecovered,i);
                        !			if CostsRecovered and retval then
                        !				_StartBlk := Element(BlocksToSearch,i);
                        !				_EndBlock := Element(BlocksToSearch, ord(_cblk,BlocksToSearch));
                        !			else
                        !				break;
                        !			endif;
                        !				i += 1 ;
                        !			endwhile;
                        
                        		endblock;
                        
                        		block !new binary search
                        !			if _desttemp  = 'ACC_FF' then DebuggerBreakpoint; endif;
                        			empty _StartBlk, _EndBlock;
                        			_low := element(BlocksToSearch,2);
                        			_high := last(sblk);
                        			i := Floor( [ ord(_high,BlocksToSearch) - ord(_cblk,BlocksToSearch)] / 2 );
                        
                        			repeat
                        				DemandWasMet := SearchBlocksForVolume(_DestTemp,BlocksToSearch,_cblk,CostsRecovered,i);
                        				LastSearch := i;
                        
                        				if CostsRecovered and DemandWasMet then !Success
                        					LastSuccessfulSearch := i;
                        					_StartBlk := Element(BlocksToSearch,i);
                        					_EndBlock := Element(BlocksToSearch, ord(_cblk,BlocksToSearch));
                        					_low := Element(BlocksToSearch,i);
                        				else
                        					_high := Element(BlocksToSearch,i);
                        				endif;
                        				!if _high < _low then
                        				!	DialogError("Low > High"); DebuggerBreakpoint; endif;
                        				i := floor([ord(_high,BlocksToSearch) + ord(_low,BlocksToSearch)] / 2);
                        
                        				break when (LastSearch = i or i=1);
                        			endrepeat;
                        
                        		endblock;
                        
                        
                        
                        !		Put "==== ",_DestTemp," RECOVERY BLOCKS ==== from ",ord(_StartBlk),"to",ord(_EndBlock),/;
                        		TempBlocks := { sblk |   _StartBlk <= sblk <= _EndBlock };
                        !		display TempBlocks;
                        
                        		! Recovery zone
                        		! if DestSupplyZone already has a value (LowCost) then _LowRec (intersection)
                        		if _StartBlk and _EndBlock then
                        			DestSupplyZones((_DestTemp,sblk) |   _StartBlk <= sblk <= _EndBlock )
                        				:= if DestSupplyZones(_DestTemp,sblk)  then __LowRec else __Recovery endif;
                        
                        			! Blocks > LowCost and < Recovery are Altern
                        			DestSupplyZones((_DestTemp,sblk) | not DestSupplyZones(_DestTemp,sblk) and sblk < _StartBlk)
                        				:= __Altern;
                        			DestSupplyZones((_DestTemp,sblk) | sblk > _EndBlock) := __Tradeoff;
                        
                        			! Blocks > LowCost and < Recovery are Altern
                        			DestSupplyZones((_DestTemp,sblk) | not DestSupplyZones(_DestTemp,sblk) and sblk < _StartBlk)
                        				:= __Altern;
                        
                        			! TradeOff Zone
                        			DestSupplyZones((_DestTemp,sblk) | sblk > _EndBlock) := __Tradeoff;
                        			! DestSupplyZones((_DestTemp,sblk) | not DestSupplyZones(_DestTemp,sblk) ) := __Tradeoff;
                        		else
                        			DestSupplyZones((_DestTemp,sblk) | not DestSupplyZones(_DestTemp,sblk) ) := __Tradeoff;
                        		endif;
                        
                        		endblock;
                        	endif;
                        	! Assign colour ramp for zones
                        	SupplyZoneColourRamp(_DestTemp, sblk) := SupplyZoneColours(DestSupplyZones(_DestTemp,sblk));
                        	HaulTimeSupplyZoneColourRamp(MuSrc, dest_sort) := SupplyZoneColourRamp(dest_sort,_BlkForMuSrc(MuSrc))
                        !endfor;
                        !putclose;
                    }
                    Set BlocksToSearch {
                        SubsetOf: Blocks;
                        Index: sblk;
                        Parameter: _StartBlk, _EndBlock, _low, _high;
                        OrderBy: user;
                    }
                    Set TempBlocks {
                        SubsetOf: Blocks;
                        OrderBy: user;
                    }
                    ElementParameter _cblk {
                        Range: Blocks;
                    }
                    Parameter Demand {
                        IndexDomain: (PrGrp);
                        Unit: ProductGroupUnit(PrGrp);
                    }
                    Parameter CostsRecovered {
                        Range: binary;
                    }
                    File Console {
                        Name: "Console";
                        Device: window;
                        Mode: replace;
                    }
                    Parameter i {
                        Range: integer;
                    }
                    Parameter DemandWasMet {
                        Range: binary;
                    }
                    Parameter LastSearch {
                        Range: integer;
                    }
                    Parameter LastSuccessfulSearch {
                        Range: integer;
                    }
                }
                Procedure solveSupplyZone_Finder {
                    Body: {
                        if SupplyZone_SolveAsMaximize then
                        	solve SupplyZoneFinder where direction := 'maximize';
                        else
                        	solve SupplyZoneFinder where direction := 'minimize';
                        endif;
                    }
                }
                Procedure Copy_Calculate_SupplyZones_wrk {
                    Body: {
                        /*********DESCRIPTION ***********************************************************************************************
                         * This procedure calculates the different supply zones for each destination => DestSupplyZones(dest)
                         * __LowCost 	Lowest cost wood that meets mill demand <= Recovery Cost
                         * __LowLim 	Lowest cost wood that meeds mill demand, but COST >= RECOVERY COST
                         * __LowRec 	Blocks in both LowCost and Recovery
                         * __Recovery 	Highest cost wood <= Recovery Cost, from consecutively ranked (cost) blocks
                         * __Tradeoff 	High-cost wood that if harvested, must be balanced by low-cost volumes
                         *
                         * 1.  The usual zones are LowCost+LowRec, LowRec+Recovery, TradeOff.
                         * 2.  The LowRec element is necessary because some LowCost blocks may also occur in the Recovery Zone
                         * 3.  If a destiantion has a LowLim zone, then it cannot have { LowCost, LowRec, Recovery }
                         ********************************************************************************************************/
                        
                        
                        !for (dest | UsesProducts(dest) and exists(PrGrp | MillDemand_PrGrp_AllTerms(dest, PrGrp) ) ) do
                        	! clear DestSupplyZones for _DestTemp;
                        	DestSupplyZones((dest, blk) | dest=_DestTemp) := '';
                        	SupplyZoneColourRamp((dest, blk) | dest=_DestTemp)  := '' ;
                        	HaulTimeSupplyZoneColourRamp((MuSrc, dest) | dest=_DestTemp) := '';
                        
                        	! AccessibleSupplyRoutes reflect available supply within MaxHaulTime
                        	BlocksToSearch := sort(blk | [(blk,_DestTemp) in AccessibleSupplyRoutes ]
                        									and if MinimumPercentUtilizableVolume then
                        											PercentAccessibleVolumeUtilize(_DestTemp, blk) >= MinimumPercentUtilizableVolume
                        										else 1 endif
                        						,HaulTime(blk,_DestTemp)  );
                        
                        	block !==== Preferred Zones =====
                        !		if dest = 'ACC_FF' then DebuggerBreakpoint; endif;
                        		!retval is 1 unless demand not met
                        		retval := SearchBlocksForVolume(_DestTemp,BlocksToSearch,_cblk,CostsRecovered);
                        
                        		DestSupplyZones((_DestTemp,sblk) | ord(sblk,BlocksToSearch) <= ord(_cblk,BlocksToSearch))
                        		!DestSupplyZones((_DestTemp,blk) | ord(blk,BlockCosts(_DestTemp)) <= ord(_cblk,BlockCosts(_DestTemp)))
                        			:= if CostsRecovered and retval then __LowCost else __LowLim endif;
                        	endblock;
                        
                        	if not CostsRecovered and retval then
                        		! All other blocks are __Tradeoff
                        		DestSupplyZones( (_DestTemp, sblk) | not DestSupplyZones(_DestTemp, sblk) ) := __Tradeoff;
                        	else
                        		block !Find Recovery Zone
                        !		if _DestTemp = 'Goulard' then
                        !			DebuggerBreakpoint;
                        !			put console;
                        !		else putclose;
                        !		endif;
                        		block !OLD sequential search
                        !			i := 2;
                        !			while (i <= card(BlocksToSearch) ) do
                        !				!retval = 0 if demand not met
                        !				retval := SearchBlocksForVolume(_DestTemp,BlocksToSearch,_cblk,CostsRecovered,i);
                        !			if CostsRecovered and retval then
                        !				_StartBlk := Element(BlocksToSearch,i);
                        !				_EndBlock := Element(BlocksToSearch, ord(_cblk,BlocksToSearch));
                        !			else
                        !				break;
                        !			endif;
                        !				i += 1 ;
                        !			endwhile;
                        
                        		endblock;
                        
                        		block !new binary search
                        !			if _desttemp  = 'ACC_FF' then DebuggerBreakpoint; endif;
                        			empty _StartBlk, _EndBlock;
                        			_low := element(BlocksToSearch,2);
                        			_high := last(sblk);
                        			i := Floor( [ ord(_high,BlocksToSearch) - ord(_cblk,BlocksToSearch)] / 2 );
                        
                        			repeat
                        				retval := SearchBlocksForVolume(_DestTemp,BlocksToSearch,_cblk,CostsRecovered,i);
                        				LastSearch := i;
                        
                        				if CostsRecovered and retval then !Success
                        					LastSuccessfulSearch := i;
                        					_StartBlk := Element(BlocksToSearch,i);
                        					_EndBlock := Element(BlocksToSearch, ord(_cblk,BlocksToSearch));
                        					_low := Element(BlocksToSearch,i);
                        				else
                        					_high := Element(BlocksToSearch,i);
                        				endif;
                        				!if _high < _low then
                        				!	DialogError("Low > High"); DebuggerBreakpoint; endif;
                        				i := floor([ord(_high,BlocksToSearch) + ord(_low,BlocksToSearch)] / 2);
                        
                        				break when (LastSearch = i or i=1);
                        			endrepeat;
                        
                        		endblock;
                        
                        
                        
                        !		Put "==== ",_DestTemp," RECOVERY BLOCKS ==== from ",ord(_StartBlk),"to",ord(_EndBlock),/;
                        		TempBlocks := { sblk |   _StartBlk <= sblk <= _EndBlock };
                        !		display TempBlocks;
                        
                        		! Recovery zone
                        		! if DestSupplyZone already has a value (LowCost) then _LowRec (intersection)
                        		if _StartBlk and _EndBlock then
                        			DestSupplyZones((_DestTemp,sblk) |   _StartBlk <= sblk <= _EndBlock )
                        				:= if DestSupplyZones(_DestTemp,sblk)  then __LowRec else __Recovery endif;
                        
                        			! Blocks > LowCost and < Recovery are Altern
                        			DestSupplyZones((_DestTemp,sblk) | not DestSupplyZones(_DestTemp,sblk) and sblk < _StartBlk)
                        				:= __Altern;
                        			DestSupplyZones((_DestTemp,sblk) | sblk > _EndBlock) := __Tradeoff;
                        
                        			! Blocks > LowCost and < Recovery are Altern
                        			DestSupplyZones((_DestTemp,sblk) | not DestSupplyZones(_DestTemp,sblk) and sblk < _StartBlk)
                        				:= __Altern;
                        
                        			! TradeOff Zone
                        			DestSupplyZones((_DestTemp,sblk) | sblk > _EndBlock) := __Tradeoff;
                        			! DestSupplyZones((_DestTemp,sblk) | not DestSupplyZones(_DestTemp,sblk) ) := __Tradeoff;
                        		else
                        			DestSupplyZones((_DestTemp,sblk) | not DestSupplyZones(_DestTemp,sblk) ) := __Tradeoff;
                        		endif;
                        
                        		endblock;
                        	endif;
                        	! Assign colour ramp for zones
                        	SupplyZoneColourRamp(_DestTemp, sblk) := SupplyZoneColours(DestSupplyZones(_DestTemp,sblk));
                        	HaulTimeSupplyZoneColourRamp(MuSrc, dest_sort) := SupplyZoneColourRamp(dest_sort,_BlkForMuSrc(MuSrc))
                        !endfor;
                        !putclose;
                    }
                    Set BlocksToSearch {
                        SubsetOf: Blocks;
                        Index: sblk;
                        Parameter: _StartBlk, _EndBlock, _low, _high;
                        OrderBy: user;
                    }
                    Set TempBlocks {
                        SubsetOf: Blocks;
                        OrderBy: user;
                    }
                    ElementParameter _cblk {
                        Range: Blocks;
                    }
                    Parameter Demand {
                        IndexDomain: (PrGrp);
                        Unit: ProductGroupUnit(PrGrp);
                    }
                    Parameter CostsRecovered {
                        Range: binary;
                    }
                    File Console {
                        Name: "Console";
                        Device: window;
                        Mode: replace;
                    }
                    Parameter i {
                        Range: integer;
                    }
                    Parameter retval {
                        Range: integer;
                    }
                    Parameter LastSearch {
                        Range: integer;
                    }
                    Parameter LastSuccessfulSearch {
                        Range: integer;
                    }
                }
                Procedure ClearSupplyZoneColourRamp {
                    Body: {
                        empty SupplyZoneColourRamp;
                    }
                }
                Section Supply_Zone_Model_Section {
                    Procedure DefineGBlocksToSearch {
                        Body: {
                            !Define ordererd set of blocks that meet conditions
                            
                            empty _EndBlock, _blk_GUI, Current_blk ;
                            
                            !-- make suer CalcualtedTotalCostPerUnit is calculated;
                            AssignCalculatedTotalCostPerUnit;
                            
                            gBlocksToSearch := sort(blk | [(blk,_DestTemp) in AccessibleSupplyRoutes ]
                            								and exists(prd|CalculatedTotalCostPerUnit(blk, _DestTemp, Prd))
                            								and if MinimumPercentUtilizableVolume then
                            										PercentAccessibleVolumeUtilize(_DestTemp, blk) >= MinimumPercentUtilizableVolume
                            									else 1 endif
                            					,HaulTime(blk,_DestTemp)  );
                        }
                    }
                    Parameter SupplyZone_SolveAsMaximize {
                        Range: binary;
                        Unit: 1;
                        Property: NoSave;
                        InitialData: 0;
                    }
                    Parameter SupplyZone_Demand {
                        IndexDomain: (PrGrp);
                        Unit: ProductGroupUnit(PrGrp);
                    }
                    Parameter SupplyZone_CostLimit {
                        Unit: 1000 * $;
                        Property: NoSave;
                    }
                    Parameter SupplyZone_UnitCost {
                        IndexDomain: (sblk,prd);
                        Unit: $/ProductUnit(prd);
                        Property: NoSave;
                        Definition: CalculatedTotalCostPerUnit(sblk, _DestTemp, Prd);
                    }
                    Parameter BlockNum {
                        IndexDomain: (sblk);
                        Property: NoSave;
                        Definition: ord(sblk);
                    }
                    Parameter SelectedBlockNum {
                        IndexDomain: (sblk);
                        Property: NoSave;
                        Definition: {
                            BlockNum(::sblk | SupplyZone_BlockSelected(::sblk)) ;
                        }
                    }
                    Set gBlocksToSearch {
                        SubsetOf: Blocks;
                        Index: sblk, sblk1;
                        Parameter: _EndBlock, _low, _high;
                        OrderBy: user;
                    }
                    Set SupplyZoneFinderVariables {
                        SubsetOf: AllVariables;
                        Property: NoSave;
                        Definition: {
                            AllVariables * Supply_Zone_Model_Section
                            - AllVariables * SupplyZone_Unused_Section
                        }
                    }
                    Set SupplyZoneFinderConstraints {
                        SubsetOf: AllConstraints;
                        Property: NoSave;
                        Definition: {
                            AllConstraints  * Supply_Zone_Model_Section
                             - AllConstraints  * SupplyZone_Unused_Section
                        }
                    }
                    Variable SupplyZone_BlockSelected {
                        IndexDomain: sblk;
                        Range: binary;
                        Unit: 1;
                        Property: NoSave;
                    }
                    Variable SupplyZone_isStartBlock {
                        IndexDomain: (sblk);
                        Range: binary;
                        Unit: 1;
                    }
                    Constraint SupplyZone_OneStartingBlock {
                        Text: "Only 1 blk can be selected as the starting block";
                        Definition: sum[sblk , SupplyZone_isStartBlock(sblk)  ] <= 1;
                    }
                    Constraint SupplyZone_SelectionStart {
                        IndexDomain: (sblk);
                        Definition: {
                            !sum[sblk , SupplyZone_isStartBlock(sblk)  ] <= 1
                            
                            SupplyZone_isStartBlock(sblk) >= SupplyZone_BlockSelected(sblk) - SupplyZone_BlockSelected(sblk-1)
                        }
                    }
                    Variable SupplyZone_Allocation {
                        IndexDomain: {
                            (sblk,prd,prgrp) | cPrG(PrGrp, prd)
                            and ProductsUsed(_DestTemp, prd) and ProductsUsed_PrGrp(_desttemp, PrGrp)
                            and GsAvailable(sblk, prd)
                        }
                        Text: "volume of prd allocated to _desttemp from sblk to meet demand for prgrp";
                        Range: nonnegative;
                        Unit: ProductUnit_k(prd);
                        Property: NoSave;
                    }
                    Variable SupplyZone_Cost {
                        IndexDomain: (sblk,prd) | ProductsUsed(_desttemp, prd);
                        Text: "cost of delivering prd to _desttemp from sblk";
                        Range: nonnegative;
                        Unit: 1000 * $;
                        Property: NoSave;
                        Definition: {
                            sum[Prgrp | cPrG(PrGrp, prd) and ProductsUsed_PrGrp(_desttemp, PrGrp)
                            	, SupplyZone_Allocation(sblk,prd,PrGrp)] *  SupplyZone_UnitCost(sblk, prd)
                        }
                    }
                    Constraint SupplyZone_NoOverAllocation {
                        IndexDomain: (sblk,prd) | GsAvailable(sblk, prd) and ProductsUsed(_DestTemp, prd);
                        Unit: ProductUnit_k(prd);
                        Property: NoSave;
                        Definition: {
                            sum[prgrp,SupplyZone_Allocation(sblk, prd, PrGrp)]
                            <=
                            GsAvailable(sblk, prd) * SupplyZone_BlockSelected(sblk)
                        }
                    }
                    Constraint SupplyZone_UnderAllocation {
                        IndexDomain: {
                            (sblk,prd) | GsAvailable(sblk, prd) and ProductsUsed(_DestTemp, prd)
                            and GsAvailable(sblk+1, prd)
                        }
                        Text: "The proportion unallocated in sblk <= proportion unallocated in sblk+1";
                        Unit: 1;
                        Property: NoSave;
                        Definition: {
                            SupplyZone_BlockSelected(sblk)
                            	-  sum[prgrp,SupplyZone_Allocation(sblk, prd, PrGrp)] / GsAvailable(sblk, prd)
                            <=
                            SupplyZone_BlockSelected(sblk+1)
                            	- sum[prgrp,SupplyZone_Allocation(sblk+1, prd, PrGrp)] / GsAvailable(sblk+1, prd)
                        }
                        Comment: "Rearranged form of [ GS * Sel - Alloc ] / GS";
                    }
                    Constraint SupplyZone_MeetDemand {
                        IndexDomain: PrGrp | SupplyZone_Demand(PrGrp);
                        Unit: ProductGroupUnit(PrGrp);
                        Property: NoSave;
                        Definition: {
                            sum[(sblk,prd)  , SupplyZone_Allocation(sblk, prd, PrGrp) ]
                            >= SupplyZone_Demand(PrGrp)
                        }
                    }
                    Constraint SupplyZone_CostConstrol {
                        Unit: 1000 * $;
                        Definition: sum[ (sblk, prd) , SupplyZone_Cost(sblk, prd) ] <= SupplyZone_CostLimit;
                    }
                    Set SupplyZone_VariablesConstraintsWithViolationPenalties {
                        SubsetOf: AllVariablesConstraints;
                        Text: "Constraints for which users can set violation penalties";
                        Index: sz_pen;
                        Parameter: _sz_pen;
                        Property: NoSave;
                        Definition: {
                            { 'SupplyZone_MeetDemand' , 'SupplyZone_CostConstrol' }
                        }
                    }
                    Parameter SupplyZone_PenaltyWeights {
                        IndexDomain: (sz_pen);
                        Unit: 1;
                    }
                    Variable SupplyZone_obj {
                        Range: free;
                        Unit: 1000 * $;
                        Property: NoSave;
                        Definition: {
                            !sum[ (sblk,prd) , SupplyZone_Cost(sblk, prd) ]
                            !+ sum(sblk , SupplyZone_BlockSelected(sblk) * 100 [$] )
                            
                            if SupplyZone_SolveAsMaximize then
                            	sum[ (sblk,prd) , SupplyZone_Cost(sblk, prd) - 1e-3 [$] * SupplyZone_BlockSelected(sblk)]
                            else
                            	sum[ (sblk,prd) , SupplyZone_Cost(sblk, prd) + 1e-3 [$]  * SupplyZone_BlockSelected(sblk)]
                            endif
                        }
                    }
                    MathematicalProgram SupplyZoneFinder {
                        Objective: SupplyZone_obj;
                        Direction: minimize;
                        Constraints: SupplyZoneFinderConstraints;
                        Variables: SupplyZoneFinderVariables;
                        Type: Automatic;
                        ViolationPenalty: SupplyZone_PenaltyWeights;
                    }
                    Section SupplyZone_Unused_Section {
                        Constraint SupplyZone_BigM {
                            IndexDomain: (sblk);
                            Unit: m3;
                            Property: NoSave;
                            Definition: {
                                	sum[(prd, PrGrp) , SupplyZone_Allocation(sblk, prd, PrGrp) ]  	! tot vol Allocated from sblk
                                	- HugeNumber *  SupplyZone_BlockSelected(sblk)					! minus huge number
                                	<= 0 [m3]
                            }
                        }
                        Constraint SupplyZone_SmallM {
                            IndexDomain: (sblk);
                            Unit: 1;
                            Property: NoSave;
                            Definition: {
                                	sum[(prd, PrGrp) , SupplyZone_Allocation(sblk, prd, PrGrp) ]  / 1 [m3]	! tot vol Allocated from sblk
                                	- SupplyZone_BlockSelected(sblk) / 9e9  ! minus hugenumber
                                	>= 0
                            }
                        }
                        Variable SupplyZone_FinalGS {
                            IndexDomain: (sblk,prd) | GsAvailable(sblk, prd);
                            Range: nonnegative;
                            Unit: m3;
                            Definition: GsAvailable(sblk, prd) * SupplyZone_BlockSelected(sblk) - sum [PrGrp , SupplyZone_Allocation(sblk, prd, PrGrp)];
                        }
                        Constraint x {
                            IndexDomain: sblk | 1 < ord(sblk)  < card(sblk);
                            Definition: {
                                
                                SupplyZone_BlockSelected(sblk-1) + SupplyZone_BlockSelected(sblk+1) <= 2 * SupplyZone_BlockSelected(sblk)
                            }
                        }
                        Variable SupplyZone_EndBlock {
                            Range: {
                                {1..inf}
                            }
                        }
                        Constraint SupplyZone_StartBlockDef {
                            IndexDomain: sblk;
                            Definition: BlockNum(sblk) *  SupplyZone_BlockSelected(sblk) >= SupplyZone_isStartBlock(sblk);
                        }
                        Constraint SupplyZone_EndBlockDef {
                            IndexDomain: sblk;
                            Definition: BlockNum(sblk) *  SupplyZone_BlockSelected(sblk) <= SupplyZone_EndBlock;
                        }
                        Constraint SupplyZone_ConsecutiveBlocksSelected {
                            Property: NoSave;
                            Definition: {
                                sum[sblk, SupplyZone_BlockSelected(sblk)]
                                =
                                SupplyZone_EndBlock - sum[sblk,SupplyZone_isStartBlock(sblk)] + 1
                            }
                        }
                        Constraint SupplyZone_ConsecutiveBlocksSelected_Lower {
                            IndexDomain: sblk;
                            Property: NoSave;
                            Definition: BlockNum(sblk) *  SupplyZone_BlockSelected(sblk) <= SupplyZone_EndBlock;
                        }
                        Constraint SupplyZone_ConsecutiveBlocksSelected_Upper {
                            IndexDomain: sblk;
                            Property: NoSave;
                            Definition: ord(sblk) * SupplyZone_BlockSelected(sblk) >= SupplyZone_isStartBlock(sblk);
                        }
                        Constraint SelectOnlyRequiredBlocks {
                            IndexDomain: sblk;
                            Unit: 1;
                            Definition: {
                                	sum[(prd, PrGrp) , SupplyZone_Allocation(sblk, prd, PrGrp) ]  	! tot vol Allocated from sblk
                                	/ 1 [_ProductDefaultUnit]										! for unit compatibility
                                	+ 0.001
                                	>= SupplyZone_BlockSelected(sblk)
                            }
                        }
                    }
                }
                Procedure SearchBlocksForVolume {
                    Arguments: (_dest,SearchBlocks,_LastBlockReqd,CostsRecovered,Start);
                    Body: {
                        !DebuggerBreakpoint;
                        if start = 0 then start := 1; endif;
                        
                        !for (dest | UsesProducts(dest) and exists(PrGrp | MillDemand_PrGrp_AllTerms(dest, PrGrp) ) ) do
                        !		if _dest = 'Ohaavald' then DebuggerBreakpoint; endif;
                        
                        block	! accounting parameters
                        	! Demand can be based on MillDemand or a Thresholds Demand (specified by _RecoverThreshold
                        	! ThresholdStart is the % of demand below which the threshold starts; _Low starts at 100%
                        	Demand(PrGrp) := MillDemand_PrGrp_AllTerms(_dest, PrGrp) ;
                        	if not _RecoveryThreshold then _RecoveryThreshold := 'Low'; endif;
                        	if exists(sect | [cMillSector(sect,_dest) and ThresholdStart(sect ,_RecoveryThreshold)] $ _RecoveryThreshold) then
                        		Demand(PrGrp) *= sum [(sect) |  cMillSector(sect,_dest), ThresholdStart(sect,_RecoveryThreshold) ];
                        	endif;
                        
                        	AccessVol((blk,  prd) | blk in SearchBlocks and ord(blk,SearchBlocks) >= Start)
                        		:= AccessibleVolume(blk, _dest, prd);
                        	empty Alloc, AllocCost, CostExceeded_Flag;
                        endblock;
                        	/*
                        	! CostLimit - value of products * Mill demand
                        	! ProductValue (amount dest will pay for prd) is by product, not product-group, e.g. demand
                        	! for SPF can be met by Sb, Sw, Pj, or Bf but mill pays different amounts
                        	! use the maximum  paid as a cost limit
                        	*/
                        	CostLimit := sum[PrGrp |  Demand(PrGrp), Demand(PrGrp) * max[prd | cPrG(PrGrp, prd), ProductValue(_dest, prd)] ];
                        
                        	! cycle through blocks beginning with least expensive, requires used of ORDERED
                        	ordered for (blk in SearchBlocks | ord(blk,SearchBlocks)>=Start) do  "BlockLoop"
                        		! set of product groups for which block can contribute to demand
                        		PrGrp_InBlock := {PrGrp | Demand(PrGrp)
                        								and exists(prd | AccessVol(blk, prd) and cPrG(PrGrp, prd )) };
                        
                        		! for each PrGrp that has unmet demand to which blk can contribute
                        		_cPrGrp := First(PrGrp in PrGrp_InBlock);
                        
                        		repeat ! for each PrGrp
                        			for prd | cPrG(_cPrGrp, prd) do
                        				_cblk := blk;
                        				TempAlloc := if Demand(_cPrGrp) >= AccessVol(blk, prd)
                        									then AccessVol(blk,prd)
                        									else Demand(_cPrGrp) endif ;
                        				Alloc(_dest, _cPrGrp) += TempAlloc ;
                        				AllocCost += TempAlloc * CalculatedTotalCostPerUnit(blk, _dest, Prd);
                        				if AllocCost > CostLimit then CostExceeded_Flag := 1; endif;
                        				Demand(_cPrGrp) -= TempAlloc;
                        				AccessVol(blk,prd) -= TempAlloc;
                        
                        				break when (AccessVol(blk, prd) <= 0 [m3] or Demand(_cPrGrp) <= 0 [m3]) ;
                        			endfor;
                        
                        			break when (_cPrGrp = Last(prgrp in PrGrp_InBlock) or Demand(_cPrGrp) <=0 [m3]);
                        			_cPrGrp := _cPrGrp + 1;
                        		endrepeat;
                        
                        		break when sum[prgrp,Demand(PrGrp)] <= 0 [m3] ;
                        	endfor;
                        
                        	!s := FormatString("The last Preferred block for %e is %e",dest,_cblk);
                        	!DialogMessage(s,"Block Report");
                        !		DestSupplyZones((dest,blk) | ord(blk,BlockCosts(dest)) <= ord(_cblk,BlockCosts(dest)))
                        !			:= if CostExceeded_Flag then __LowLim else __LowCost endif;
                        	_LastBlockReqd := _cblk;
                        	CostsRecovered := not CostExceeded_Flag;
                        
                        	! Demand() should be zero if demand has been met
                        	if sum[prgrp,Demand(PrGrp)] then
                        		return 0;
                        	else
                        		return 1;
                        	endif;
                    }
                    Parameter AccessVol {
                        IndexDomain: (blk,prd);
                        Unit: ProductUnit(prd);
                    }
                    ElementParameter _cblk {
                        Range: Blocks;
                    }
                    Parameter Alloc {
                        IndexDomain: (dest,PrGrp);
                        Unit: ProductGroupUnit(PrGrp);
                    }
                    Parameter Demand {
                        IndexDomain: (PrGrp);
                        Unit: ProductGroupUnit(PrGrp);
                    }
                    ElementParameter _cPrGrp {
                        Range: PrGrp_InBlock;
                    }
                    Set PrGrp_InBlock {
                        SubsetOf: ProductGroups;
                    }
                    Parameter TempAlloc {
                        Unit: _ProductDefaultUnit;
                    }
                    Parameter CostLimit {
                        Unit: $;
                    }
                    Parameter AllocCost {
                        Unit: $;
                    }
                    Parameter CostExceeded_Flag {
                        Range: binary;
                    }
                    StringParameter s;
                    File Console {
                        Name: "Console";
                        Device: window;
                        Mode: replace;
                    }
                    Set SearchBlocks {
                        SubsetOf: Blocks;
                        Index: sblk;
                        Property: Input;
                    }
                    ElementParameter _dest {
                        Range: Destinations;
                        Property: Input;
                    }
                    ElementParameter _LastBlockReqd {
                        Range: Blocks;
                        Property: Output;
                    }
                    Parameter CostsRecovered {
                        Range: binary;
                        Property: Output;
                    }
                    Parameter Start {
                        Property: Optional;
                    }
                }
                Procedure AssignAverageCostPerUnit {
                    Body: {
                        !Based on AssignCalculatedTotalCostPerUnit
                        ValidSupplies := { (blk,dest) | (blk,dest) in  TimePermittedSupplyRoutes
                        		 						and (blk,dest) in AvailableSupplyRoutes
                        					! and HaulTime(src,dest) < MaxAllowedHaultime
                        					};
                        
                        for ( vsupp  ) do
                         	if HaulTime(vsupp.vsrc,vsupp.vdest) then
                        		if IsSelected(__HaulTimeAsCost) then
                        			AverageCostPerUnit(vsupp.vsrc, vsupp.vdest)
                        				:= HaulTime(vsupp.vsrc,vsupp.vdest) * 1 [$] / 1 [ _ProductDefaultUnit ] / 1 [hour] ;
                        		else
                        		cProd := first(prd | ProductsUsed(vsupp.vdest, prd) );
                        		AverageCostPerUnit(vsupp.vsrc, vsupp.vdest) :=
                        			2 * HaulTime(vsupp.vsrc,vsupp.vdest) /$ VolumePerLoad(cProd) * TruckRate(cProd)
                        			+ LoadingCostPerLoad(cProd) /$ VolumePerLoad(cProd)
                        			;
                        		endif
                        	else
                        		AverageCostPerUnit(vsupp.vsrc, vsupp.vdest) :=  0 [$/m3] ;
                        	endif;
                        endfor;
                    }
                    Comment: {
                        "for ( (src,dest,gProd) | (src,dest,gProd)  in ValidSupplies
                         ) do
                         	if HaulTime(src,dest) then
                        		if IsSelected(__HaulTimeAsCost) then
                        			CalculatedTotalCostPerUnit(src, dest, gProd)
                        				:= HaulTime(src,dest) * 1 [$] / 1 [ProductUnit(gprod)] / 1 [hour] ;
                        		else
                        		CalculatedTotalCostPerUnit(src, dest, gProd) :=
                        			2 * HaulTime(src,dest) /$ VolumePerLoad(gProd) * TruckRate(gProd)
                        			+ LoadingCostPerLoad(gProd) /$ VolumePerLoad(gProd)
                        			;
                        		endif
                        	else
                        		CalculatedTotalCostPerUnit(src, dest, gProd) :=  999 [$/m3] ;
                        	endif;
                        endfor;"
                    }
                    Set ValidSupplies {
                        SubsetOf: (AllSources, Destinations);
                        Tags: (vsrc, vdest);
                        Index: vsupp;
                    }
                    ElementParameter cProd {
                        Range: Products;
                    }
                }
                Procedure InitializeAccessibleVolume {
                    Body: {
                        SetLastViewedChildPage;
                        AssignAverageCostPerUnit;
                        
                        if count( ims | VisibleArea_Accessible(iMS) < 4) then
                        	ZoomToFullExtent;
                        endif;
                    }
                }
                DeclarationSection Competition_Declaration {
                    Set NoCompetitionBlocks {
                        SubsetOf: AvailableBlocks;
                        Text: "All available blocks where each product is required by at most 1 dest";
                        Property: NoSave;
                        OrderBy: aBlk;
                        Definition: {
                            { aBlk |  exists(prd | GsAvailable(aBlk, prd))
                            		and ForAll(prd | GsAvailable(aBlk, prd)
                            		, Atmost (aDest | (aBlk,aDest,prd) in TimePermittedRoutesForProducts
                            !				and [ ord(DestSupplyZones(aDest, aBlk),SupplyZones) <= ord(__LowCost,SupplyZones)  ]
                            				and [  SupplyZones_Xref(__ZLowCost , DestSupplyZones(adest,ablk)) ]
                            				,1)
                            			and ForAll(aDest | (aBlk,aDest,prd) in TimePermittedRoutesForProducts
                            !				and [ ord(DestSupplyZones(aDest, aBlk),SupplyZones) <= ord(__LowCost,SupplyZones)  ]
                            				and [  SupplyZones_Xref(__ZLowCost , DestSupplyZones(adest,ablk)) ]
                            				,
                            				not [ exists(aDest1 | aDest1 <> aDest and (aBlk,aDest1,prd) in TimePermittedRoutesForProducts
                            !										and ord(DestSupplyZones(aDest1, aBlk),SupplyZones) <= ord(__LowCost, SupplyZones) )]
                            										and [  SupplyZones_Xref(__ZLowCost , DestSupplyZones(aDest1,aBlk)) ]) ]
                            				)
                            		)
                            }
                        }
                        Comment: {
                            "{ aBlk | ForAll(prd | GsAvailable(aBlk, prd)
                            		, Atmost (dest | (aBlk,dest,prd) in TimePermittedRoutesForProducts
                            				and DestSupplyZones(dest, aBlk) <= __LowLim
                            				 , 1 ) )
                            }"
                        }
                    }
                    Set testzone {
                        SubsetOf: SupplyZones;
                        Property: NoSave;
                        Definition: {
                            { zone | zone <= __LowLIm }
                        }
                    }
                    Parameter SelectedProducts {
                        IndexDomain: (prd);
                        Range: binary;
                        Unit: 1;
                        Default: 1;
                        Property: NoSave;
                    }
                    Parameter GUISelectedProducts {
                        IndexDomain: (prd);
                        Range: binary;
                        Unit: 1;
                        Default: 1;
                        Property: NoSave;
                    }
                    Parameter NumberMillsByZone {
                        IndexDomain: (ablk,mzone);
                        Text: "Number of included mills for which blk_s is in mzone";
                        Property: NoSave;
                        Definition: {
                            
                            count[ adest |
                            	(SupplyZones_Xref(mzone , DestSupplyZones(adest, ablk) )  )
                            	and exists( prd | TimePermittedRoutesForProducts(ablk,adest,prd)
                                 				and SelectedProducts(prd) )
                            
                            	]
                        }
                    }
                    Parameter NumberCompetingMills {
                        IndexDomain: (blk);
                        Unit: 1;
                        Property: NoSave;
                        Definition: {
                            !as proportion of total demand
                            !sum[(dest1,PrGrp) | cPrG(PrGrp, prd),MillDemand_PrGrp_AllTerms(dest1, PrGrp)] /$ GsAvailable(blk_GUI , prd)
                            
                            ! as number of competing facilities
                            sum[mzone | mzone <= _mzone , NumberMillsByZone(Blk, mzone) ]
                            
                            !
                            !count(aDest | DestSupplyZones(adest,blk)
                            !and SupplyZones_Lkp(DestSupplyZones(adest,blk)) <= _mzone
                            !and (exists( prd | AvailableRoutesForProducts(blk,adest,prd)
                            !     and SelectedProducts(prd)) )
                            !)
                        }
                    }
                }
                Procedure ResetCompetitionSelectors {
                    Body: {
                        empty  _dest_s, Current_blk;
                        ZoomToExtent_AccessibleVolume;
                    }
                }
                Procedure ProductsSelector_Open {
                    Body: {
                        !SetLastViewedChildPage;
                        
                        GUISelectedProducts(prd) := SelectedProducts(prd);
                    }
                }
                Procedure ProductsSelector_Close {
                    Body: {
                        SelectedProducts(prd) := GUISelectedProducts(prd);
                    }
                }
                Section Histogram_Section {
                    Set Moments {
                        Index: mm;
                        Property: NoSave;
                        Definition: data { Average, Deviation, Skewness, Kurtosis };
                    }
                }
            }
            Section GUI_Prodecures {
                Procedure ClearTargets {
                    Body: {
                            empty UsesProducts,UsesResiduals ;
                        
                            empty ProductsUsed_PrGrp;
                        
                            empty ProducesResiduals;
                        
                            empty ResidualsProduced;
                        
                            empty ResidualsUsed_PrGrp;
                        
                        empty MillDemand,MillDemand_PrGrp,MillResidualDemand_PrGrp;
                        
                        empty EquivalentProducts;
                    }
                }
                Procedure AssignMinimumUnencumbranceValues;
                Procedure EditWhatsNew {
                    Body: {
                        FileEdit(WhatsNewFilename);
                    }
                }
                Procedure AddMU;
                Procedure AddElementFunction {
                    Arguments: (ArgumentSet,NewName);
                    Body: {
                        ArgumentElement := StringToElement(ArgumentSet,NewName);
                        If ArgumentElement then
                                DialogMessage(FormatString("This element is already in the set: %s", SetName));
                                return -1;
                        Else
                                SetElementAdd(ArgumentSet,ArgumentElement,NewName);
                                cleandependents ArgumentSet;
                                return 1;
                        EndIf;
                    }
                    Set ArgumentSet {
                        Index: arg;
                        Property: InOut;
                    }
                    StringParameter NewName {
                        Property: Input;
                    }
                    ElementParameter ArgumentElement {
                        Range: ArgumentSet;
                    }
                }
                Procedure DeleteElementFunction {
                    Arguments: (ArgumentSet,ArgumentElement);
                    Body: {
                        If not ArgumentElement then
                            DialogMessage("No element Selected.");
                            return -1;
                        endif;
                        !DebuggerBreakpoint;
                        !--- if ArgumentSet is a subset, delete element from the root set
                        if ArgumentSet = Blocks or ArgumentSet = Destinations then
                                AllLocations -= ElementCast(AllLocations, ArgumentElement,0);
                                cleandependents AllLocations;
                        elseif ArgumentSet =  Products or ArgumentSet = Residuals then
                                AllProducts -= ElementCast(AllProducts, ArgumentElement,0);
                                cleandependents AllProducts;
                        elseif ArgumentSet = ProductGroups or ArgumentSet = ResidualGroups then
                        		AllProductGroups -= ElementCast(AllProductGroups, ArgumentElement,0);
                        		cleandependents AllProductGroups;
                        else
                                ArgumentSet -= ArgumentElement;
                                cleandependents ArgumentSet;
                        endif;
                        
                        ! cleandependents AllLocations,AllProducts,AllProductGroups;
                        return 1;
                    }
                    Set ArgumentSet {
                        Index: arg;
                        Property: InOut;
                    }
                    StringParameter NewName;
                    ElementParameter ArgumentElement {
                        Range: ArgumentSet;
                        Property: Input;
                    }
                }
                Procedure AddSetMember {
                    Body: {
                        !DialogMessage(
                        !       FormatString("(2 <= StringLength(NewElementName) <= 8) returns: '%n'",(2 <= StringLength(NewElementName) <= 8))
                        !       ,"");
                        if (2 <= StringLength(NewElementName) <= 8) <> 1 then
                                DialogMessage("The length of the element should be between 2 and 8 characters");
                                return -1;
                        endif;
                        ! warning: Apr 2010 - AddElementFunction: Must also add to root sets (AIMMS bug)
                        
                        if SetName = "Blocks" then
                        	AddElementFunction(Blocks,NewElementName);
                        	AddElementFunction(AllLocations,NewElementName);
                        ElseIf SetName = "Management Units" then
                        	AddElementFunction(ManagementUnits,NewElementName);
                        ElseIf SetName = "Destinations" then
                        	AddElementFunction(Destinations,NewElementName);
                        	AddElementFunction(AllLocations,NewElementName);
                        
                        ElseIf SetName = "CostCentres" then
                        	AddElementFunction(CostCentres,NewElementName);
                        
                        !--- For products, also modify cPrG(product,ProductGroup) association
                        ElseIf SetName = "Products" then
                        	AddElementFunction(Products,NewElementName);
                        	AddElementFunction(AllProducts,NewElementName);
                        
                        	! products must also be added to Product Groups
                        	AddElementFunction(ProductGroups,NewElementName);
                        	AddElementFunction(AllProductGroups,NewElementName);
                        	cPrG((gPrGrp,gpr) | FormatString("%e",gprgrp) = FormatString("%s",NewElementName)
                        						and FormatString("%e",gpr) = FormatString("%s",NewElementName)
                        						) := 1;
                        
                        ElseIf SetName = "Residuals" then
                        	AddElementFunction(Residuals,NewElementName);
                        	AddElementFunction(AllProducts,NewElementName);
                        	! products must also be added to Product Groups
                        	AddElementFunction(ResidualGroups,NewElementName);
                        	AddElementFunction(AllProductGroups,NewElementName);
                        	cPrG((gPrGrp,gpr) | FormatString("%e",gprgrp) = FormatString("%s",NewElementName)
                        						and FormatString("%e",gpr) = FormatString("%s",NewElementName)
                        						) := 1;
                        
                        Elseif Setname = "ProductGroups" then
                        	switch c_ProductGroupType do
                        	'Products': 	AddElementFunction(ProductGroups,NewElementName);
                        	'Residuals' , 'Both':
                        			SetName := "ResidualGroups";
                        			AddElementFunction(ResidualGroups,NewElementName);
                        	default:	DialogError(FormatString("Unknown element '%e'",c_ProductGroupType),"Internal Error");
                        				halt;
                        	endswitch;
                        	AddElementFunction(AllProductGroups,NewElementName);
                        	cPrG((gPrGrp,gpr) | FormatString("%e",gprgrp) = FormatString("%s",NewElementName)
                        						and FormatString("%e",gpr) = FormatString("%s",NewElementName)
                        						) := 1;
                        
                        ElseIf SetName = "Sectors" then
                        	AddElementFunction(Sectors,NewElementName);
                        else
                                DialogError("No action defined for the set '" + SetName + "'","Error");
                        endif;
                        
                        s := FormatString("'%s' has been added to the set: %s \n\n",NewElementName,SetName);
                        if setname = "Products" or SetName = "Residuals" then
                        	s += FormatString("'%s' has also been added to product and residual groups\n\nPlease check product/group relation",NewElementName);
                        endif;
                        
                        DialogMessage(s,"New Element Added");
                        
                        return 1;
                    }
                    StringParameter s;
                }
                Procedure DeleteSetMember {
                    Body: {
                        !DebuggerBreakpoint;
                        if SetName = "Blocks" then
                                !DummySet_ElementsToDelete := blocks;
                                Current_blk := ElementCast(Blocks,Current_etd,0);
                                DeleteElementFunction(Blocks,Current_blk)
                        ElseIf SetName = "Management Units" then
                                Current_mu := ElementCast(ManagementUnits,Current_etd,0);
                                DeleteElementFunction(ManagementUnits,Current_mu)
                        ElseIf SetName = "Destinations" then
                                Current_dest := ElementCast(Destinations,Current_etd,0);
                                DeleteElementFunction(Destinations,Current_dest)
                        ElseIf SetName = "CostCentres" then
                        		_Cost := ElementCast(CostCentres, Current_etd,0);
                        		DeleteElementFunction(CostCentres,_Cost)
                        ElseIf SetName = "Products" then
                                Current_prd := ElementCast(Products,Current_etd,0);
                        
                        ElseIf SetName = "Residuals" then
                                Current_res := ElementCast(Residuals,Current_etd,0);
                                DeleteElementFunction(Residuals,Current_res)
                        ElseIf SetName = "Sectors" then
                                _Sect := ElementCast(Sectors,Current_etd,0);
                                DeleteElementFunction(Sectors,_Sect)
                        ElseIf SetName = "ProductGroups" then
                                ! Don't allow deletion of singleton Product Groups
                                if (ElementCast(ProductGroupsSingle,Current_etd,0) <> '') or (ElementCast(ResidualGroupsSingle,Current_etd,0) <> '')  then
                                	DialogError(FormatString("%e represents a single product/residual and cannot be deleted",Current_etd),"Can't delete element");
                                	return 0;
                                endif;
                        
                        
                                _gPrGrp := ElementCast(AllProductGroups,Current_etd,0);
                        
                                ! OK to delete
                                DeleteElementFunction(AllProductGroups,_gPrGrp)else
                                DialogError("No action defined for the set '" + setname + "'","Error");
                        endif;
                    }
                }
                Procedure InitializeElementsToDelete {
                    Body: {
                        !DebuggerBreakpoint;
                        if SetName = "Blocks" then
                                SetCopyElements(blocks,DummySet_ElementsToDelete);
                        ElseIf SetName = "Management Units" then
                                SetCopyElements(ManagementUnits,DummySet_ElementsToDelete);
                        ElseIf SetName = "Destinations" then
                                SetCopyElements(Destinations,DummySet_ElementsToDelete);
                        ElseIf SetName = "CostCentres" then
                                SetCopyElements(CostCentres,DummySet_ElementsToDelete);
                        ElseIf SetName = "Products" then
                                SetCopyElements(Products,DummySet_ElementsToDelete);
                        ElseIf SetName = "Residuals" then
                                SetCopyElements(Residuals,DummySet_ElementsToDelete);
                        ElseIf SetName = "ProductGroups" then
                                SetCopyElements(AllProductGroups,DummySet_ElementsToDelete);
                                !remove singleton productGroups and Residualgroups
                                SetRemoveElements(ProductGroupsSingle  ,	DummySet_ElementsToDelete );
                                SetRemoveElements(ResidualGroupsSingle  ,	DummySet_ElementsToDelete );
                        ElseIf SetName = "Sectors" then
                                SetCopyElements(Sectors,DummySet_ElementsToDelete);
                        else
                                DialogError("No action defined for the set '" + setname + "'","Error");
                        endif;
                    }
                }
                Procedure SetCopyElements {
                    Arguments: (fromSet,ToSet);
                    Body: {
                        !DebuggerBreakpoint;
                        empty toset;
                        for (iset in fromSet) do
                                current_iset := iset;
                                ArgumentElement := ElementCast(toset, current_iset,0);
                                SetElementAdd(ToSet, ArgumentElement, iset);
                                !SetElementAdd(ToSet, ArgumentElement, FormatString("%e",iset));
                        
                        endfor;
                    }
                    Set FromAndToSet;
                    Set fromSet {
                        SubsetOf: FromAndToSet;
                        Index: iSet;
                        Parameter: Current_iset;
                        Property: Input;
                    }
                    Set ToSet {
                        SubsetOf: FromAndToSet;
                        Index: jSet;
                        Parameter: Current_ToSet;
                        Property: InOut;
                    }
                    ElementParameter ArgumentElement {
                        Range: ToSet;
                    }
                }
                Procedure SetRemoveElements {
                    Arguments: (ElementsToRemove,SetToModify);
                    Body: {
                        
                        !  Warning: SetRemoveElements is not working
                        for (iset in ElementsToRemove) do
                                current_iset := iset;
                                !ArgumentElement := ElementCast(SetToModify, current_iset,0);
                                Current_ToSet := ElementCast(SetToModify, current_iset,0);
                                if Current_ToSet <> '' then
                                	SetToModify -= Current_ToSet; endif;
                                !SetElementAdd(SetToModify, ArgumentElement, iset);
                                !SetElementAdd(ToSet, ArgumentElement, FormatString("%e",iset));
                        
                        endfor;
                    }
                    Set FromAndToSet;
                    Set ElementsToRemove {
                        SubsetOf: FromAndToSet;
                        Index: iSet;
                        Parameter: Current_iset;
                        Property: Input;
                    }
                    Set SetToModify {
                        SubsetOf: FromAndToSet;
                        Index: jSet;
                        Parameter: Current_ToSet;
                        Property: InOut;
                    }
                    ElementParameter ArgumentElement {
                        Range: SetToModify;
                    }
                }
                Procedure DuplicateDataFunction {
                    Arguments: (ParameterName,FromTuple,ToTuple);
                    Set FromTuple {
                        Index: fr;
                        Property: Input;
                    }
                    Set ToTuple {
                        Property: Input;
                    }
                    ElementParameter ParameterName {
                        Range: AllParameters;
                        Property: InOut;
                    }
                }
                Procedure SetThresholdViolationPenalties {
                    Body: {
                        if IsSelected(__ThresholdPenalties) then
                        ViolationPenalty_NEW(ivp | ivp in ThresholdVariablesConstraints) :=
                        	ThresholdPenalties(__thrLow) $ FindString( FormatString("%e",ivp),"_Low")
                        	+ThresholdPenalties(__thrMod) $ FindString( FormatString("%e",ivp),"_Mod")
                        	+ThresholdPenalties(__thrSig) $ FindString( FormatString("%e",ivp),"_Sig")
                        	+ThresholdPenalties(__thrHigh) $ FindString( FormatString("%e",ivp),"_High")
                        	;
                        endif;
                    }
                }
                Procedure InitializeAddElementPage {
                    Body: {
                        empty c_ProductGroupType;
                    }
                }
                Procedure EditHelpFile {
                    Body: {
                        ! open the help application
                        ! if developer, ask to edit/view help
                        
                        
                        if IsAuthorized('Develop') then
                        	switch (DialogAsk("What do you wish to do"
                        			,button1: "View Help"
                        			,button2: "Edit Help"
                        			,button3: "Cancel"
                        			,title: "Enter Option") ) do
                        	1: 	HelpFileName := "Help\\MarketFlow_Help.chm";
                        	2:	HelpFileName := "Help\\MarketFlow_Help.hnd";
                        	3:  return 0;
                        	endswitch;
                        else
                        	HelpFileName := "Help\\MarketFlow_Help.chm";
                        endif;
                        
                        if FileExists(HelpFileName) then
                        	OpenDocument(HelpFileName);
                        	return 1;
                        else
                        	DialogError("File not found: " + HelpFileName, "File Not Found");
                        	return 0;
                        endif;
                    }
                    StringParameter HelpFileName;
                }
                Function GetPTBackgroundColour {
                    Arguments: (TagName);
                    Range: AllColors;
                    Body: {
                        !if StringToElement(PTStateManager::AllTags,TagName,0) = '' then
                        	GetPTBackgroundColour := 'default background';
                        !else
                        	!GetPTBackgroundColour := 'PTState Background'
                        !endif;
                    }
                    Comment: {
                        "used for PivotTable, General, Background Color to expression (GetPTBackgroundColour(tag) where
                        tag is the tag of the pivot table"
                    }
                    StringParameter TagName {
                        Property: Input;
                    }
                }
                Procedure RandomizeMillNames {
                    Body: {
                        !-- Confirm action
                        !if Card(Destinations) = 0 then
                        !	DialogError("Your model has no destinations.\n\nPlease load a case.","No Destinations");
                        !	return 0;
                        !endif;
                        !if DialogAsk("Do you wish to give mills random names?","Yes","No","Cancel","Confirm Action") <> 1 then return 0; endif;
                        
                        if IsNotAuthorized(__AMillNames) then
                        	RandomizeMillNames_wrk;
                        endif;
                    }
                }
                Procedure RandomizeMillNames_wrk {
                    Body: {
                        
                        !Remove any mills that use neither products nor residuals
                        
                        AllLocations -= { dest | not dest in Destinations_Valid };
                        cleandependents AllLocations;
                        
                        i := 1;
                        n := card(Destinations);
                        empty Millnum;
                        
                        while (i <= n) do
                        !for dest in destinations do
                        	_mill := Element(Destinations,i);
                        	!_mill := dest;
                        	if _mill = '' then
                        		DialogError("Element " + i + " Not found");
                        		return 0;
                        	endif;
                        
                        	!use StringToElement to avoid explicit element ... can't use SetElementRename
                        	!if _mill = StringToElement(Destinations,"HokumCh") then DebuggerBreakpoint; endif;
                        
                        	MillName := FormatString("%e", _mill);
                        
                        	j := FindNthString( MillName,"_",-1); !Find last _
                        	if j then Ending := SubString(MillName,j,500); else ending := ""; endif;
                        
                        	_sect := MillSector(_mill);
                        	Millnum(_sect) += 1;
                        	MillName := FormatString("%e", _sect);
                        	MillName := SubString(MillName,1,4) + FormatString("%03i",Millnum(_sect)) + Ending ;
                        
                        	_loc := ElementCast(AllLocations,_mill,0);
                        	if StringToElement(AllLocations,millname,0) = '' then
                        		SetElementRename(AllLocations,_loc,Millname);
                        		!SetElementRename(Destinations,_mill,MillName); !destinations_sorted
                        	endif;
                        	i += 1;
                        endwhile;
                        !endfor;
                    }
                    StringParameter MillName;
                    ElementParameter i {
                        Range: Integers;
                    }
                    Parameter j;
                    Parameter n;
                    ElementParameter _mill {
                        Range: Destinations;
                    }
                    StringParameter Ending;
                    Parameter Millnum {
                        IndexDomain: (sect);
                    }
                }
                Procedure RandomizeDemand {
                    Body: {
                        
                        
                        for (dest ) do
                        	RandNum := uniform(0.5 ,1.0) ;
                        
                        	MillDemand(dest, gpr, tt, tp ) 	*= RandNum;
                        	DeliveredVolume(term, blk, dest, prd) *= RandNum;
                        	DeliveredAllVolume_PrGrp(term, aDest, gPrGrp) *= RandNum;
                        	DeliveredTotalVolume(term, src, dest, gProd)  *= RandNum;
                        	ProcessedVolume(term, aDest, gpr) *= RandNum;
                        	ResidualVolumeProduced(term, dest, res) *= RandNum;
                        	DeliveredResidualVolume(term, destFrom, DestTo, res) *= RandNum;
                        	DeliveredResidualVolume_PrGrp(term, DestTo, ResGrp) *= RandNum;
                        endfor;
                    }
                    Parameter RandNum;
                }
                DeclarationSection Advance_Identifiers {
                    ElementParameter IDtoAdvance {
                        Range: AllIdentifiers;
                        Property: NoSave;
                        Comment: "Identifier to advance ... used in GUI with arrow keys";
                    }
                }
                Procedure IdentifierNext {
                    Body: {
                        if IDtoAdvance = '' then return 0; endif;
                        
                        switch IDtoAdvance do
                        '_destTemp':	_DestTemp += 1;
                        '_EndBlock':	_EndBlock += 1;
                        
                        '_bmo': !Primary Map
                        	switch (_bmo) do
                        		'Block':	_musrc		+= 1;
                        		'MU':		_mu_s		+= 1;
                        		'Mill':		_MillToMap	+= 1;
                        	endswitch;
                        
                        'c_MapSrcMu':	c_MapSrcMu 	+= 1;
                        '_MillToMap':	_MillToMap	+= 1;
                        
                        endswitch;
                        
                        empty _blk_GUI, Current_blk;
                    }
                }
                Procedure IdentifierPrevious {
                    Body: {
                        if IDtoAdvance = '' then return 0; endif;
                        
                        switch IDtoAdvance do
                        '_destTemp':	_DestTemp -= 1;
                        '_EndBlock':	_EndBlock -= 1;
                        '_bmo': !Primary Map
                        	switch (_bmo) do
                        		'Block':	_musrc		-= 1;
                        		'MU':		_mu_s		-= 1;
                        		'Mill':		_MillToMap	-= 1;
                        	endswitch;
                        
                        'c_MapSrcMu':	c_MapSrcMu 	-= 1;
                        '_MillToMap':	_MillToMap	-= 1;
                        
                        endswitch;
                        
                        empty _blk_GUI, Current_blk;
                    }
                }
            }
            DeclarationSection HIDE_and_SHOW_Parameters {
                Parameter UsesProductsHIDE {
                    IndexDomain: (dest);
                    Range: binary;
                    Property: NoSave;
                    Definition: not UsesProducts(dest);
                }
                Parameter UsesResidualsHIDE {
                    IndexDomain: (dest);
                    Range: binary;
                    Property: NoSave;
                    Definition: not UsesResiduals(dest);
                }
                Parameter ProducesResidualsHIDE {
                    IndexDomain: (dest);
                    Property: NoSave;
                    Definition: not ProducesResiduals(dest);
                }
                Parameter MillDemandPivotTableHIDE {
                    Range: binary;
                    Property: NoSave;
                }
                Parameter MillDemandPivotTableSHOW {
                    Range: binary;
                    Property: NoSave;
                    Definition: not MillDemandPivotTableHIDE;
                }
                Parameter MUsPerBlockPROBLEM {
                    Range: binary;
                    Definition: if sum(blk | sum(mu,MU_Block_Relation(mu,blk)) <> 1 ,1) then 1 else 0 endif;
                }
                Parameter FeasibleDestinationsHIDE {
                    Range: binary;
                    Definition: IsSelected('Hide Feasible Targets');
                }
                Parameter HideInfeasibilities {
                    Range: binary;
                    Property: NoSave;
                    Definition: if NumberOfInfeasibilities > 0 then 0 else 1 endif;
                }
                Parameter HideTrees {
                    Range: binary;
                    Definition: if   IsSelected(_SimulateTREES) then 0 else 1 endif;
                }
                Parameter HideMillDemand {
                    Range: binary;
                    Definition: if   IsSelected(__MeetVolumeTargets) then 0 else 1 endif;
                }
                Parameter HideTREESInfeasibilities {
                    Range: binary;
                    Definition: {
                        if [ HideTrees = 0] and
                        [
                        (count((term,mu,dest,prd) | MeetTreesFlow_lower.Violation(term,mu,dest,prd)))
                        +
                        (count((term,mu,dest,prd) | MeetTreesFlow_upper.Violation(term,mu,dest,prd)))
                        +
                        (count((term,dest,prd) | MeetTreesTotalFlow_lower.Violation(term,dest,prd)))
                        +
                        (count((term,dest,prd) | MeetTreesTotalFlow_upper.Violation(term,dest,prd)))
                        ] > 0 then 0 else 1 endif
                    }
                }
                Parameter MillDemandViolationDOMAIN {
                    IndexDomain: {
                        (dest,gPrGrp,tt,tp) | if FeasibleDestinationsHIDE then (
                        sum(term,MeetMillAllDemandPrGrp_Lower.violation(term,dest,gPrGrp,tt,tp))
                        + sum(term,MeetMillAllDemandPrGrp_Lower.Violation(term,dest,gPrGrp,tt,tp))
                        )
                        else MillAllDemand_PrGrp(dest,gPrGrp,tt,tp)
                        endif
                    }
                    Definition: 1;
                }
                Parameter TreesFlowViolationDOMAIN {
                    IndexDomain: {
                        (term,mu,dest,prd) | if FeasibleDestinationsHIDE then
                        MeetTreesFlow_lower.Violation(term,mu,dest,prd) !+ MeetTreesFlow_upper.Violation(term,mu,dest,prd)
                        else TreesFlow(term,mu,dest,prd,__min)
                        endif
                    }
                    Definition: 1;
                }
                Parameter TreesTotalFlowViolationDOMAIN {
                    IndexDomain: {
                        (term,dest,prd) | if FeasibleDestinationsHIDE then
                        MeetTreesTotalFlow_lower.Violation(term,dest,prd) !+ MeetTreesTotalFlow_upper.Violation(term,dest,prd)
                        else TreesTotalFlow(term,dest,prd,__min)
                        endif
                    }
                    Definition: 1;
                }
                Parameter MIPWarningHIDE {
                    Range: binary;
                    Definition: if IsSelected(__BinaryMills) = 1  then 0 else 1 endif;
                }
                Parameter ShowDifferencesOnly {
                    Text: "Show differences only";
                    Range: binary;
                    Property: NoSave;
                    Comment: "dk: Feb 2010 Show differences only  ... for Pivot Tables";
                }
                Parameter HIDETreesPages {
                    Range: binary;
                    Definition: if IsSelected( _SimulateTREES) then 0 else 1 endif;
                }
                Parameter HideAvailableGsFactor {
                    Range: binary;
                    Property: NoSave;
                    Definition: {
                        if IsSelected(__IncludeOnlyAvailableBlocks) and IsSelected(__ScaleUpAvailableGs)
                        then 0 else 1 endif
                    }
                }
            }
            Parameter num_Decimals {
                Range: {
                    {0..3}
                }
                Default: 0;
                Property: NoSave;
            }
            Parameter num_ShowComma {
                Default: 1;
                Property: NoSave;
            }
            Set AutoResolvePages {
                Property: NoSave;
            }
            Set ProductGroupTypes {
                Parameter: c_ProductGroupType;
                Property: NoSave;
                Definition: data { Products, Residuals, Both };
            }
            Parameter HIDE_MillDemandWithoutSupply {
                Range: binary;
                Property: NoSave;
                Definition: if sum((PrGrp,dest),MillDemandWithoutSupply(PrGrp,dest)) then 0 else 1 endif;
            }
            Parameter HIDE_ProductGroupType {
                Range: binary;
                Property: NoSave;
                Definition: if SetName = "ProductGroups" then 0 else 1 endif;
            }
            Parameter HIDE_AddButton {
                Range: binary;
                Property: NoSave;
                Definition: {
                    if SetName = "ProductGroups" then
                    	if	 StringLength(NewElementName) < 1 and c_ProductGroupType = ''  then 1 else 0 endif
                    elseif StringLength(NewElementName) < 1 then
                    	1
                    else 0
                    endif
                }
            }
            Set SetsToAddDeleteElements {
                SubsetOf: AllSets;
                Index: sta;
                Parameter: CurrentSet;
                Definition: {
                    data {
                    ManagementUnits,        Blocks,         Destinations, Products, Residuals, Sectors
                    }
                }
            }
            Set DummySet_ElementsToDelete {
                Text: "Contains elements from a set available for deletion";
                Index: etd;
                Parameter: Current_etd;
            }
            StringParameter WhatsNewFilename {
                Property: NoSave;
                Definition: "<prj>:Whats New\\Beta 2b";
            }
            StringParameter ActivePageTagName {
                Property: NoSave;
            }
            StringParameter ActivePageName {
                Default: "";
                Property: NoSave;
            }
            StringParameter SetName {
                Property: NoSave;
            }
            StringParameter NewElementName;
            Assertion AssertElementName {
                Text: "The length of the element should be between 2 and 8 characters";
                Definition: (2 <= StringLength(NewElementName) <= 8);
            }
            Section ResultsGUI {
                ElementParameter InfeasibleColour {
                    IndexDomain: ( dest, gPrGrp, tp ) | MillAllDemand_PrGrp( dest, gPrGrp, __min, tp );
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        if not MeetMillAllDemandPrGrp_Lower_Violation( dest, gPrGrp, tp ) then 'white'
                        elseif -1 * MeetMillAllDemandPrGrp_Lower_Violation( dest, gPrGrp, tp ) /$ MillAllDemand_PrGrp( dest, gPrGrp, __min, tp ) >= 0.75 then 'Q4'
                        elseif -1 * MeetMillAllDemandPrGrp_Lower_Violation( dest, gPrGrp, tp ) /$ MillAllDemand_PrGrp( dest, gPrGrp, __min, tp ) >= 0.5 then 'Q3'
                        elseif -1 * MeetMillAllDemandPrGrp_Lower_Violation( dest, gPrGrp, tp ) /$ MillAllDemand_PrGrp( dest, gPrGrp, __min, tp ) >= 0.25 then 'Q2'
                         else 'Q1'
                        endif
                    }
                }
                ElementParameter TREESInfeasibleColour {
                    IndexDomain: (  term, dest, prd ) |TreesTotalFlow( term, dest, prd, __min );
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        if IsSelected(__SimulateTREESByMU) then
                        	if DeliveredVolume_Dest( term, dest, prd ) = TreesTotalFlow( term, dest, prd, __min ) >= 0.75 then 'white'
                        	elseif DeliveredVolume_Dest( term, dest, prd ) /$ TreesTotalFlow( term, dest, prd, __min ) >= 0.75 then 'Q1'
                        	elseif DeliveredVolume_Dest( term, dest, prd ) /$ TreesTotalFlow( term, dest, prd, __min ) >= 0.5 then 'Q2'
                        	elseif DeliveredVolume_Dest( term, dest, prd ) /$ TreesTotalFlow( term, dest, prd, __min ) >= 0.25 then 'Q3'
                        	else 'Q4'
                        	endif
                        endif
                    }
                }
                ElementParameter TreesMUInfeasibleColour {
                    IndexDomain: (  term, mu, dest, prd ) |TreesFlow( term, mu, dest, prd, __min );
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        if MeetTreesFlow_lower.Violation(term, mu, dest, prd) then
                        	if - MeetTreesFlow_lower.Violation(term, mu, dest, prd) /$ TreesFlow( term, mu, dest, prd, __min ) >= 0.75 then 'Q4'
                        	elseif - MeetTreesFlow_lower.Violation(term, mu, dest, prd) /$ TreesFlow( term, mu, dest, prd, __min ) >= 0.5 then 'Q3'
                        	elseif - MeetTreesFlow_lower.Violation(term, mu, dest, prd) /$ TreesFlow( term, mu, dest, prd, __min ) >= 0.25 then 'Q2'
                        	else 'Q1'
                        	endif
                        endif
                    }
                }
                Parameter FlagOverDeliveryFactor {
                    Text: "Delivery exceeding Demand by Factor";
                    Range: [1, 100];
                    Unit: 1;
                    Default: 1.5;
                    Property: NoSave;
                }
                Parameter Delivery_DOM {
                    IndexDomain: (dest,gPrGrp) | IncludeMill(dest)  and  gPrGrp in ProductsAllUsed_PrGrp(dest);
                    Default: 1;
                    Property: NoSave;
                }
                ElementParameter DeliveryColour {
                    IndexDomain: (dest,gPrGrp,term) | Delivery_DOM(dest, gPrGrp);
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        if DeliveredVolume_term( dest, gPrGrp, term ) < MillDemand_term(dest,gPrGrp,term) then 'red'
                        elseif MillDemandMax_term(dest,gPrGrp,term)
                          and [DeliveredVolume_term( dest, gPrGrp, term ) > MillDemandMax_term(dest,gPrGrp,term) ] then 'corresponding'
                        elseif MillDemand_term(dest,gPrGrp,term)
                          and DeliveredVolume_term( dest, gPrGrp, term ) >   MillDemand_term(dest,gPrGrp,term) * FlagOverDeliveryFactor  then 'cyan'
                        endif
                    }
                }
            }
            Section ToolTip_Related {
                Procedure GetPageNames {
                    Body: {
                        !retrieves all Child pages for "Main Page"
                        empty PageNames;
                        
                        
                        PageGetChild( "Main Page",CurPage,0);
                        repeat
                        	!-- add page name to set PageNames
                        	AddElementFunction(PageNames,CurPage);
                        
                        	!-- quit when no Next Page found
                        	break when (PageGetNext(CurPage,NextPage,0) = 0);
                        	!break when (PageGetNextInTreeWalk(CurPage,NextPage,0) = 0);
                        	CurPage := NextPage;
                        endrepeat;
                    }
                    StringParameter CurPage;
                    StringParameter NextPage;
                    Parameter i {
                        Range: binary;
                    }
                }
                Procedure WriteTooltips {
                    Body: {
                        write ToolTip to file "<prj>:Tooltips.txt";
                    }
                }
                Procedure ReadTooltips {
                    Body: {
                        read ToolTip from file "<prj>:Tooltips.txt";
                    }
                }
                DeclarationSection Tooltips_and_Tabbed_Page_Declarations {
                    Set PageNames {
                        Index: ipage;
                        Parameter: _CurrentPage;
                        Property: NoSave;
                        Comment: "Populated by GetPageNames";
                    }
                    Set TagNames {
                        Index: iTag;
                        Parameter: _CurrentTag;
                        Property: NoSave;
                        Definition: {
                            !data{
                            !Overview		, 'General Data'		, 'Supply'		,Mills		,Costs		,'QA Exec'
                            !,Results		,Candy					, 'Whats New'
                            !}
                        }
                    }
                    StringParameter ToolTip {
                        IndexDomain: (iPage,iTag);
                        Property: NoSave;
                    }
                    StringParameter TabbedPage {
                        IndexDomain: (iPage);
                        Property: NoSave;
                    }
                    StringParameter CurrentTabbedPage {
                        Property: NoSave;
                    }
                    Macro ToolTipFormat {
                        Arguments: DisplayValue,DisplayUnit;
                        Definition: {
                            !Warning: Unit conversion problem in Tooltip
                            FormatString("%t.3n %u",DisplayValue [DisplayUnit],DisplayUnit)
                        }
                    }
                }
            }
            Section Residuals_Wizard_Section {
                Set WizardOptions {
                    Index: wo;
                    Property: NoSave;
                    Definition: {
                        data {
                        ResProducersProduct	,	ResProducersSector	,	ResUsersSector
                        }
                    }
                }
                ElementParameter _WizResProducersProduct {
                    Range: WizardOptions;
                    Property: NoSave;
                    Definition: 'ResProducersProduct';
                }
                ElementParameter _WizResProducersSector {
                    Range: WizardOptions;
                    Property: NoSave;
                    Definition: 'ResProducersSector';
                }
                ElementParameter _WizResUsersSector {
                    Range: WizardOptions;
                    Property: NoSave;
                    Definition: 'ResUsersSector';
                }
                StringParameter WizardOptions_txt {
                    IndexDomain: wo;
                    Property: NoSave;
                    Definition: {
                        data {
                        	'ResProducersProduct'	:	"Define residual PRODUCERS by product used"
                        ,	'ResProducersSector'	:	"Define residual PRODUCERS by sector"
                        ,	'ResUsersSector'	:	"Define residual USERS by sector"
                        }
                    }
                }
                Procedure Residuals_Wizard {
                    Body: {
                        /* wizard to identify mills that produce residuals (use specified product group),
                          * 2. Identify residuals produced
                          * 3. input conversion factor
                           */
                        block !validation
                           if count(res) < 1 then
                           	DialogError("You must first specify residual products.","Residual Wizard Error");
                           	return -1;
                           endif;
                        endblock;
                        
                        block !Which WIZARD To use: residuals by product or residuals by sector
                        	s := "This wizard will help you identify mills that use produce residuals, the residual(s) produced, and the conversion factor(s)";
                        	s += FormatString("\n\nWhat do you wish to do:\n\n1. Define residuals for a sector, or\n\n2. Define residuals for mills using a certain product?");
                        	!switch (DialogAsk(s,button1: "1", button2:"2",button3:"Cancel",title:"Define Residuals Wizard")) do
                        	if DialogGetElementByText("Select Option",c_wo,WizardOptions_txt) = 0 then return 0; endif;
                        	switch (c_wo) do
                        		'ResProducersSector':
                        			! *********************************************
                        			! * --- PRODUCES RESIDUALS BY SECTOR WIZARD ----
                        			! *********************************************
                        			ProducesResiduals_Wizard_BySector_wrk;
                        
                        		'ResProducersProduct':
                        			  ! *********************************************
                        			! * --- PRODUCES RESIDUALS BY PRODUCT WIZARD ----
                        			! *********************************************
                        			ProducesResiduals_Wizard_ByProduct_wrk;
                        
                        		'ResUsersSector':
                        			  ! *********************************************
                        			! * --- USES RESIDUALS BY SECTOR WIZARD ----
                        			! *********************************************
                        			UsesResiduals_Wizard_BySector_wrk;
                        
                        		default: ! ==========================================================
                        			return 0;
                        	endswitch;
                        endblock;
                    }
                    StringParameter s;
                    ElementParameter c_wo {
                        Range: WizardOptions;
                    }
                }
                Procedure ProducesResiduals_Wizard_ByProduct_wrk {
                    Body: {
                        block ! --- RESIDUALS BY PRODUCT WIZARD ----
                        	!get species group that is converted into a residual
                        	if DialogGetElement("Specify the product that is always converted to a residual",c_Prd) = 0 then return-1; endif;
                        
                        	repeat  ! for each residual produced
                        		block !get residual that  c_prd is converted into
                        			s := FormatString("Specify the residual that is created from '%e'",c_Prd);
                        			if DialogGetElement(s,c_Res) =0 then return-1; endif;
                        		endblock;
                        
                        		block !get conversion rate
                        			s := FormatString("Specify the amount of residual '%e' produced from each unit of product '%e'",c_res,c_Prd);
                        			if DialogGetNumber(message : s,	reference : rate,decimals : 2,	title : "Residuals Wizard") = -1 then return-1; endif;
                        
                        		endblock;
                        
                        		block !confirm action
                        			s := FormatString("The following will happen:\n\n 1. All mills that use '%e' will be tagged 'Produces residuals',\n\n",c_prd);
                        			s += FormatString("2. Each unit of '%e' will be converted into %n units of '%e',and\n\n",c_prd,rate,c_res);
                        			!s += "3. The haultime from the destinations to Xall will be zero.";
                        			if DialogAsk(s,"Yes","No",title:"Confirm Action") <> 1 then return -1; endif;
                        		endblock;
                        
                        		block !===ASSIGMENTS===
                        			ProducesResiduals((dest) |   ProductsUsed(dest,c_prd)) := 1  ;
                        
                        			ResidualsProduced((dest,c_prd,c_res) |  ProductsUsed(dest,c_prd) and ProducesResiduals(dest) ) := rate;
                        
                        			!HaulTime((dest,'xall') |   ProductsUsed(dest,c_prd)) := zero;
                        		endblock;
                        
                        		s := FormatString("Production of Residual '%e' has been identified for all mills using '%e'\n\n",c_res,c_prd);
                        
                        		if count(res) > 1 then
                        			s += FormatString("Does product '%e' produce additional residuals?",c_prd);
                        			retval := DialogAsk(s,button1:"Yes", button2:"No",title:"Residuals Wizard Successful");
                        		else
                        			DialogMessage(s,"Residuals Wizard Successful");
                        			retval := 0;
                        		endif;
                        		break when (retval <> 1 );
                        	endrepeat;
                        endblock;
                    }
                    StringParameter s;
                    ElementParameter c_Prd {
                        Range: Products;
                    }
                    ElementParameter c_Res {
                        Range: Residuals;
                    }
                    ElementParameter c_Mill {
                        Range: Destinations;
                    }
                    Parameter rate {
                        Range: (0, 10];
                    }
                    Parameter retval;
                }
                Procedure ProducesResiduals_Wizard_BySector_wrk {
                    Body: {
                        block ! --- RESIDUALS BY SECTOR WIZARD ----
                        	!get sector group that produces residuals
                        	s := "Pick sector that creates residuals";
                        	if DialogGetElement(s,c_Sect) = 0 then return -1; endif;
                        
                        	! --- get the product group for which the conversion will be specified
                        	!     each used product that is part of product group will get a conversion
                        	s := "Select Product Group that gets converted";
                        	if DialogGetElement(s,c_ProdGroup) = 0 then return -1 endif;
                        
                        	repeat  ! for each residual produced
                        		!--- get residual that  c_prd is converted into
                        		s := FormatString("Specify the residual that is created from '%e'",c_ProdGroup);
                        		if DialogGetElement(s,c_Res) =0 then return-1; endif;
                        
                        		!---get conversion rate
                        		s := FormatString("Specify the amount of residual '%e' produced from each unit of product '%e'",c_res,c_ProdGroup);
                        		if DialogGetNumber(message : s,	reference : rate,decimals : 2,	title : "Residuals Wizard") = -1 then return-1; endif;
                        
                        
                        		block !confirm action
                        			s := FormatString("The following will happen:\n\n 1. All mills in sector '%e' that use products in group '%e' will be tagged 'Produces residuals',\n\n",c_Sect,c_ProdGroup);
                        			s += FormatString("2. Each unit of '%e' will be converted into %n units of '%e',and\n\n",c_ProdGroup,rate,c_res);
                        !			s += "3. The haultime from the destinations to Xall will be zero.";
                        			if DialogAsk(s,"Yes","No",title:"Confirm Action") <> 1 then return -1; endif;
                        		endblock;
                        
                        		block !===ASSIGMENTS===
                        			ProducesResiduals((dest)
                        				|   cMillSector(c_sect,dest)										! Mill in sector c_sect
                        				and exists(gpr | ProductsUsed(dest,gpr) and cPrG(c_ProdGroup,gpr))		! mill uses product in c_ProdGroup
                        				) := 1  ;
                        
                        			ResidualsProduced((dest,gpr,c_res)
                        			|   cMillSector(c_sect,dest)										! Mill in sector c_sect
                        			and ProducesResiduals(dest) 											! produces residuals
                        			and ProductsUsed(dest,gpr) and cPrG(c_ProdGroup,gpr)					! mill uses product in c_ProdGroup
                        			) := rate;
                        
                        !			HaulTime((dest,'xall')
                        !			|   MillSectorRelation(c_sect,dest)										! Mill in sector c_sect
                        !			and exists(gpr | ProductsUsed(dest,gpr) and cPrG(c_ProdGroup,gpr))		! mill uses product in c_ProdGroup
                        !			) := zero;
                        		endblock;
                        
                        		s := FormatString("Production of Residual '%e' has been identified for all mills in sector '%e' using products in group'%e'\n\n",c_Res,c_Sect,c_ProdGroup);
                        		if count(res) > 1 then
                        			s += FormatString("Do products in '%e' produce additional residuals?",c_ProdGroup);
                        			retval := DialogAsk(s,button1:"Yes", button2:"No",title:"Residuals Wizard Successful");
                        		else
                        			DialogMessage(s,"Residuals Wizard Successful");
                        			retval := 0;
                        		endif;
                        		break when (retval <> 1 );
                        	endrepeat;
                        
                        endblock; ! ---END RESIDUALS BY SECTOR WIZARD ----
                    }
                    StringParameter s;
                    ElementParameter c_Prd {
                        Range: Products;
                    }
                    ElementParameter c_Res {
                        Range: Residuals;
                    }
                    ElementParameter c_Mill {
                        Range: Destinations;
                    }
                    ElementParameter c_Sect {
                        Range: Sectors;
                    }
                    ElementParameter c_ProdGroup {
                        Range: ProductGroups;
                    }
                    Parameter rate {
                        Range: (0, 10];
                    }
                    Parameter retval;
                }
                Procedure UsesResiduals_Wizard_BySector_wrk {
                    Body: {
                        block ! --- USES RESIDUALS BY SECTOR WIZARD ----
                        	!get sector group that uses residuals
                        	s := "Pick sector that uses residuals";
                        	if DialogGetElement(s,c_Sect) = 0 then return -1; endif;
                        
                        	! --- get the residual product group used
                        	!     each used product that is part of product group will get a conversion
                        	s := "Select Product Group that is used";
                        	if DialogGetElement(s,c_ProdGroup) = 0 then return -1 endif;
                        
                        	! --- get the default HaulTime
                        !	s := "Enter the default HaulTime to affected destinations";
                        !	if DialogGetNumber(s,rate,1,"Enter Value") = 0 then return -1; endif;
                        
                        		block !confirm action
                        			s := FormatString("The following will happen:\n\n 1. All mills in sector '%e'  will be tagged 'Uses residuals',\n\n",c_Sect);
                        			s += FormatString("2. The mills will be set to use residual '%e'",c_ProdGroup);
                        !			s += FormatString("3. Haultimes from mills producing residuals in '%e' to mills that use it' will be %n.",c_ProdGroup,rate);
                        			if DialogAsk(s,"Yes","No",title:"Confirm Action") <> 1 then return -1; endif;
                        		endblock;
                        
                        		block !===ASSIGMENTS===
                        			UsesResiduals((dest) |   cMillSector(c_sect,dest)				! Mill in sector c_sect
                        				) := 1  ;
                        
                        			ResidualsUsed_PrGrp((dest,c_ProdGroup) |   cMillSector(c_sect,dest)		! Mill in sector c_sect
                        			!and  exists(res | ResidualsUsed(dest,res) and cPrG(c_ProdGroup,res))		! mill uses product in c_ProdGroup
                        			) := 1;
                        
                        	! use haultime calculator instead
                        !			HaulTime((src,dest)
                        !			| exists(gpr | sum[prd,ResidualsProduced(src,prd,gpr)]  and cPrG(c_ProdGroup,gpr))		! mill produces residual in c_ProdGroup
                        !!			and     (not haultime(src,dest) )
                        !			) := inf ;
                        		endblock;
                        
                        		DialogMessage("Residual Users Defined","Residuals Wizard Successful");
                        endblock; ! ---END RESIDUALS BY SECTOR WIZARD ----
                    }
                    StringParameter s;
                    ElementParameter c_Prd {
                        Range: Products;
                    }
                    ElementParameter c_Res {
                        Range: Residuals;
                    }
                    ElementParameter c_Mill {
                        Range: Destinations;
                    }
                    ElementParameter c_Sect {
                        Range: Sectors;
                    }
                    ElementParameter c_ProdGroup {
                        Range: ResidualGroups;
                    }
                    Parameter rate {
                        Range: (0, 10];
                        Default: 5.55;
                    }
                    Parameter retval;
                }
            }
            Section Data_Entry_Section {
                ElementParameter _ChangeParameter {
                    Range: AllParameters;
                    Property: NoSave;
                }
                Procedure GetNewValue {
                    Body: {
                        !_ChangeParameter := 'MaxAllowedHaultime' ;
                        !_ChangeParameter := 'MinimumPercentUtilizableVolume' ;
                        !_ChangeParameter := 'ProductValue' ;
                        block where Warning_Argument_Unit_Consistency := off ;
                        
                        switch (_ChangeParameter) do
                        	'MaxAllowedHaultime':
                        		de::GetNumber(MaxAllowedHaultime,MaxAllowedHaultime.unit);
                        
                        	'MinimumPercentUtilizableVolume':
                        		de::GetNumber(MinimumPercentUtilizableVolume,MinimumPercentUtilizableVolume.unit);
                        
                        	'ProductValue':
                        		ProductUnit((gpr) | not ProductUnit(gpr)) := [m3];
                        		LocalUnit := [$/m3];
                        		! element parameters depend on pagename
                        		PageGetActive(PageName);
                        		if FindString(PageName , "Curve") then		! Cost Curves
                        			if not (_DestTemp and Current_prd) then  return 0; endif;
                        			xx := ProductValue(_DestTemp,Current_prd) ;
                        			number := xx;
                        			!Number := ProductValue(_Dest_Sel,Current_gpr) ;
                        			de::GetNumber(Number , LocalUnit);
                        			ProductValue(_DestTemp,Current_prd)  := Number;
                        		else  !Product Values Page
                        			Current_prd := ElementCast(AllProducts,Current_gpr,0);
                        			!if not _dest_sel then _Dest_Sel := 'Bonifer'; endif;
                        			!if not Current_prd  then Current_prd := 'Thlog'; endif;
                        			if not (_dest_sel and Current_prd) then
                        				return 0;
                        			endif;
                        			!LocalUnit := ProductValue.unit ;  ! ProductValue(_Dest_Sel,Current_prd).unit;
                        			!DialogMessage(FormatString("ProductValue(%e,%e) = %n %u",_Dest_Sel,Current_prd, ProductValue(_Dest_Sel,Current_prd),LocalUnit));
                        			xx := ProductValue(_Dest_Sel,Current_gpr) ;
                        			number := xx;
                        			!Number := ProductValue(_Dest_Sel,Current_gpr) ;
                        			de::GetNumber(Number , LocalUnit);
                        			ProductValue(_Dest_Sel,Current_gpr)  := Number;
                        		endif;
                        
                        	'MillDemand_PrGrp':
                        		if (not Current_mill ) or (not Current_PrGrp) or (not _FirstTimePeriod) or (not _tt) then return 0; endif;
                        		!ProductUnit((gpr) | not ProductUnit(gpr)) := [m3];
                        		LocalUnit := [m3];
                        		xx := MillDemand_PrGrp(Current_Mill, Current_PrGrp, _tt, _FirstTimePeriod ) ;
                        		Number := xx;
                        		!Number := ProductValue(_Dest_Sel,Current_gpr) ;
                        		de::GetNumber(Number , LocalUnit);
                        		MillDemand_PrGrp(Current_Mill, Current_PrGrp, _tt, _FirstTimePeriod ) := Number;
                        
                        	'MillResidualDemand_PrGrp':
                        		if (not Current_mill ) or (not Current_ResGrp) or (not _FirstTimePeriod) or (not _tt) then return 0; endif;
                        
                        		LocalUnit := [m3];
                        		xx := MillResidualDemand_PrGrp(Current_Mill, Current_ResGrp, _tt, _FirstTimePeriod ) ;
                        		Number := xx;
                        		!Number := ProductValue(_Dest_Sel,Current_gpr) ;
                        		de::GetNumber(Number , LocalUnit);
                        		MillResidualDemand_PrGrp(Current_Mill, Current_ResGrp, _tt, _FirstTimePeriod ) := Number;
                        
                        	'ResidualsProduced':
                        		if (not _dest_s ) or (not Current_Res) or (not Current_prd) then return 0; endif;
                        		LocalUnit := [ODT/m3];
                        		xx := ResidualsProduced(_dest_s, Current_prd, Current_Res) ;
                        		Number := xx;
                        		!Number := ProductValue(_Dest_Sel,Current_gpr) ;
                        		de::GetNumber(Number , LocalUnit);
                        		ResidualsProduced(_dest_s, Current_prd, Current_Res) := Number;
                        
                        	'PercentBlockAvailable':
                        		de::GetNumber(PercentBlockAvailable(_blk_s), PercentBlockAvailable.unit);
                        
                        	'InitialGS':
                        		de::GetNumber( InitialGS(_blk_s, Current_prd),InitialGS(_blk_s, Current_prd).unit );
                        
                        	default:
                        
                        endswitch;
                        endblock;
                    }
                    UnitParameter LocalUnit;
                    Parameter Number {
                        Unit: LocalUnit;
                    }
                    Parameter xx;
                    StringParameter PageName;
                }
            }
        }
        Section Mapping_Section {
            Section Map_Initialization_Section {
                Procedure InitializeAllSourcesMU {
                    Body: {
                        /* AllSoucesMU contains all MUs (block aggregates) and destinations that produce sources
                         * easier? than using Super-set of mu's and blocks
                        /**/
                        
                        	empty MapAllSources;
                        	cleandependents MapAllSources;
                        
                        	! check if MU of same name exists, if so rename MU
                        	for dest   | ProducesResiduals(dest)	do
                        		_mu := ElementCast(ManagementUnits,dest,0);
                        		if _mu <> '' then
                        			SetElementRename(ManagementUnits,_mu,FormatString("%e_",_mu));
                        		endif;
                        	endfor;
                        
                        	!add each mu to set
                        	for mu_s 	do
                        		SetElementAdd(MapSourcesMU,_mapsrc,mu_s);
                        		cMuMapmu(_MapSrc,mu_s) := 1;
                        	endfor;
                        
                        	!add each dest that produces to set  | ProducesResiduals(dest)
                        	for dest_sort   | ProducesResiduals(dest_sort)	do
                        		SetElementAdd(MapSourcesMill,_mapsrc,dest_sort);
                        		cDestMapsrc(_mapsrc,dest_sort) :=1;
                        	endfor;
                        
                        assert Assert_AllProductsHaveUnits;
                        
                        !reset Robust solution selector
                        empty Sel_ShowRobustSolution;
                        
                        InitializeMapSelectors;
                        InitializeColourOrder;
                        InitializeVisibleArea;
                        
                        OpenParentPage;
                    }
                }
                Procedure InitializeMapSelectors {
                    Body: {
                        block ! check that all element parameters used in maps have a value
                        	if (not _MillToMap) then _MillToMap := first(RcvDest); endif;
                        	if (not c_MapSrcMu) then c_MapSrcMu := first(i_MapSrcMu); endif;
                        endblock;
                    }
                }
                Procedure InitializeColourOrder {
                    Body: {
                        cleandependents MapQuantileColours_Ordered;
                        
                        if count(imqco | GUIColourOrder(imqco)>0) < NumberQuantiles then
                        	GUIColourOrder(imqco) := ColourSetOrder(imqco);
                        endif;
                    }
                }
                Procedure InitializeColourSetOrder {
                    Body: {
                        
                        ColourSetOrder(imqco) := ord(imqco);
                    }
                }
                Procedure InitializeVisibleArea {
                    Body: {
                        empty VisibleArea_Default;
                        if exists(ims | not VisibleArea_Default(iMS) ) then
                        	VisibleArea_Default(iMS)  :=  {
                        	'Left' : 	199962.1035,
                        	'Right' : 1646350.979,
                        	'Top' :	12811991.35,
                        	'Bottom' :11963344.82
                        	};
                        endif;
                        
                        for ims do
                        	switch ims do
                        	'Left':
                        		CalcExtent(iMS) := min[ min(dest | Millxy(dest,'X') , Millxy(dest,'X')) ,
                        								min(mu | MUxy(mu,'X') , MUxy(mu,'X')) ,
                        								min(blk| BLKxy(blk,'X') , BLKxy(blk,'X')) ];
                        	'Right':
                        		CalcExtent(iMS) := max[ max(dest| Millxy(dest,'X') , Millxy(dest,'X')) ,
                        								max(mu| MUxy(mu,'X') , MUxy(mu,'X')) ,
                        								max(blk| BLKxy(blk,'X') , BLKxy(blk,'X')) ];
                        	'Top':
                        		CalcExtent(iMS) := max[ max(dest| Millxy(dest,'y') , Millxy(dest,'y')) ,
                        								max(mu| MUxy(mu,'y') , MUxy(mu,'y')) ,
                        								max(blk| BLKxy(blk,'y') , BLKxy(blk,'y')) ];
                        	'Bottom':
                        		CalcExtent(iMS) := min[ min(dest| Millxy(dest,'Y') , Millxy(dest,'Y')) ,
                        								min(mu| MUxy(mu,'y') , MUxy(mu,'y')) ,
                        								min(blk| BLKxy(blk,'y') , BLKxy(blk,'y')) ];
                        	endswitch;
                        endfor;
                        IncreaseExtent(calcextent,105 [%] );
                        
                        VisibleArea_Default(iMS) := CalcExtent(iMS);
                    }
                    Parameter CalcExtent {
                        IndexDomain: (iMS);
                    }
                }
            }
            Section Print_Page_Section {
                Procedure PrintPage_WoodFlow_To_Mill {
                    Body: {
                        !**********************************************
                        !---- Print the PrintPage "Report To Mills"
                        !**********************************************
                        !PrintEndReport;
                        switch DialogAsk(FormatString("How would you like your report to appear?\n\n1. %s\n2. %s"
                        				,"A single table showing all flows?"
                        				,"Separate Tables for products, received residuals, send residuals?")
                        		,"1","2","Cancel") do
                        1:	s := "Report To Mills_SingleTable";
                        2:	s := "Report To Mills_SeparateTables";
                        3:	return 0;
                        endswitch;
                        
                        cad::GetDatafileAttributes;
                        
                        if ReportName = "" then
                        	ReportName := "WoodFlowToMill_" + CurrentToString("%c%y%sAm|AllAbbrMonths|%d");
                        endif;
                        if PrintStartReport(	title    :  ReportName  )
                        	<> 1 then
                        		DialogError("Report cancelled");
                        		return 0;
                        endif;
                        
                        ZoomToFullExtent;
                        for RcvDest | MillsToReport(RcvDest)
                        			and exists[(MapSrc, dest, gPrGrp)
                        				|DeliveredVolumeToMapNEW_Detail(MapSrc, dest, gPrGrp) ] do
                        	_MillToMap := RcvDest;
                        	ZoomToFullExtent;
                        	ZoomToDeliverExtent_Mill;
                        	!PageRefreshAll;
                        
                        
                        
                        !	DeliveredVolumeToMapPROD(MapSrc, dest)
                        !	DeliveredVolumeToMapRES(MapSrc, dest)
                        !	DeliveredVolumeToMapRESSent(MapSrc, dest)
                        
                        	PrintPage(s);
                        endfor;
                        
                        
                        PrintEndReport;
                    }
                    StringParameter s;
                    StringParameter ReportName {
                        Property: RetainsValue;
                    }
                }
                Procedure SelectMillsToReport {
                    Body: {
                        switch (_gmill) do
                        'All' :
                        	MillsToReport(RcvDest) := 1;
                        'None' :
                        	MillsToReport(RcvDest) := 0;
                        'Produces Residuals' :
                        	MillsToReport(RcvDest | ProducesResiduals(rcvdest)) := 1;
                        'Does Not Produce Residuals' :
                        	MillsToReport(RcvDest | ProducesResiduals(rcvdest)=0) := 1;
                        'Uses Residuals' :
                        		MillsToReport(RcvDest | UsesResiduals(rcvdest)) := 1;
                        endswitch;
                        
                        ! remove mills that don't receive enough wood
                        MillsToReport(RcvDest |
                        	sum[ (mapsrc, gPrGrp) , 	DeliveredVolumeToMapNEW_Detail(MapSrc, RcvDest, gPrGrp) ]
                        		<  MinimumVolumeToMap
                        	) := 0;
                        
                        PageRefreshAll;
                    }
                }
                Parameter MillsToReport {
                    IndexDomain: (RcvDest);
                    Range: binary;
                    Property: NoSave;
                }
                Set MillGroups {
                    Index: gMill;
                    Parameter: _gMill;
                    Property: NoSave;
                    Definition: {
                        { 'All' , 'None' , 'Produces Residuals' , 'Does Not Produce Residuals' ,'Uses Residuals' }
                    }
                }
                Parameter boolPrinterSetup {
                    Range: binary;
                    Unit: 1;
                    Property: NoSave;
                }
            }
            Section BLK_Mapping_Section {
                Parameter VisibleArea_BLK {
                    IndexDomain: (iMS);
                }
                Parameter VisibleArea_Accessible {
                    IndexDomain: (iMS);
                }
                Set BLK_MapOptions {
                    Index: bmo;
                    Parameter: _bmo;
                    Property: NoSave;
                    Definition: data { 'Block' , 'MU' , 'Mill' };
                }
                Parameter BLK_DeliveredBlockVolume {
                    IndexDomain: {
                        (blk,dest,gPrGrp) | ProductsToMap(gPrGrp)
                        and MinimumVolumeToMap <= sum[(term,prd) | cPrG(gPrGrp, prd)and TermsToMap(term)
                                                 ,DeliveredBlockVolume_RO( term, blk, prd, dest, gPrGrp ) ]
                    }
                    Unit: k_m3;
                    Property: NoSave;
                    Definition: {
                        sum[(term,prd) | cPrG(gPrGrp, prd) and TermsToMap(term)
                        and
                        if _bmo='Mill' then
                        	dest = _MillToMap
                        elseif _bmo='MU' then
                        	MU_Block_Relation(_mu_s, blk)
                        else !'blk
                        	blk = _musrc
                        endif
                        
                        ,DeliveredBlockVolume_RO( term, blk, prd, dest, gPrGrp ) ]
                    }
                }
                ElementParameter _BLK_DestLabels {
                    IndexDomain: (dest);
                    Range: Destinations;
                    Property: NoSave;
                    Definition: dest | sum[(blk,gPrGrp), BLK_DeliveredBlockVolume(blk, dest, gPrGrp) ];
                }
                ElementParameter _BLK_BLKLabels {
                    IndexDomain: blk;
                    Range: Blocks;
                    Property: NoSave;
                    Definition: {
                        if _bmo = 'Block' then
                        blk | sum[(dest,gPrGrp), BLK_DeliveredBlockVolume(blk, dest, gPrGrp) ]
                        endif
                    }
                }
                Parameter BLK_BlkSize {
                    IndexDomain: blk | sum[(dest,gPrGrp), BLK_DeliveredBlockVolume(blk, dest, gPrGrp)];
                    Text: "size of block marker on map";
                    Property: NoSave;
                    Definition: {
                        
                        sum[(dest,gPrGrp) ,BLK_DeliveredBlockVolume(blk, dest, gPrGrp)]
                        		/$ sum[(blk1,dest,gPrGrp) , BLK_DeliveredBlockVolume(blk1, dest, gPrGrp) ]
                        !if _bmo = 'block' then 1
                        !elseif _bmo = 'MU' then
                        !	! proportion of total MU wood delivered from each block
                        !	sum[(dest,gPrGrp) ,BLK_DeliveredBlockVolume(blk, dest, gPrGrp)]
                        !		/$ sum[(blk1,dest,gPrGrp) , BLK_DeliveredBlockVolume(blk1, dest, gPrGrp) ]
                        !elseif _bmo = 'Mill' then
                        !	! proportion of wood delivered to dest from each block
                        !	sum[(dest,gPrGrp) ,BLK_DeliveredBlockVolume(blk, dest, gPrGrp)]
                        !		/$ sum[(blk1,dest,gPrGrp) , BLK_DeliveredBlockVolume(blk1, dest, gPrGrp) ]
                        !endif
                    }
                }
                Parameter BLK_ArcSize {
                    IndexDomain: (blk,dest) | sum[(gPrGrp), BLK_DeliveredBlockVolume(blk, dest, gPrGrp)];
                    Text: "size of block marker on map";
                    Property: NoSave;
                    Definition: {
                        
                        sum[(gPrGrp) ,BLK_DeliveredBlockVolume(blk, dest, gPrGrp)]
                        		/$ sum[(blk1,dest1,gPrGrp) , BLK_DeliveredBlockVolume(blk1, dest1, gPrGrp) ]
                        !if _bmo = 'block' then 1
                        !elseif _bmo = 'MU' then
                        !	! proportion of total MU wood delivered from each block
                        !	sum[(dest,gPrGrp) ,BLK_DeliveredBlockVolume(blk, dest, gPrGrp)]
                        !		/$ sum[(blk1,dest,gPrGrp) , BLK_DeliveredBlockVolume(blk1, dest, gPrGrp) ]
                        !elseif _bmo = 'Mill' then
                        !	! proportion of wood delivered to dest from each block
                        !	sum[(dest,gPrGrp) ,BLK_DeliveredBlockVolume(blk, dest, gPrGrp)]
                        !		/$ sum[(blk1,dest,gPrGrp) , BLK_DeliveredBlockVolume(blk1, dest, gPrGrp) ]
                        !endif
                    }
                }
                Procedure ZoomToExtent_BLK {
                    Body: {
                        /* set map extent to be the same as the blocks in Current_mu
                        /**/
                        !--- Check that Blkxy exists
                        if count((blk,ixy) | BLKxy(blk, ixy)) = 0 then
                        	switch(DialogAsk("Do you wish to load coordinates for Blocks?","Yes","No","Cancel","Missing XYs")) do
                        	1:
                        		if DatasetLoadCurrent(data_category :  'MapXY', dataset:  cad::_DataSet,dialog:  1) <> 1 then return 0; endif;
                        	2,3: return 0;
                        	endswitch;
                        endif;
                        
                        empty NewExtent;
                        !--- get extent of current visible area
                        CurrentExtent(iMS) := VisibleArea_BLK(iMS);
                        
                        !-- get ratio of height to width
                        SideRatio := [CurrentExtent('top') - CurrentExtent('bottom')] /$ [CurrentExtent('right') - CurrentExtent('left')];
                        
                        	DisplayedBlocks := { blk | sum[(dest, gPrGrp) , BLK_DeliveredBlockVolume(blk, dest, gPrGrp) ] } ;
                        	DisplayedDest   := { dest | sum[(blk, gPrGrp) , BLK_DeliveredBlockVolume(blk, dest, gPrGrp) ] } ;
                        
                        	!-- calculate extent of blocks in current_MU
                        	!DebuggerBreakpoint;
                        	NewExtent('Top') 	    := max [  max[ dblk ,BLKxy(dblk, 'y') ], max[ ddest ,Millxy(ddest, 'y') ] ];
                        	NewExtent('Bottom') 	:= min [  min[ dblk ,BLKxy(dblk, 'y') ], min[ ddest ,Millxy(ddest, 'y') ] ];
                        	NewExtent('Right') 	    := max [  max[ dblk ,BLKxy(dblk, 'x') ], max[ ddest ,Millxy(ddest, 'x') ] ];
                        	NewExtent('Left') 		:= min [  min[ dblk ,BLKxy(dblk, 'x') ], min[ ddest ,Millxy(ddest, 'x') ] ];
                        
                        
                        
                        !--make extent 10% larger
                        !Buffer := [NewExtent('top') - NewExtent('bottom')] / 10;
                        !NewExtent(ims | ims='Top' or ims = 'Right') +=  Buffer;
                        !NewExtent(ims | ims='Left' or ims = 'Bottom') -=  Buffer;
                        IncreaseExtent(NewExtent,110 [%]);
                        
                        !-- adjust ratio Height =  Width * Sideratio
                        NewSideRatio := [NewExtent('top') - NewExtent('bottom')] /$ [NewExtent('right') - NewExtent('left')];
                        
                        if SideRatio >0 and NewSideRatio > SideRatio  then
                        	!not wide enough:  stretch right Width = Height / SideRatio
                        	NewExtent('right') := NewExtent('left') + [NewExtent('top') - NewExtent('bottom')] / SideRatio;
                        else ! too tall:  stretch bottom Height =  Width * SideRatio
                        	NewExtent('Bottom') := NewExtent('Top') - [NewExtent('right') - NewExtent('left')] * SideRatio;
                        endif;
                        
                        !-- set visible area to new extent
                        VisibleArea_BLK(iMS) := NewExtent(iMS);
                        !-- set extent for legend map
                        switch _bmo do
                        'MU'	:	VisibleArea_MU(iMS) := NewExtent(iMS);
                        'Mill'	:	VisibleArea_Mill(iMS) := NewExtent(iMS);
                        endswitch;
                    }
                    Parameter MapSourceAndDest {
                        IndexDomain: {
                            (MapSrc,dest) |
                            sum [(PrGrp), DeliveredMUVolumeToMap_Detail(MapSrc,dest,PrGrp)] $ MapShowProd
                            or
                            sum [(ResGrp), DeliveredMUVolumeToMap_Detail(MapSrc,dest,ResGrp)] $ MapShowRes
                        }
                        Text: "Sources and destinations shown in map";
                        InitialData: 999;
                    }
                    Set DisplayedBlocks {
                        SubsetOf: Blocks;
                        Index: dblk;
                    }
                    Set DisplayedDest {
                        SubsetOf: Destinations;
                        Index: ddest;
                    }
                    Parameter CurrentExtent {
                        IndexDomain: (iMS);
                    }
                    Parameter NewExtent {
                        IndexDomain: (iMS);
                    }
                    Parameter SideRatio;
                    Parameter NewSideRatio;
                    Parameter Buffer;
                }
                Procedure ZoomToExtent_AccessibleVolume {
                    Body: {
                        /* Based on ZoomToExtent_BLK
                         * set map extent to be the same as the blocks in Current_mu
                        /**/
                        !-- Check that Current_dest is valid
                        if not Current_dest then
                        	if not _Dest_Sel then
                        		DialogError("Current_Dest and _dest_sel are empty");
                        	return 0;
                        	endif;
                        	DialogMessage("Current_Dest is empty\n\nsetting to _Dest_Sel");
                        	Current_dest := _Dest_Sel;
                        endif;
                        
                        !--- Check that Blkxy exists
                        if count((blk,ixy) | BLKxy(blk, ixy)) = 0 then
                        	switch(DialogAsk("Do you wish to load coordinates for Blocks?","Yes","No","Cancel","Missing XYs")) do
                        	1:
                        		if DatasetLoadCurrent(data_category :  'MapXY', dataset:  cad::_DataSet,dialog:  1) <> 1 then return 0; endif;
                        	2,3: return 0;
                        	endswitch;
                        endif;
                        
                        empty NewExtent;
                        !--- get extent of current visible area
                        CurrentExtent(iMS) := VisibleArea_BLK(iMS);
                        
                        !-- get ratio of height to width
                        SideRatio := [CurrentExtent('top') - CurrentExtent('bottom')] /$ [CurrentExtent('right') - CurrentExtent('left')];
                        
                        	DisplayedBlocks := { blk | exists[( prd) | AccessibleVolume(blk, Current_dest, prd) ] } ;
                        	DisplayedDest   := Current_dest; !{ dest | exists[(blk, prd) | AccessibleVolume(blk, dest, prd) ] } ;
                        
                        	!-- calculate extent of blocks in current_MU
                        	!DebuggerBreakpoint;
                        	NewExtent('Top') 	    := max [  max[ dblk ,BLKxy(dblk, 'y') ], max[ ddest ,Millxy(ddest, 'y') ] ];
                        	NewExtent('Bottom') 	:= min [  min[ dblk ,BLKxy(dblk, 'y') ], min[ ddest ,Millxy(ddest, 'y') ] ];
                        	NewExtent('Right') 	    := max [  max[ dblk ,BLKxy(dblk, 'x') ], max[ ddest ,Millxy(ddest, 'x') ] ];
                        	NewExtent('Left') 		:= min [  min[ dblk ,BLKxy(dblk, 'x') ], min[ ddest ,Millxy(ddest, 'x') ] ];
                        
                        
                        
                        !--make extent 10% larger
                        !Buffer := [NewExtent('top') - NewExtent('bottom')] / 10;
                        !NewExtent(ims | ims='Top' or ims = 'Right') +=  Buffer;
                        !NewExtent(ims | ims='Left' or ims = 'Bottom') -=  Buffer;
                        IncreaseExtent(NewExtent,110 [%]);
                        
                        !-- adjust ratio Height =  Width * Sideratio
                        NewSideRatio := [NewExtent('top') - NewExtent('bottom')] /$ [NewExtent('right') - NewExtent('left')];
                        
                        if SideRatio >0 and NewSideRatio > SideRatio  then
                        	!not wide enough:  stretch right Width = Height / SideRatio
                        	NewExtent('right') := NewExtent('left') + [NewExtent('top') - NewExtent('bottom')] / SideRatio;
                        else ! too tall:  stretch bottom Height =  Width * SideRatio
                        	NewExtent('Bottom') := NewExtent('Top') - [NewExtent('right') - NewExtent('left')] * SideRatio;
                        endif;
                        
                        !-- set visible area to new extent
                        VisibleArea_Accessible(iMS) := NewExtent(iMS);
                        !-- set extent for legend map
                        !switch _bmo do
                        !'MU'	:	VisibleArea_MU(iMS) := NewExtent(iMS);
                        !'Mill'	:	VisibleArea_Mill(iMS) := NewExtent(iMS);
                        !endswitch;
                        !
                    }
                    Parameter MapSourceAndDest {
                        IndexDomain: {
                            (MapSrc,dest) |
                            sum [(PrGrp), DeliveredMUVolumeToMap_Detail(MapSrc,dest,PrGrp)] $ MapShowProd
                            or
                            sum [(ResGrp), DeliveredMUVolumeToMap_Detail(MapSrc,dest,ResGrp)] $ MapShowRes
                        }
                        Text: "Sources and destinations shown in map";
                        InitialData: 999;
                    }
                    Set DisplayedBlocks {
                        SubsetOf: Blocks;
                        Index: dblk;
                    }
                    Set DisplayedDest {
                        SubsetOf: Destinations;
                        Index: ddest;
                    }
                    Parameter CurrentExtent {
                        IndexDomain: (iMS);
                    }
                    Parameter NewExtent {
                        IndexDomain: (iMS);
                    }
                    Parameter SideRatio;
                    Parameter NewSideRatio;
                    Parameter Buffer;
                }
                Procedure xxxxx {
                    Body: {
                        MapExtent_Default(iMS) := {
                        'left': -180,
                        'right': 180,
                        'top': 90,
                        'bottom':-90
                        
                        	};
                    }
                }
            }
            Section Map_Registration_Section {
                Procedure MapMarkersInitialize {
                    Body: {
                        !MarkerBottomLeft('x') := MapExtent_Default('Left');
                        !MarkerBottomLeft('y') := MapExtent_Default('Bottom') ;
                        !
                        !MarkerTopRight('x') := MapExtent_Default('right');
                        !MarkerTopRight('y') := MapExtent_Default('top');
                        
                        
                        ImageMarkersXY('bottomleft','x') := MapExtent_Default('Left');
                        ImageMarkersXY('bottomleft','y') := MapExtent_Default('Bottom') ;
                        ImageMarkersXY('topright','x')	:= MapExtent_Default('right');
                        ImageMarkersXY('topright','y')	:= MapExtent_Default('top');
                    }
                }
                Procedure MapExtentUpdate {
                    Body: {
                        !MarkerBottomLeft('x') := MapExtent_Default('Left');
                        !MarkerBottomLeft('y') := MapExtent_Default('Bottom') ;
                        !
                        !MarkerTopRight('x') := MapExtent_Default('right');
                        !MarkerTopRight('y') := MapExtent_Default('top');
                        
                        msg := "What would you like to do?";
                        msg := FormatString("%s\n\n1. Stretch background image into fit between markers?", msg);
                        msg := FormatString("%s\n2. (Clip) Use the portion of the image between the markers as the background?", msg);
                        msg := FormatString("%s\n3. (Clip) Strtch points & image to fit between the markers?", msg);
                        
                        if DialogGetNumber(msg,Choice,0,"Enter Choice") = 0 then return 0; endif;
                        
                        
                        switch (Choice) do
                        	1: !Fit image between markers
                        		MapExtent_Default('Left') 	:= 	ImageMarkersXY('bottomleft','x') ;
                        		MapExtent_Default('Bottom')	:=  ImageMarkersXY('bottomleft','y')	 ;
                        		MapExtent_Default('right')	:=  ImageMarkersXY('topright','x')	 ;
                        		MapExtent_Default('top')	:=  ImageMarkersXY('topright','y')	;
                        
                        	2: !Clip - use portion of image between markers as background
                        		VisibleArea_Default('Left') 	:= 	ImageMarkersXY('bottomleft','x') ;
                        		VisibleArea_Default('Bottom')	:=  ImageMarkersXY('bottomleft','y')	 ;
                        		VisibleArea_Default('right')	:=  ImageMarkersXY('topright','x')	 ;
                        		VisibleArea_Default('top')		:=  ImageMarkersXY('topright','y')	;
                        
                        		VisibleArea_BLK('Left') 	:= 	ImageMarkersXY('bottomleft','x') ;
                        		VisibleArea_BLK('Bottom')	:=  ImageMarkersXY('bottomleft','y')	 ;
                        		VisibleArea_BLK('right')	:=  ImageMarkersXY('topright','x')	 ;
                        		VisibleArea_BLK('top')		:=  ImageMarkersXY('topright','y')	;
                        
                        		VisibleArea_MU('Left') 	:= 	ImageMarkersXY('bottomleft','x') ;
                        		VisibleArea_MU('Bottom')	:=  ImageMarkersXY('bottomleft','y')	 ;
                        		VisibleArea_MU('right')	:=  ImageMarkersXY('topright','x')	 ;
                        		VisibleArea_MU('top')		:=  ImageMarkersXY('topright','y')	;
                        
                        		VisibleArea_Mill('Left') 	:= 	ImageMarkersXY('bottomleft','x') ;
                        		VisibleArea_Mill('Bottom')	:=  ImageMarkersXY('bottomleft','y')	 ;
                        		VisibleArea_Mill('right')	:=  ImageMarkersXY('topright','x')	 ;
                        		VisibleArea_Mill('top')		:=  ImageMarkersXY('topright','y')	;
                        
                        	3:	!Stretch points and image
                        		!-- Current extent
                        		Extent('topright', __x)		:= MapExtent_Default('right');
                        		Extent('topright', __y)		:= MapExtent_Default('top');
                        		Extent('bottomleft', __x)	:= MapExtent_Default('Left');
                        		Extent('bottomleft', __y)	:= MapExtent_Default('Bottom');
                        
                        
                        		!Fit image between markers
                        		MapExtent_Default('Left') 	:= 	ImageMarkersXY('bottomleft','x') ;
                        		MapExtent_Default('Bottom')	:=  ImageMarkersXY('bottomleft','y')	 ;
                        		MapExtent_Default('right')	:=  ImageMarkersXY('topright','x')	 ;
                        		MapExtent_Default('top')	:=  ImageMarkersXY('topright','y')	;
                        
                        		!Move points into new extent
                        		for dest do
                        			MovePoint( Millxy(dest, ixy) , Extent , ImageMarkersXY );
                        		endfor;
                        		for blk do
                        			MovePoint( BLKxy(blk, ixy) , Extent , ImageMarkersXY );
                        		endfor;
                        		for mu do
                        			MovePoint( MUxy(mu, ixy) , Extent , ImageMarkersXY );
                        		endfor;
                        
                        		!Clip - use portion of image between markers as background
                        		VisibleArea_Default('Left') 	:= 	ImageMarkersXY('bottomleft','x') ;
                        		VisibleArea_Default('Bottom')	:=  ImageMarkersXY('bottomleft','y')	 ;
                        		VisibleArea_Default('right')	:=  ImageMarkersXY('topright','x')	 ;
                        		VisibleArea_Default('top')		:=  ImageMarkersXY('topright','y')	;
                        
                        		VisibleArea_BLK('Left') 	:= 	ImageMarkersXY('bottomleft','x') ;
                        		VisibleArea_BLK('Bottom')	:=  ImageMarkersXY('bottomleft','y')	 ;
                        		VisibleArea_BLK('right')	:=  ImageMarkersXY('topright','x')	 ;
                        		VisibleArea_BLK('top')		:=  ImageMarkersXY('topright','y')	;
                        
                        		VisibleArea_MU('Left') 	:= 	ImageMarkersXY('bottomleft','x') ;
                        		VisibleArea_MU('Bottom')	:=  ImageMarkersXY('bottomleft','y')	 ;
                        		VisibleArea_MU('right')	:=  ImageMarkersXY('topright','x')	 ;
                        		VisibleArea_MU('top')		:=  ImageMarkersXY('topright','y')	;
                        
                        		VisibleArea_Mill('Left') 	:= 	ImageMarkersXY('bottomleft','x') ;
                        		VisibleArea_Mill('Bottom')	:=  ImageMarkersXY('bottomleft','y')	 ;
                        		VisibleArea_Mill('right')	:=  ImageMarkersXY('topright','x')	 ;
                        		VisibleArea_Mill('top')		:=  ImageMarkersXY('topright','y')	;
                        
                        
                        	default:
                        		halt;
                        
                        endswitch;
                    }
                    Parameter Choice {
                        Range: integer;
                    }
                    StringParameter msg;
                    Parameter Extent {
                        IndexDomain: (mark,ixy);
                    }
                    Parameter NewExtent {
                        IndexDomain: (mark,ixy);
                    }
                }
                Procedure MovePoint {
                    Arguments: (P,Extent,NewExtent);
                    Body: {
                        NewExtentRange(ixy) := [ NewExtent('topright', ixy) - NewExtent('bottomleft', ixy) ];
                        ExtentRange(ixy) := [ Extent('topright', ixy) - Extent('bottomleft', ixy) ];
                        
                        Ratio(ixy) := [P(ixy) - Extent('bottomleft', ixy)] / ExtentRange(ixy);
                        P(ixy) := Ratio(ixy) * NewExtentRange(ixy) + NewExtent('bottomleft',ixy);
                    }
                    Comment: "Translate point P(xy) from Extent(mark,xy) to NewExtent(mark,xy)";
                    Parameter ExtentRange {
                        IndexDomain: (ixy);
                    }
                    Parameter NewExtentRange {
                        IndexDomain: (ixy);
                    }
                    Parameter Ratio {
                        IndexDomain: (ixy);
                    }
                    Parameter P {
                        IndexDomain: (ixy);
                        Property: InOut;
                    }
                    Parameter Extent {
                        IndexDomain: (mark,ixy);
                        Property: Input;
                    }
                    Parameter NewExtent {
                        IndexDomain: (mark,ixy);
                        Property: Input;
                    }
                }
                Procedure JUNK_TestMovePoint {
                    Body: {
                        Extent(mark,ixy) := {
                         ('topright', __x)		: 10,
                         ('topright', __y)		: 10,
                         ('bottomleft', __x)	: 0,
                         ('bottomleft', __y)	: 0
                        } ;
                        
                        P(ixy) := {__x: 5	,	__y:	5 } ;
                        
                        NewExtent(mark,ixy) := {
                         ('topright', __x)		: 30,
                         ('topright', __y)		: 40,
                         ('bottomleft', __x)	: -40,
                         ('bottomleft', __y)	: -40
                        } ;
                        
                        
                        s := FormatString("P(%n,%n)  -->   ",p(__x),p(__y));
                        
                        MovePoint(p,extent,newextent);
                        
                         s += FormatString("P(%n,%n)",p(__x),p(__y));
                        
                         DialogMessage(s,"Translation Results");
                    }
                    Comment: "Translate point P(xy) from Extent(mark,xy) to NewExtent(mark,xy)";
                    Parameter Extent {
                        IndexDomain: (mark,ixy);
                    }
                    Parameter NewExtent {
                        IndexDomain: (mark,ixy);
                    }
                    Parameter P {
                        IndexDomain: (ixy);
                    }
                    StringParameter s;
                }
                Procedure ScatterBLKWithinVisibleArea {
                    Body: {
                        if DialogAsk("Do you want to randomly locate block centres within the visible map?","Yes","No","Cancel","Enter Choice")
                        	<> 1 then return 1; endif;
                        
                        
                        for blk do
                        	r := Uniform(VisibleArea_BLK('left') , VisibleArea_BLK('right'));
                        	BLKxy(blk,'x') := r;
                        	r := Uniform(VisibleArea_BLK('bottom') , VisibleArea_BLK('top'));
                        	BLKxy(blk,'y') := r;
                        endfor
                    }
                    Parameter r;
                }
                Procedure ScatterDESTWithinVisibleArea {
                    Body: {
                        if DialogAsk("Do you want to randomly locate Mills centres within the visible map?","Yes","No","Cancel","Enter Choice")
                        	<> 1 then return 1; endif;
                        
                        for dest do
                        	r := Uniform(VisibleArea_BLK('left') , VisibleArea_BLK('right'));
                        	Millxy(dest,'x') := r;
                        	r := Uniform(VisibleArea_BLK('bottom') , VisibleArea_BLK('top'));
                        	Millxy(dest,'y') := r;
                        endfor
                    }
                    Parameter r;
                }
                Procedure MoveMapBackground {
                    Body: {
                        switch (_iMS) do
                        	'right':
                        			MapExtent_Default(iMS | iMS in {'left','right' } )
                        				+= (MapExtent_Default('right') - MapExtent_Default('left')) * MoveFactor;
                        	'left':
                        			MapExtent_Default(iMS | iMS in {'left','right' } )
                        				-= (MapExtent_Default('right') - MapExtent_Default('left')) * MoveFactor;
                        	'top': !up
                        			MapExtent_Default(iMS | iMS in {'top','bottom' } )
                        				+= (MapExtent_Default('top') - MapExtent_Default('bottom')) * MoveFactor;
                        	'bottom': !down
                        			MapExtent_Default(iMS | iMS in {'top','bottom' } )
                        				-= (MapExtent_Default('top') - MapExtent_Default('bottom')) * MoveFactor;
                        
                        	default:
                        
                        endswitch;
                    }
                }
                Procedure MapSetMuXyFromBlocks {
                    Body: {
                        n := count(blk |  BLKxy(blk, 'x') );
                        empty MUxy;
                        
                        ! check if there are mu's with no associated blocks
                        if exists(mu | count(blk | MU_Block_Relation(mu, blk)) = 0 ) then
                        	s := "Some MUs have no associated blocks. What would you like to do?";
                        	s := FormatString("%s\n\n1. edit MU-Block relationships?\n2. Guess MUs from block names?\n3. Cancel",s);
                        	n := DialogAsk(s,"1 Edit","2 Guess","3 Cancel","Enter Choice");
                        	switch (n) do
                        		1:	DialogMessage("Open the Blocks Tab of the General Data page");
                        			return 1;
                        		2: AssignProxyMUsToMuBlockAssociations;
                        		default:
                        			return 0;
                        	endswitch;
                        endif;
                        
                        switch (DialogAsk("Do you wish to calculate MUxy based on Block XY","All","Missing","No","Enter Choice") ) do
                        	0,3:	return 0;
                        	1: ! all
                        		MUxy(mu, 'x') :=  sum(blk | MU_Block_Relation(mu, blk), BLKxy(blk, 'x') ) /$ count(blk |  MU_Block_Relation(mu, blk) );
                        		MUxy(mu, 'y') :=  sum(blk | MU_Block_Relation(mu, blk), BLKxy(blk, 'y') ) /$ count(blk |  MU_Block_Relation(mu, blk) );
                        	2: ! missing
                        		MUxy((mu, 'x') | not MUxy(mu, 'x')  )
                        			:=  sum(blk, BLKxy(blk  | MU_Block_Relation(mu, blk), 'x') ) /$ count(blk | MU_Block_Relation(mu, blk) );
                        		MUxy((mu, 'y') | not MUxy(mu, 'y')  )
                        			:=  sum(blk, BLKxy(blk  | MU_Block_Relation(mu, blk), 'y') ) /$ count(blk | MU_Block_Relation(mu, blk) );
                        endswitch;
                    }
                    ElementParameter n {
                        Range: Integers;
                    }
                    StringParameter s;
                }
                Procedure GetXYForDestinations {
                    Body: {
                        repeat
                        	DialogGetString("Enter Address",Address,"Enter Address");
                        	if GeoFindCoordinates(address,LatLong('y'),LatLong('x')) = 0 then
                        		DialogMessage("Address Not Found");
                        	endif;
                        	break when (DialogAsk(FormatString("Lat and Long for '%s' are: \n\nLatitude:\t\t%n\nLongitude:\t%n"	,address,latlong('y'),latlong('x'))
                        				,"Next Address","Done") > 1);
                        endrepeat;
                    }
                    Parameter LatLong {
                        IndexDomain: (ixy);
                    }
                    StringParameter Address;
                }
                Procedure ConvertToLatLong {
                    Body: {
                        ! set default regression coeff
                        m(__x) := 1.05609E-05;
                        b(__x) := -96.73292181;
                        
                        m(__y) := 5.22688E-06;
                        b(__y) := -16.61416654  ;
                        
                        
                        Millxy(dest,__x) $:= m(__x) * Millxy(dest, __x) + b(__x) ;
                        Millxy(dest,__y) $:= m(__y) * Millxy(dest, __y) + b(__y) ;
                        
                        MUxy(mu,__x) $:= m(__x) * MUxy(mu,__x) + b(__x) ;
                        MUxy(mu,__y) $:= m(__y) * MUxy(mu,__y) + b(__y) ;
                        
                        BLKxy(blk,__x) $:= m(__x) * BLKxy(blk, __x) + b(__x) ;
                        BLKxy(blk,__y) $:= m(__y) * BLKxy(blk, __y) + b(__y) ;
                        !
                    }
                    Parameter m {
                        IndexDomain: (ixy);
                    }
                    Parameter b {
                        IndexDomain: (ixy);
                    }
                }
                Set Markers {
                    Index: mark;
                    Property: NoSave;
                    Definition: {
                        {'BottomLeft', 'TopRight'}
                    }
                }
                Parameter ImageMarkersXY {
                    IndexDomain: (mark,ixy);
                }
                Parameter MapExtent_Default {
                    IndexDomain: (iMS);
                    InitialData: {
                        {
                        'left': -180,
                        'right': 180,
                        'top': 90,
                        'bottom':-90
                        
                        	};
                    }
                }
                Parameter ImageMarkerBottomLeft {
                    IndexDomain: (ixy);
                    Property: NoSave;
                }
                Parameter ImageMarkerTopRight {
                    IndexDomain: (ixy);
                    Property: NoSave;
                }
                Parameter ExtentMarkersXY {
                    IndexDomain: (mark,ixy);
                }
                Parameter ExtentMarkerBottomLeft {
                    IndexDomain: (ixy);
                    Property: NoSave;
                }
                Parameter ExtentMarkerTopRight {
                    IndexDomain: (ixy);
                    Property: NoSave;
                }
                Parameter MoveFactor {
                    Range: nonnegative;
                    Unit: %;
                    Default: 2;
                    Property: NoSave;
                }
                Set Communities {
                    Index: comm;
                    InitialData: {
                        {
                        'Alban',
                        'Atikokan',
                        'Bancroft',
                        'Barwick',
                        'Blind River',
                        'Bracebridge',
                        'Calstock',
                        'Chapleau',
                        'Cochrane',
                        'Cornwall',
                        'Dryden',
                        'Dubreuilville',
                        'Ear Falls',
                        'Eganville',
                        'Elk Lake',
                        'Emo',
                        'Englehart',
                        'Espanola',
                        'Falconbridge',
                        'Fort Frances',
                        'Gogama',
                        'Hagar',
                        'Hearst',
                        'Hornepayne',
                        'Hudson',
                        'Huntsville',
                        'Ignace',
                        'Iroquois Falls',
                        'Kapuskasing',
                        'Kenora',
                        'Killaloe',
                        'Kirkland Lake',
                        'L Amable',
                        'Larder Lake',
                        'Longlac',
                        'Madawaska',
                        'Marathon',
                        'Mattawa',
                        'Monetville',
                        'Nairn Centre',
                        'Nakina',
                        'Nipigon',
                        'Noelville',
                        'North Bay',
                        'Opasatika',
                        'Palmer Rapids',
                        'Pembroke',
                        'Red Rock',
                        'Sapawe',
                        'Sault Ste. Marie',
                        'Smooth Rock Falls',
                        'Sturgeon Falls',
                        'Terrace Bay',
                        'Thessalon',
                        'Thunder Bay',
                        'Timmins',
                        'Trenton',
                        'Wawa',
                        'White River',
                        'Whitney'}
                    }
                }
                ElementParameter DestinationCommunities {
                    IndexDomain: dest;
                    Range: Communities;
                }
            }
            Set XYs {
                Index: ixy;
                Property: NoSave;
                Definition: data { X, Y };
            }
            Parameter MUxy {
                IndexDomain: (mu,ixy);
            }
            Parameter BLKxy {
                IndexDomain: (blk,ixy);
            }
            Parameter MapAllSourcexy {
                IndexDomain: (MapSrc,ixy);
                Property: NoSave;
                Definition: {
                    ! Watch that mu's and dest have unique names or the xy will be added!
                    sum[ (dest)| cDestMapsrc(MapSrc,dest) and  ProducesResiduals(dest), Millxy(dest,ixy) ]
                    +
                    sum[ (mu)| cMuMapmu(MapSrc,mu) , MUxy(mu,ixy) ]
                }
            }
            Parameter Millxy {
                IndexDomain: (dest,ixy);
            }
            Parameter XXtestP {
                IndexDomain: (ixy);
                Property: NoSave;
            }
            ElementParameter _XXMill {
                Range: Destinations;
                Property: NoSave;
            }
            ElementParameter _XXMU {
                Range: ManagementUnits;
                Property: NoSave;
            }
            ElementParameter __x {
                Range: XYs;
                Property: NoSave;
                Definition: 'x';
            }
            ElementParameter __y {
                Range: XYs;
                Property: NoSave;
                Definition: 'y';
            }
            Parameter Min_X {
                Property: NoSave;
            }
            Parameter Min_Y {
                Property: NoSave;
            }
            Parameter Max_X {
                Property: NoSave;
            }
            Parameter Max_Y {
                Property: NoSave;
            }
            Set MapSides {
                Text: "The sides of a map";
                Index: iMS, iMS1;
                Parameter: _iMS;
                Property: NoSave;
                Definition: data { Left, Right, Top, Bottom };
            }
            Set MapCorners {
                Index: mc, mc1;
                Property: NoSave;
                Definition: data { 'BL' , 'BR' , 'TL' , 'TR' };
            }
            ElementParameter _WhichVisibleArea {
                Text: "Used to determine visible areas of different map types";
                Range: BLK_MapOptions;
                Property: NoSave;
            }
            Parameter Map_VisibleArea {
                IndexDomain: (bmo,mc,ixy);
                Property: NoSave;
                Definition: {
                    !if bmo = 'Mill' then
                    	{
                    	('Mill','BL','x')	:	VisibleArea_Mill('left'),
                    	('Mill','BL','y')	:	VisibleArea_Mill('bottom'),
                    
                    	('Mill','BR','x')	:	VisibleArea_Mill('right'),
                    	('Mill','BR','y')	:	VisibleArea_Mill('bottom'),
                    
                    
                    	('Mill','TL','x')		:	VisibleArea_Mill('left'),
                    	('Mill','TL','y')		:	VisibleArea_Mill('top'),
                    
                    	('Mill','TR','x')		:	VisibleArea_Mill('right'),
                    	('Mill','TR','y')		:	VisibleArea_Mill('top'),
                    !	}
                    !elseif bmo = 'MU' then
                    !	{
                    	('MU','BL','x')	:	VisibleArea_MU('left'),
                    	('MU','BL','y')	:	VisibleArea_MU('bottom'),
                    
                    	('MU','BR','x')	:	VisibleArea_MU('right'),
                    	('MU','BR','y')	:	VisibleArea_Mu('bottom'),
                    
                    
                    	('MU','TL','x')		:	VisibleArea_MU('left'),
                    	('MU','TL','y')		:	VisibleArea_MU('top'),
                    
                    	('MU','TR','x')		:	VisibleArea_MU('right'),
                    	('MU','TR','y')		:	VisibleArea_MU('top')
                    ,!	}
                    !elseif bmo = 'Block', then
                    !	{
                    	('Block','BL','x')	:	VisibleArea_BLK('left'),
                    	('Block','BL','y')	:	VisibleArea_BLK('bottom'),
                    
                    	('Block','BR','x')	:	VisibleArea_BLK('right'),
                    	('Block','BR','y')	:	VisibleArea_BLK('bottom'),
                    
                    
                    	('Block','TL','x')		:	VisibleArea_BLK('left'),
                    	('Block','TL','y')		:	VisibleArea_BLK('top'),
                    
                    	('Block','TR','x')		:	VisibleArea_BLK('right'),
                    	('Block','TR','y')		:	VisibleArea_BLK('top')
                    	}
                    !endif
                }
            }
            Parameter Map_VisibleArc {
                IndexDomain: (bmo,mc,mc1);
                Property: NoSave;
                Definition: {
                    {
                    ('Mill','BL', 'BR') : 1	,
                    ('Mill','BL', 'TL') : 1	,
                    ('Mill','TR', 'BR') : 1	,
                    ('Mill','TL', 'TR') : 1,
                    
                    ('Block','BL', 'BR') : 1	,
                    ('Block','BL', 'TL') : 1	,
                    ('Block','TR', 'BR') : 1	,
                    ('Block','TL', 'TR') : 1	,
                    
                    ('MU','BL', 'BR') : 1	,
                    ('MU','BL', 'TL') : 1	,
                    ('MU','TR', 'BR') : 1	,
                    ('MU','TL', 'TR') : 1
                    
                    
                    }
                }
            }
            Parameter VisibleArea_Default {
                IndexDomain: (iMS);
                Definition: {
                    
                    
                    /*
                    199962.1035
                    1646350.979
                    12811991.35
                    11963344.82
                    /**/
                }
            }
            Parameter MapEdit_On {
                Text: "Map is Read-only";
                Range: binary;
                Unit: 1;
                Default: 1;
                Property: NoSave;
            }
            DeclarationSection Map_Background_Declaration {
                StringParameter MapBackgroundImageFilename {
                    Default: "<prj>:MapInfo\\muBigger_BW.gif";
                }
                StringParameter TEST_MapBackgroundImageFilename {
                    Property: NoSave;
                    InitialData: "<prj>:MapInfo\\muBigger_BW.gif";
                }
            }
            DeclarationSection MapData {
                Set MapAllSources {
                    Index: MapSrc, MapSrc1;
                    Parameter: _MapSrc, _MapSrc_Sel;
                    Property: NoSave;
                }
                Set MapSourcesMU {
                    SubsetOf: MapAllSources;
                    Index: i_MapSrcMu;
                    Parameter: c_MapSrcMu;
                    Property: NoSave;
                    OrderBy: i_MapSrcMu;
                }
                Set MapSourcesMill {
                    SubsetOf: MapAllSources;
                    Property: NoSave;
                }
                Set ProductsToShowOnPage {
                    SubsetOf: AllProducts;
                    Index: gpr_map;
                    Property: NoSave;
                    Definition: Products $ MapShowProd + Residuals $ MapShowRes;
                }
                Set ALLProductGroupsToShowOnPage {
                    SubsetOf: AllProductGroups;
                    Index: gPrGrp_Map;
                    Parameter: _gPrGrp_Map;
                    Property: NoSave;
                    Definition: ProductGroups $ MapShowProd + ResidualGroups $ MapShowRes;
                }
                Set ProductGroupsToShowOnPage {
                    SubsetOf: AllProductGroups;
                    Index: gPrGrp_Map_Prod;
                    Property: NoSave;
                    Definition: ProductGroups $ MapShowProd;
                }
                Set ResidualGroupsToShowOnPage {
                    SubsetOf: AllProductGroups;
                    Index: gPrGrp_Map_Res;
                    Property: NoSave;
                    Definition: ResidualGroups $ MapShowRes;
                }
                Parameter cDestMapsrc {
                    IndexDomain: (MapSrc,dest);
                    Range: binary;
                    Property: NoSave;
                }
                Parameter ProductsToMap {
                    IndexDomain: (gPrGrp);
                    Range: binary;
                    Default: 1;
                    Property: NoSave;
                    Comment: "Populated from ProductsToMap_GUI";
                }
                Parameter ProductsToMap_GUI {
                    IndexDomain: (gPrGrp);
                    Range: binary;
                    Default: 1;
                    Property: NoSave;
                }
                Parameter TermsToMap {
                    IndexDomain: (term);
                    Range: binary;
                    Unit: 1;
                    Default: 1;
                    Property: NoSave;
                }
                Parameter TermsToMap_GUI {
                    IndexDomain: (term);
                    Range: binary;
                    Unit: 1;
                    Default: 1;
                    Property: NoSave;
                }
                StringParameter FilterButtonImage {
                    Property: NoSave;
                    Definition: {
                        if exists(term | TermsToMap(term)=0)
                        or exists(gprgrp | ProductsToMap(gPrGrp)=0)
                        then "<prj>:MyBitmaps\filter24_Active.png"	!"<prj>:filter24_red.png" 			!
                        else "<prj>:filter24_green.gif"			!"<prj>:MyBitmaps\filter24.png"		!
                        endif
                    }
                }
                Set MapQuantileColours_Ordered {
                    SubsetOf: MapQuantileColours;
                    Index: imqco, imqco2;
                    Property: NoSave;
                    OrderBy: ColourSetOrder(imqc);
                    Definition: {
                        { imqc }
                    }
                }
                Set MapQuantileColours {
                    SubsetOf: AllColors;
                    Index: imqc, imqc2;
                    Property: NoSave;
                    Definition: {
                        !data { red, green, blue, magenta,'dark grey', grey  }
                        data {Q1, Q2, Q3, Q4, Q5, Q6, NA, TooFar}
                        !+ data { 'dark grey' , cyan , blue , green, magenta,  red }
                    }
                }
                Set MapResidualColours {
                    SubsetOf: AllColors;
                    Index: mrc;
                    Property: NoSave;
                    Definition: {
                        !data { red, green, blue, magenta,'dark grey', grey  }
                        data { 'yellow' , cyan , brown  } +
                        data { Res1, Res2, Res3 }
                    }
                }
                ElementParameter ResidualColourRamp {
                    IndexDomain: (res);
                    Range: MapResidualColours;
                    Property: NoSave;
                }
                Parameter ColourSetOrder {
                    IndexDomain: (imqc);
                    Text: "Order of colours in set";
                    Range: integer;
                    Property: NoSave;
                    InitialData: {
                        {
                        'Q1': 1,
                        'Q2': 2,
                        'Q3': 3,
                        'Q4': 4,
                        'Q5': 5,
                        'Q6': 6
                        ,'NA': 7,
                        'TooFar': 8
                        }
                    }
                }
                Parameter GUIColourOrder {
                    IndexDomain: (imqco) | ord(imqco) <= NumberQuantiles;
                    Text: "Order of colors in GUI";
                    Range: integer;
                    Property: NoSave;
                    InitialData: {
                        !ColorSetOrder(imqc)
                    }
                }
                Parameter NumberQuantiles {
                    Range: {
                        {1..6}
                    }
                    Property: NoSave;
                    InitialData: 5;
                }
                ElementParameter LegendColourRamp {
                    IndexDomain: (imqco);
                    Range: MapQuantileColours_Ordered;
                    Property: NoSave;
                    Definition: {
                        if GUIColourOrder(imqco) >0 then
                        	first(imqco2 | FormatString("%i",ord(imqco)) = FormatString("%i",GUIColourOrder(imqco2)))
                        else
                        	last(imqco2)
                        endif
                    }
                }
                Parameter LegendColourProportion {
                    IndexDomain: {
                        (imqco)! | ord(imqc) <= NumberQuantiles
                    }
                    Range: nonnegative;
                    Unit: %;
                    Property: NoSave;
                    Definition: {
                        ColourSetOrder(imqco) / 6!NumberQuantiles
                    }
                }
                Parameter MapShowProd {
                    Range: binary;
                    Default: 1;
                    Property: NoSave;
                }
                Parameter MapShowRes {
                    Range: binary;
                    Default: 1;
                    Property: NoSave;
                }
                Set GUIMinimumVolumesToMap {
                    SubsetOf: Integers;
                    Index: iGUIvtm;
                    Property: NoSave;
                    Definition: {
                        {0,1,2,5,10,15,25,50}
                    }
                }
                ElementParameter _iGUIvtm {
                    Range: GUIMinimumVolumesToMap;
                    Property: NoSave;
                    InitialData: 1;
                }
                Parameter MinimumVolumeToMap {
                    Text: "Min Vol shown";
                    Range: nonnegative;
                    Unit: m3;
                    Default: 1;
                    Property: NoSave;
                }
            }
            DeclarationSection FromMUMap {
                Parameter FromMU_DeliveredMUVolume {
                    IndexDomain: (MapSrc,dest);
                    Unit: k_m3;
                    Property: NoSave;
                    Definition: sum[( PrGrp ),DeliveredMUVolumeToMap_Detail( MapSrc, dest, PrGrp )] $ MapShowProd;
                }
                Parameter FromMU_DeliveredResVolume {
                    IndexDomain: (MapSrc,dest);
                    Unit: k_ODT;
                    Property: NoSave;
                    Definition: sum[( ResGrp ),DeliveredMUVolumeToMap_Detail( MapSrc, dest, ResGrp )] $ MapShowRes;
                }
            }
            Procedure UpdateProductsToMap {
                Body: {
                    ProductsToMap(gPrGrp) := ProductsToMap_GUI(gPrGrp);
                    
                    TermsToMap(term) := TermsToMap_GUI(term);
                }
            }
            Procedure ResetProductsToMap {
                Body: {
                    ProductsToMap_GUI(gPrGrp) := 1;
                    
                    TermsToMap_GUI(term) := 1;
                }
            }
            Procedure UpdateMinimumVolumeToMap {
                Body: {
                    if _iGUIvtm <> '' then
                       MinimumVolumeToMap := (val(_iGUIvtm)) [k_m3] ; endif;
                }
            }
            Procedure ZoomToFullExtent {
                Body: {
                    !ActivePageName is set by Zoom ToExtent button because there's no way to retrieve the name of the map in the tagged object
                    !PageGetFocus(page : ActivePageName,tag: ActivePageTagName);
                    !
                    
                    PageGetActive(page : ActivePageName);
                    
                    if exists(ims | not VisibleArea_Default(iMS)) then
                    	InitializeVisibleArea;
                    endif;
                    
                    if FindString(SearchString : ActivePageName,Key : "Accessible",0) <> 0 then
                    	VisibleArea_Accessible(iMS) := VisibleArea_Default(iMS);
                    elseif FindString(SearchString : ActivePageName,Key : "Mill",0) <> 0 then
                    	VisibleArea_Mill(iMS) := VisibleArea_Default(iMS);
                    elseif FindString(SearchString : ActivePageName,Key : "MU",0) <> 0 then
                    	VisibleArea_MU(iMS) := VisibleArea_Default(iMS);
                    elseif FindString(SearchString : ActivePageName,Key : "BLK",0) <> 0 then
                    	VisibleArea_BLK(iMS) := VisibleArea_Default(iMS);
                    elseif FindString(SearchString : ActivePageName,Key : "Primary",0) <> 0 then
                    	VisibleArea_BLK(iMS) := VisibleArea_Default(iMS);
                    elseif FindString(SearchString : ActivePageName,Key : "Zone",0) <> 0
                    		or FindString(SearchString : ActivePageName,Key : "Curve",0) <> 0 then
                    	VisibleArea_Accessible(iMS) := VisibleArea_Default(iMS);
                    else
                    	halt "ZoomToFullExtent: Cannot Determine Active Map name";
                    endif;
                }
            }
            Procedure ReadWriteXYdata {
                Body: {
                    switch (DialogAsk("What do you want to do with XY data?",button1:"Read",button2:"Write",title:"Enter Option") ) do
                    	1:
                    		read muxy,millxy from file "<prj>:MapInfo\\XYdata.txt";
                    	2:
                    		write muxy,millxy to file "<prj>:MapInfo\\XYdata.txt";
                    	default:
                    		return 0;
                    endswitch;
                    
                    return 1;
                }
            }
            Procedure ResetMapEditMode {
                Body: {
                    empty MapEdit_On;
                }
            }
            Procedure ApplyColourOrder {
                Body: {
                    ! Executed after ColorOrder has been modified in GUI
                    ColourSetOrder(imqco | ord(imqco) <= NumberQuantiles) := GUIColourOrder(imqco);
                }
            }
            DeclarationSection ToMillMapData {
                Parameter VisibleArea_Mill {
                    IndexDomain: (iMS);
                }
                ElementParameter _MillToMap {
                    Range: DestinationsReceivingWood;
                    Property: NoSave;
                    Definition: {
                        !if Current_Mill then Current_mill
                        !else last(DestinationsReceivingWood) endif
                    }
                }
                Set DestinationsReceivingWood {
                    SubsetOf: Destinations_Sorted;
                    Text: "Destinations Receiving Wood";
                    Index: RcvDest;
                    Property: NoSave;
                    OrderBy: dest_sort;
                    Definition: {
                        {dest_sort | sum ((MapSrc,gPrGrp), DeliveredVolumeToAndFromDest(MapSrc,dest_sort,gPrGrp) ) }
                    }
                }
                Parameter Sel_ShowRobustSolution {
                    Text: "Show Robust Solution";
                    Range: binary;
                    Property: NoSave;
                    Comment: "Used to toggle between Robust and Level values in mapping";
                }
                Parameter DeliveredBlockVolume_RO {
                    IndexDomain: {
                        (term,blk,prd,dest,gPrGrp) |
                         if Sel_ShowRobustSolution then DeliveredBlockVolume_VAR.robust (term,blk,prd,dest,gPrGrp)
                        else DeliveredBlockVolume_VAR (term,blk,prd,dest,gPrGrp)
                        endif
                    }
                    Unit: ProductUnit(prd);
                    Property: NoSave;
                    Definition: {
                        if Sel_ShowRobustSolution then
                        	DeliveredBlockVolume_VAR.robust (term,blk,prd,dest,gPrGrp)
                        else DeliveredBlockVolume_VAR(term,blk,prd,dest,gPrGrp)
                        endif
                    }
                }
                Parameter DeliveredResidualVolume_RO {
                    IndexDomain: (term,destFrom,res,dest,gPrGrp) | DeliveredResidualVolume_VAR(term,destfrom,res,dest,gPrGrp);
                    Range: nonnegative;
                    Unit: ProductUnit(res);
                    Property: NoSave;
                    Definition: {
                         if Sel_ShowRobustSolution then
                        	DeliveredResidualVolume_VAR.robust(term,destfrom,res,dest,gPrGrp)
                        else
                        	DeliveredResidualVolume_VAR (term,destfrom,res,dest,gPrGrp)
                        endif
                    }
                }
                Parameter DeliveredVolumeToAndFromDest {
                    IndexDomain: (mapsrc,dest,gPrGrp) |  ProductsToMap(gPrGrp);
                    Text: "Master Table of all wood flows";
                    Unit: ProductGroupUnit_k(gPrGrp);
                    Property: NoSave;
                    Definition: {
                        !sum [ (mu) | cMuMapmu(MapSrc,mu),	DeliveredVolumeToMap(mu,dest)]
                        
                        !Note: An error (Units are not commensurate) will result if some product groups have no units
                        ! 		Check ProductGroupUnit() data to find missing values
                        
                        ! Volume from blocks
                        sum [(mu,term,blk,prd)  | MU_Block_Relation(mu,blk) and cMuMapmu(MapSrc,mu)
                        	and TermsToMap(term) and cPrG(gPrGrp,prd)
                        	, DeliveredBlockVolume_RO(term,blk,prd,dest,gPrGrp) ]
                        +
                        ! Residue FROM Destinations
                        sum [ (term,destfrom,res) |  cDestMapsrc(MapSrc,destfrom) and TermsToMap(term) and cPrG(gPrGrp,res)
                        	,DeliveredResidualVolume_RO(term,destfrom,res,dest,gPrGrp)  ]
                    }
                }
                Parameter DeliveredVolumeToMap {
                    IndexDomain: (mu,dest) | dest = _MillToMap;
                    Unit: 1000 * _ProductDefaultUnit;
                    Property: NoSave;
                    Definition: {
                        !sum [(term,gPrGrp),DeliveredAllVolume_PrGrp]
                        
                        sum [(term,blk,prd,gPrGrp) | MU_Block_Relation(mu,blk)
                        	, DeliveredBlockVolume_RO(term,blk,prd,dest,gPrGrp) $ cPrG(gPrGrp,prd)
                        ]
                    }
                }
                Parameter DeliveredVolumeToMapNEW {
                    IndexDomain: {
                        (mapsrc,dest) | dest = _MillToMap
                        or FormatString("%e",_MillToMap) = FormatString("%e",mapsrc)
                    }
                    Unit: 1000 * _ProductDefaultUnit;
                    Property: NoSave;
                    Definition: {
                        !sum [ (mu) | cMuMapmu(MapSrc,mu),	DeliveredVolumeToMap(mu,dest)]
                        
                        sum [(mu,term,blk,prd,gPrGrp)  | MU_Block_Relation(mu,blk) and cMuMapmu(MapSrc,mu) and ProductsToMap(gPrGrp)
                        	, DeliveredBlockVolume_RO(term,blk,prd,dest,gPrGrp) $ cPrG(gPrGrp,prd)]
                        +
                        sum [ (term,destfrom,res,gPrGrp) |  cDestMapsrc(MapSrc,destfrom) and ProductsToMap(gPrGrp)
                        	,DeliveredResidualVolume_RO(term,destfrom,res,dest,gPrGrp) ]
                    }
                }
                Parameter DeliveredVolumeToMapPROD {
                    IndexDomain: {
                        (mapsrc,dest) | dest = _MillToMap !and formatstring("%e",current_mu) = formatstring("%e",mapsrc)
                        and MapShowProd
                    }
                    Unit: 1000 * _ProductDefaultUnit;
                    Property: NoSave;
                    Definition: sum [(PrGrp), DeliveredVolumeToMapNEW_Detail(MapSrc,dest,PrGrp)];
                }
                Parameter DeliveredVolumeToMapRES {
                    IndexDomain: {
                        (mapsrc,dest) | dest = _MillToMap !and formatstring("%e",current_mu) = formatstring("%e",mapsrc)
                        and MapShowRES
                    }
                    Unit: 1000 * _ResidualDefaultUnit;
                    Property: NoSave;
                    Definition: {
                        !sum [ (mu) | cMuMapmu(MapSrc,mu),	DeliveredVolumeToMap(mu,dest)]
                        
                        	sum [(ResGrp), DeliveredVolumeToMapNEW_Detail(MapSrc,dest,ResGrp)]
                    }
                }
                Parameter DeliveredVolumeToMapRESSent {
                    IndexDomain: {
                        (mapsrc,dest) | formatstring("%e",_MillToMap) = formatstring("%e",mapsrc)
                        and MapShowRES
                    }
                    Unit: 1000 * _ResidualDefaultUnit;
                    Property: NoSave;
                    Definition: {
                        !sum [ (mu) | cMuMapmu(MapSrc,mu),	DeliveredVolumeToMap(mu,dest)]
                        
                        	sum [(ResGrp), DeliveredVolumeToMapNEW_Detail(MapSrc,dest,ResGrp)]
                    }
                }
                Parameter DeliveredVolumeToMapNEW_Detail {
                    IndexDomain: {
                        (mapsrc,dest,gPrGrp) |( dest = _MillToMap                    ! flow to Current Mill
                        or FormatString("%e",_MillToMap) = FormatString("%e",mapsrc) )! flow leaving Current_Mill
                        and DeliveredVolumeToAndFromDest(MapSrc,dest,gPrGrp) >= MinimumVolumeToMap
                    }
                    Unit: 1000 * ProductGroupUnit(gPrGrp);
                    Property: NoSave;
                    Definition: {
                        !sum [ (mu) | cMuMapmu(MapSrc,mu),	DeliveredVolumeToMap(mu,dest)]
                        
                        DeliveredVolumeToAndFromDest(MapSrc,dest,gPrGrp)
                        /* !OLD
                        sum [(mu,term,blk,prd)  | MU_Block_Relation(mu,blk) and cMuMapmu(MapSrc,mu) and ProductsToMap(gPrGrp)
                        	, DeliveredBlockVolume_VAR(term,blk,prd,dest,gPrGrp) $ cPrG(gPrGrp,prd)]
                        +
                        sum [ (term,destfrom,res) |  cDestMapsrc(MapSrc,destfrom) and ProductsToMap(gPrGrp)
                        	,DeliveredResidualVolume_VAR(term,destfrom,res,dest,gPrGrp) $ cPrG(gPrGrp,res) ]
                        	/**/
                    }
                }
                Parameter ProportionDeliveredVolumeToMap {
                    IndexDomain: (mu,dest) | dest = _MillToMap;
                    Unit: 1;
                    Property: NoSave;
                    Definition: DeliveredVolumeToMap(mu,dest) /$ sum [(mu1), DeliveredVolumeToMap(mu1,dest)];
                }
                Parameter ProportionDeliveredVolumeToMapNEw {
                    IndexDomain: (MapSrc,dest)| dest = _MillToMap;
                    Property: NoSave;
                    Definition: DeliveredVolumeToMapNEW(MapSrc,dest) /$ sum [(MapSrc1), DeliveredVolumeToMapNEW(MapSrc1,dest)];
                }
                StringParameter SourcesOfResiduals_txt {
                    IndexDomain: {
                        MapSrc | mapsrc in MapSourcesMill
                        and sum[dest,DeliveredVolumeToMapRES(MapSrc,dest)]
                    }
                    Property: NoSave;
                    Definition: FormatString( "%e",mapsrc );
                }
                Parameter sel_MillXy {
                    IndexDomain: {
                        (dest,ixy) | dest = _MillToMap
                        or sum[MapSrc, DeliveredVolumeToMapRESSent(MapSrc,dest)]
                    }
                    Property: NoSave;
                    Definition: Millxy(dest,ixy);
                }
                ElementParameter DeliveryColourRamp {
                    IndexDomain: (mu,dest);
                    Range: MapQuantileColours_Ordered;
                    Property: NoSave;
                    Definition: first(imqco | (ord(imqco) =  Ceil(ProportionDeliveredVolumeToMap(mu,dest) * NumberQuantiles)));
                }
                ElementParameter DeliveryColourRampNEW {
                    IndexDomain: (MapSrc,dest);
                    Range: MapQuantileColours_Ordered;
                    Property: NoSave;
                    Definition: first(imqco | (ord(imqco) =  Ceil(ProportionDeliveredVolumeToMapNEw(MapSrc,dest) * NumberQuantiles)));
                }
            }
            Procedure ZoomToDeliverExtent {
                Body: {
                    /* set map extent to be the same as the supply are for the _MillToMap
                    /**/
                    !DebuggerBreakpoint;
                    !--- Check that mill has supply
                    if count( mu | DeliveredVolumeToMap(mu,_MillToMap)) < 1 then
                    	DialogMessage(FormatString("%e received no wood",_MillToMap),"Nothing to map");
                    	return 1;
                    endif;
                    empty NewExtent;
                    !--- get extent of current visible area
                    CurrentExtent(iMS) := VisibleArea_Mill(iMS);
                    !-- get ratio of height to width
                    SideRatio := [CurrentExtent('top') - CurrentExtent('bottom')] /$ [CurrentExtent('right') - CurrentExtent('left')];
                    
                    !-- calculate extent of supply area ... from supplying mu'nsm::s'
                    NewExtent('Top') 	:= max[ (mu) | DeliveredVolumeToMap(mu,_MillToMap), MUxy(mu,'y') ];
                    NewExtent('Bottom') := min[ (mu) | DeliveredVolumeToMap(mu,_MillToMap), MUxy(mu,'y') ];
                    NewExtent('Right') 	:= max[ (mu) | DeliveredVolumeToMap(mu,_MillToMap), MUxy(mu,'x') ];
                    NewExtent('left') 	:= min[ (mu) | DeliveredVolumeToMap(mu,_MillToMap), MUxy(mu,'x') ];
                    
                    ! ... and target mill
                    if NewExtent('Top')    < Millxy(_MillToMap,'y') then NewExtent('Top') 	:= Millxy(_MillToMap,'y') endif;
                    if NewExtent('Bottom') > Millxy(_MillToMap,'y') then NewExtent('Bottom'):= Millxy(_MillToMap,'y') endif;
                    if NewExtent('Right')  < Millxy(_MillToMap,'x') then NewExtent('Right') := Millxy(_MillToMap,'x') endif;
                    if NewExtent('Left')   > Millxy(_MillToMap,'x') then NewExtent('left') 	:= Millxy(_MillToMap,'x') endif;
                    
                    !--make extent 10% larger
                    !Buffer := [NewExtent('top') - NewExtent('bottom')] / 10;
                    !NewExtent(ims | ims='Top' or ims = 'Right') +=  Buffer;
                    !NewExtent(ims | ims='Left' or ims = 'Bottom') -=  Buffer;
                    IncreaseExtent(	NewExtent , 110 [%]);
                    
                    !-- adjust ratio Height =  Width * Sideratio
                    NewSideRatio := [NewExtent('top') - NewExtent('bottom')] /$ [NewExtent('right') - NewExtent('left')];
                    
                    if NewSideRatio > SideRatio  then
                    	!not wide enough:  stretch right Width = Height / SideRatio
                    	NewExtent('right') := NewExtent('left') + [NewExtent('top') - NewExtent('bottom')] / SideRatio;
                    else ! too tall:  stretch bottom Height =  Width * SideRatio
                    	NewExtent('Bottom') := NewExtent('Top') - [NewExtent('right') - NewExtent('left')] * SideRatio;
                    endif;
                    
                    !-- set visible area to new extent
                    VisibleArea_Mill(iMS) := NewExtent(iMS);
                }
                Parameter CurrentExtent {
                    IndexDomain: (iMS);
                }
                Parameter NewExtent {
                    IndexDomain: (iMS);
                }
                Parameter SideRatio;
                Parameter NewSideRatio;
                Parameter Buffer;
            }
            Procedure ZoomToDeliverExtent_Mill {
                Body: {
                    /* set map extent to be the same as the supply are for the _MillToMap
                    /**/
                    !DebuggerBreakpoint;
                    !--- Check that mill has supply
                    if count( MapSrc | DeliveredVolumeToMapNEW(MapSrc,_MillToMap)) < 1 then
                    	DialogMessage(FormatString("%e received no wood",_MillToMap),"Nothing to map");
                    	return 1;
                    endif;
                    empty NewExtent;
                    !--- get extent of current visible area
                    CurrentExtent(iMS) := VisibleArea_Mill(iMS);
                    !-- get ratio of height to width
                    SideRatio := [CurrentExtent('top') - CurrentExtent('bottom')] /$ [CurrentExtent('right') - CurrentExtent('left')];
                    
                    !-- calculate extent of supply area ... from supplying sources
                    !DebuggerBreakpoint;
                    if MapShowProd and MapShowRes then
                    	NewExtent('Top') 	:= max[ (MapSrc,dest) | DeliveredVolumeToMapNEW(MapSrc,dest), MapAllSourcexy(MapSrc,'y') ];
                    	NewExtent('Bottom') := min[ (MapSrc,dest) | DeliveredVolumeToMapNEW(MapSrc,dest), MapAllSourcexy(MapSrc,'y') ];
                    	NewExtent('Right') 	:= max[ (MapSrc,dest) | DeliveredVolumeToMapNEW(MapSrc,dest), MapAllSourcexy(MapSrc,'x') ];
                    	NewExtent('left') 	:= min[ (MapSrc,dest) | DeliveredVolumeToMapNEW(MapSrc,dest), MapAllSourcexy(MapSrc,'x') ];
                    elseif MapShowProd then
                    	NewExtent('Top') 	:= max[ (MapSrc) | DeliveredVolumeToMapPROD(MapSrc,_MillToMap), MapAllSourcexy(MapSrc,'y') ];
                    	NewExtent('Bottom') := min[ (MapSrc) | DeliveredVolumeToMapPROD(MapSrc,_MillToMap), MapAllSourcexy(MapSrc,'y') ];
                    	NewExtent('Right') 	:= max[ (MapSrc) | DeliveredVolumeToMapPROD(MapSrc,_MillToMap), MapAllSourcexy(MapSrc,'x') ];
                    	NewExtent('left') 	:= min[ (MapSrc) | DeliveredVolumeToMapPROD(MapSrc,_MillToMap), MapAllSourcexy(MapSrc,'x') ];
                    else ! show only residuals
                    	NewExtent('Top') 	:= max[ (MapSrc) | DeliveredVolumeToMapRES(MapSrc,_MillToMap), MapAllSourcexy(MapSrc,'y') ];
                    	NewExtent('Bottom') := min[ (MapSrc) | DeliveredVolumeToMapRES(MapSrc,_MillToMap), MapAllSourcexy(MapSrc,'y') ];
                    	NewExtent('Right') 	:= max[ (MapSrc) | DeliveredVolumeToMapRES(MapSrc,_MillToMap), MapAllSourcexy(MapSrc,'x') ];
                    	NewExtent('left') 	:= min[ (MapSrc) | DeliveredVolumeToMapRES(MapSrc,_MillToMap), MapAllSourcexy(MapSrc,'x') ];
                    endif;
                    
                    ! ... and target mill
                    if NewExtent('Top')    < Millxy(_MillToMap,'y') then NewExtent('Top') 	:= Millxy(_MillToMap,'y') endif;
                    if NewExtent('Bottom') > Millxy(_MillToMap,'y') then NewExtent('Bottom'):= Millxy(_MillToMap,'y') endif;
                    if NewExtent('Right')  < Millxy(_MillToMap,'x') then NewExtent('Right') := Millxy(_MillToMap,'x') endif;
                    if NewExtent('Left')   > Millxy(_MillToMap,'x') then NewExtent('left') 	:= Millxy(_MillToMap,'x') endif;
                    
                    ! ... and residual destinations
                    if MapShowRes then
                    	_mapsrc := First(MapSrc | FormatString("%e",mapsrc) = FormatString("%e",_MillToMap));
                    	if NewExtent('Top') < max[ (dest) | DeliveredVolumeToMapNEW(_MapSrc,dest), Millxy(dest,'y') ]
                    		then Newextent('Top') := max[ (dest) | DeliveredVolumeToMapNEW(_MapSrc,dest), Millxy(dest,'y') ]; endif;
                    	if NewExtent('Bottom') > min[ (dest) | DeliveredVolumeToMapNEW(_MapSrc,dest), Millxy(dest,'y') ]
                    		then NewExtent('Bottom') := min[ (dest) | DeliveredVolumeToMapNEW(_MapSrc,dest), Millxy(dest,'y') ]; endif;
                    	if NewExtent('Right') 	<  max[ (dest) | DeliveredVolumeToMapNEW(_MapSrc,dest), Millxy(dest,'x') ]
                    		then NewExtent('Right') := max[ (dest) | DeliveredVolumeToMapNEW(_MapSrc,dest), Millxy(dest,'x') ]; endif;
                    	if NewExtent('left') 	> min[ (dest) | DeliveredVolumeToMapNEW(_MapSrc,dest), Millxy(dest,'x') ]
                    		then NewExtent('left') 	:= min[ (dest) | DeliveredVolumeToMapNEW(_MapSrc,dest), Millxy(dest,'x') ]; endif;
                    endif;
                    
                    !--make extent 10% larger
                    !Buffer := [NewExtent('top') - NewExtent('bottom')] / 10;
                    !NewExtent(ims | ims='Top' or ims = 'Right') +=  Buffer;
                    !NewExtent(ims | ims='Left' or ims = 'Bottom') -=  Buffer;
                    IncreaseExtent(NewExtent,110 [%]);
                    
                    !-- adjust ratio Height =  Width * Sideratio
                    NewSideRatio := [NewExtent('top') - NewExtent('bottom')] /$ [NewExtent('right') - NewExtent('left')];
                    
                    if SideRatio >0 and  NewSideRatio > SideRatio  then
                    	!not wide enough:  stretch right Width = Height / SideRatio
                    	NewExtent('right') := NewExtent('left') + [NewExtent('top') - NewExtent('bottom')] / SideRatio;
                    else ! too tall:  stretch bottom Height =  Width * SideRatio
                    	NewExtent('Bottom') := NewExtent('Top') - [NewExtent('right') - NewExtent('left')] * SideRatio;
                    endif;
                    
                    !-- set visible area to new extent
                    VisibleArea_Mill(iMS) := NewExtent(iMS);
                }
                Parameter CurrentExtent {
                    IndexDomain: (iMS);
                }
                Parameter NewExtent {
                    IndexDomain: (iMS);
                }
                Parameter SideRatio;
                Parameter NewSideRatio;
                Parameter Buffer;
            }
            DeclarationSection FromMUMapData {
                Parameter VisibleArea_MU {
                    IndexDomain: (iMS);
                    InitialData: {
                        { 'left' :-97 , 'right': -74, 'top': 54, 'bottom': 43 }
                    }
                }
                Parameter DeliveredVolumeMapSrcToDest {
                    IndexDomain: (mapsrc,dest,gPrGrp);
                    Unit: ProductGroupUnit_k(gPrGrp);
                    Property: NoSave;
                    Definition: {
                        !sum [ (mu) | cMuMapmu(MapSrc,mu),	DeliveredVolumeToMap(mu,dest)]
                        
                        sum [(mu,term,blk,prd)  | MU_Block_Relation(mu,blk) and cMuMapmu(MapSrc,mu)
                        	and TermsToMap(term) !and ProductsToMap(gPrGrp)
                        	, DeliveredBlockVolume_RO(term,blk,prd,dest,gPrGrp) $ cPrG(gPrGrp,prd)]
                        +
                        sum [ (term,destfrom,res) |  cDestMapsrc(MapSrc,destfrom) !and ProductsToMap(gPrGrp)
                        	and TermsToMap(term)
                        	,DeliveredResidualVolume_RO(term,destfrom,res,dest,gPrGrp) $ cPrG(gPrGrp,res) ]
                    }
                }
                Parameter DeliveredVolumeMapSrcToDest_term {
                    IndexDomain: (term,mapsrc,dest,gPrGrp);
                    Unit: ProductGroupUnit_k(gPrGrp);
                    Property: NoSave;
                    Definition: {
                        !sum [ (mu) | cMuMapmu(MapSrc,mu),	DeliveredVolumeToMap(mu,dest)]
                        
                        sum [(mu,blk,prd)  | MU_Block_Relation(mu,blk) and cMuMapmu(MapSrc,mu) !and ProductsToMap(gPrGrp)
                        	, DeliveredBlockVolume_VAR(term,blk,prd,dest,gPrGrp) $ cPrG(gPrGrp,prd)]
                        +
                        sum [ (destfrom,res) |  cDestMapsrc(MapSrc,destfrom) !and ProductsToMap(gPrGrp)
                        	,DeliveredResidualVolume_VAR(term,destfrom,res,dest,gPrGrp) $ cPrG(gPrGrp,res) ]
                    }
                }
                Set TermsWoodReceived {
                    IndexDomain: dest_sort;
                    SubsetOf: Periods;
                    Property: NoSave;
                    OrderBy: term;
                    Definition: {
                        { term | exists((mapsrc, gprgrp) | DeliveredVolumeMapSrcToDest_term(term, MapSrc, dest_sort, gPrGrp) )}
                    }
                }
                Parameter TermsWoodReceived2 {
                    IndexDomain: (dest_sort,term);
                    Range: binary;
                    Property: NoSave;
                    Definition: 1 $ exists((mapsrc, gprgrp) | DeliveredVolumeMapSrcToDest_term(term, MapSrc, dest_sort, gPrGrp) );
                }
                Parameter DeliveredMUVolumeToMap_Detail {
                    IndexDomain: {
                        (MapSrc,dest,gPrGrp) | ProductsToMap(gPrGrp)
                        and DeliveredVolumeToAndFromDest(MapSrc,dest,gPrGrp) > MinimumVolumeToMap
                        !and mapsrc = c_MapSrcMu               ! flow from selected MU
                        !or (! gprgrp in ResidualGroups and
                        !sum[prd, ResidualsProduced(dest,prd,gprgrp)]           ! dest produces gPrGrp
                        !)
                    }
                    Text: "Direct and indirect flow from Current_MU";
                    Unit: ProductGroupUnit_k(gPrGrp);
                    Property: NoSave;
                    Definition: {
                        ! dest = Current_Mill                    ! flow to Current Mill
                        !or formatstring("%e",Current_Mill) = formatstring("%e",mapsrc) ! flow leaving Current_Mill
                        
                        
                        if mapsrc =  c_MapSrcMu        then      ! flow from selected MU
                        	DeliveredVolumeMapSrcToDest(MapSrc,dest,gPrGrp)
                        
                        !Flow of residuals from dest to other mills
                        ! ie. DestTo is a MapSrc that receives wood from c_MapSrcMu
                        elseif  sum[(DestTo) |  cDestMapsrc(MapSrc,DestTo), DestReceivesWoodFromC_MapSrcMu_Vol(DestTo)  > MinimumVolumeToMap ]
                        then
                        !	all residual sent from DestTo to other mills
                        	sum [ (DestTo) |  cDestMapsrc(MapSrc,DestTo) , DeliveredVolumeMapSrcToDest(MapSrc,dest,gPrGrp) ]
                        
                        	!  Warning: *** We really want only the portion associated with c_MapSrcMu
                        	! so multiply by
                        	! (Volume From c_MapSrcMu Converted to gPrGrp) / ((Volume From all MUs Converted to gPrGrp)
                        endif
                    }
                }
                Parameter ProportionOfVolumeConverted {
                    IndexDomain: {
                        (MapSrc,dest,gPrGrp) | ProductsToMap(gPrGrp)
                        and mapsrc <>  c_MapSrcMu
                        and sum[ (DestTo) |  cDestMapsrc(MapSrc,DestTo) , DestReceivesWoodFromC_MapSrcMu_Vol(DestTo) ]
                        and sum [(DestTo) |  cDestMapsrc(MapSrc,DestTo) , DeliveredVolumeMapSrcToDest(MapSrc,dest,gPrGrp) ]
                    }
                    Property: NoSave;
                    Definition: {
                        ! (Volume From c_MapSrcMu Converted to gPrGrp)
                        !  Warning: Need to fix this
                        !/ ((Volume From all MUs Converted to gPrGrp)
                        !sum[(term),Temp_DeliveredResidualVolume_PrGrp(term,destfrom,DestTo,ResGrp)]
                        
                        +1
                    }
                }
                Parameter Temp_DeliveredBlockVolume_PrGrp {
                    IndexDomain: (destFrom,DestTo,ResGrp)| ResidualsUsed_PrGrp(DestTo,ResGrp);
                    Text: "Volume of residual ResGrp deliered to DestTo from DestFrom in term";
                    Range: nonnegative;
                    Unit: ProductGroupUnit(ResGrp);
                    Property: NoSave;
                    Definition: {
                        !  Warning: Need to fix this
                        sum [(term,Res), DeliveredBlockVolume_VAR(term,destFrom,res,DestTo,ResGrp)]
                        !sum((destFrom,res), DeliveredResidualVolume(term,destFrom,DestTo,res) $ cPrG(ResGrp,res))
                    }
                    Comment: "prd is primary product (not residuals)";
                }
                Parameter DeliveredMUVolumeToMap_PROD {
                    IndexDomain: {
                        (MapSrc,dest,PrGrp) |DeliveredMUVolumeToMap_Detail(MapSrc,dest,PrGrp)
                        !and mapsrc = c_MapSrcMu               ! flow from selected MU
                        !or (! gprgrp in ResidualGroups and
                        !sum[prd, ResidualsProduced(dest,prd,gprgrp)]           ! dest produces gPrGrp
                        !)
                    }
                    Text: "Direct and indirect flow from Current_MU";
                    Unit: ProductGroupUnit_k(PrGrp);
                    Property: NoSave;
                    Definition: DeliveredMUVolumeToMap_Detail(MapSrc,dest,PrGrp);
                }
                Parameter DeliveredMUVolumeToMap_RES {
                    IndexDomain: {
                        (MapSrc,dest,ResGrp) |DeliveredMUVolumeToMap_Detail(MapSrc,dest,ResGrp)
                        !and mapsrc = c_MapSrcMu               ! flow from selected MU
                        !or (! gprgrp in ResidualGroups and
                        !sum[prd, ResidualsProduced(dest,prd,gprgrp)]           ! dest produces gPrGrp
                        !)
                    }
                    Text: "Direct and indirect flow from Current_MU";
                    Unit: ProductGroupUnit_k(ResGrp);
                    Property: NoSave;
                    Definition: DeliveredMUVolumeToMap_Detail(MapSrc,dest,ResGrp);
                }
                Parameter cMuMapmu {
                    IndexDomain: (MapSrc,mu);
                    Range: binary;
                    Property: NoSave;
                    Comment: "initialized in InitializeAllSourcesMU";
                }
                Parameter DestReceivesWoodFromC_MapSrcMu_Vol {
                    IndexDomain: (dest);
                    Range: nonnegative;
                    Unit: 1000 * m3;
                    Property: NoSave;
                    Definition: {
                        
                        sum[(mapsrc,gprgrp) | mapsrc = c_MapSrcMU and ProductsToMap(gPrGrp)
                        ,DeliveredVolumeMapSrcToDest(MapSrc,dest,gPrGrp)]
                    }
                }
                Parameter sel_MUMillXy {
                    IndexDomain: {
                        (dest,ixy) | dest = _MillToMap
                        or sum[ (MapSrc,gPrGrp), DeliveredMUVolumeToMap_Detail(MapSrc,dest,gPrGrp)]
                    }
                    Text: "Mill receiving wood directly or indirectly from c_MapSrcMu";
                    Property: NoSave;
                    Definition: Millxy(dest,ixy);
                }
                Parameter sel_MuXy {
                    IndexDomain: (mu,ixy) | formatstring("%e",mu) = FormatString("%e", c_MapSrcMu);
                    Property: NoSave;
                    Definition: Muxy(mu,ixy);
                }
                Parameter ProportionMUDeliveredVolumeToMap {
                    IndexDomain: (MapSrc,dest)| MapSrc = c_MapSrcMu;
                    Property: NoSave;
                    Definition: {
                        sum[ (PrGrp),DeliveredMUVolumeToMap_Detail(MapSrc,dest,PrGrp) ]
                        /$ sum [(dest1,PrGrp), DeliveredMUVolumeToMap_Detail(MapSrc,dest1,PrGrp) ]
                    }
                }
                ElementParameter MUDeliveryColourRamp {
                    IndexDomain: (MapSrc,dest) | mapSrc = c_MapSrcMu;
                    Range: MapQuantileColours_Ordered;
                    Property: NoSave;
                    Definition: {
                        !if MapSrc = _MapSrc_Sel and dest = _Dest_Sel then 'Grid Focus' else
                        first(imqco | (ord(imqco) =  Ceil(ProportionMUDeliveredVolumeToMap(MapSrc,dest) * NumberQuantiles)))
                        !endif
                    }
                }
            }
            Procedure ZoomToDeliverExtent_MU {
                Body: {
                    /* set map extent to be the same as the supply are for the _MillToMap
                    /**/
                    !--- Check that mill has supply
                    !DebuggerBreakpoint;
                    MapSourceAndDest(MapSrc,dest) := 999;
                    if (count( (MapSrc,dest) | MapSourceAndDest(MapSrc,dest)) < 1  )
                    	or (MapShowProd=0 and MapShowRes =0) then
                    	DialogMessage("Nothing to map");
                    	return 1;
                    endif;
                    empty NewExtent;
                    !--- get extent of current visible area
                    CurrentExtent(iMS) := VisibleArea_Mill(iMS);
                    !-- get ratio of height to width
                    SideRatio := [CurrentExtent('top') - CurrentExtent('bottom')] /$ [CurrentExtent('right') - CurrentExtent('left')];
                    
                    !-- calculate extent of supply area ... from supplying sources
                    !DebuggerBreakpoint;
                    NewExtent('Top') 	:= max[ (MapSrc,dest) | MapSourceAndDest(MapSrc,dest), MapAllSourcexy(MapSrc,'y') ];
                    NewExtent('Top') 	:= max( max[ (MapSrc,dest) | MapSourceAndDest(MapSrc,dest), MapAllSourcexy(MapSrc,'y') ]
                    							,max[ (mapsrc,dest) | MapSourceAndDest(MapSrc,dest), Millxy(dest,'y') ] );
                    NewExtent('Bottom') 	:= min( min[ (MapSrc,dest) | MapSourceAndDest(MapSrc,dest), MapAllSourcexy(MapSrc,'y') ]
                    							,min[ (mapsrc,dest) | MapSourceAndDest(MapSrc,dest), Millxy(dest,'y') ] );
                    NewExtent('Right') 	:= max( max[ (MapSrc,dest) | MapSourceAndDest(MapSrc,dest), MapAllSourcexy(MapSrc,'x') ]
                    							,max[ (mapsrc,dest) | MapSourceAndDest(MapSrc,dest), Millxy(dest,'x') ] );
                    NewExtent('Left') 	:= min( min[ (MapSrc,dest) | MapSourceAndDest(MapSrc,dest), MapAllSourcexy(MapSrc,'x') ]
                    							,min[ (mapsrc,dest) | MapSourceAndDest(MapSrc,dest), Millxy(dest,'x') ] );
                    
                    !NewExtent('Top') 	:= max[ (MapSrc,dest) | MapSourceAndDest(MapSrc,dest), MapAllSourcexy(MapSrc,'y') ];
                    !NewExtent('Bottom') := min[ (MapSrc,dest) | MapSourceAndDest(MapSrc,dest), MapAllSourcexy(MapSrc,'y') ];
                    !NewExtent('Right') 	:= max[ (MapSrc,dest) | MapSourceAndDest(MapSrc,dest), MapAllSourcexy(MapSrc,'x') ];
                    !NewExtent('left') 	:= min[ (MapSrc,dest) | MapSourceAndDest(MapSrc,dest), MapAllSourcexy(MapSrc,'x') ];
                    
                    !--make extent 10% larger
                    !Buffer := [NewExtent('top') - NewExtent('bottom')] / 10;
                    !NewExtent(ims | ims='Top' or ims = 'Right') +=  Buffer;
                    !NewExtent(ims | ims='Left' or ims = 'Bottom') -=  Buffer;
                    IncreaseExtent(	NewExtent , 110 [%]);
                    
                    !-- adjust ratio Height =  Width * Sideratio
                    NewSideRatio := [NewExtent('top') - NewExtent('bottom')] /$ [NewExtent('right') - NewExtent('left')];
                    
                    if SideRatio >0 and NewSideRatio > SideRatio  then
                    	!not wide enough:  stretch right Width = Height / SideRatio
                    	NewExtent('right') := NewExtent('left') + [NewExtent('top') - NewExtent('bottom')] / SideRatio;
                    else ! too tall:  stretch bottom Height =  Width * SideRatio
                    	NewExtent('Bottom') := NewExtent('Top') - [NewExtent('right') - NewExtent('left')] * SideRatio;
                    endif;
                    
                    !-- set visible area to new extent
                    VisibleArea_MU(iMS) := NewExtent(iMS);
                }
                Parameter MapSourceAndDest {
                    IndexDomain: {
                        (MapSrc,dest) |
                        sum [(PrGrp), DeliveredMUVolumeToMap_Detail(MapSrc,dest,PrGrp)] $ MapShowProd
                        or
                        sum [(ResGrp), DeliveredMUVolumeToMap_Detail(MapSrc,dest,ResGrp)] $ MapShowRes
                    }
                    Text: "Sources and destinations shown in map";
                    InitialData: 999;
                }
                Parameter CurrentExtent {
                    IndexDomain: (iMS);
                }
                Parameter NewExtent {
                    IndexDomain: (iMS);
                }
                Parameter SideRatio;
                Parameter NewSideRatio;
                Parameter Buffer;
            }
            Procedure ZoomToExtent_MU {
                Body: {
                    /* set map extent to be the same as the blocks in Current_mu
                    /**/
                    !--- Check that Blkxy exists
                    if count((blk,ixy) | BLKxy(blk, ixy)) = 0 then
                    	switch(DialogAsk("Do you wish to load coordinates for Blocks?","Yes","No","Cancel","Missing XYs")) do
                    	1:
                    		if DatasetLoadCurrent(data_category :  'MapXY', dataset:  cad::_DataSet,dialog:  1) <> 1 then return 0; endif;
                    	2,3: return 0;
                    	endswitch;
                    endif;
                    
                    empty NewExtent;
                    !--- get extent of current visible area
                    CurrentExtent(iMS) := VisibleArea_Mill(iMS);
                    !-- get ratio of height to width
                    SideRatio := [CurrentExtent('top') - CurrentExtent('bottom')] /$ [CurrentExtent('right') - CurrentExtent('left')];
                    
                    DisplayedBlocks := {
                    			blk |
                    			!blk = Current_blk                           ! blk selected
                    			!or
                    			MU_Block_Relation(Current_mu,blk)           ! blk in Current MU
                    			!or [ First(mu | MU_Block_Relation(mu,Current_blk) )
                    		!		= First(mu1 | MU_Block_Relation(mu1,blk) ) ] ! blk in same MU as selected blk
                    			} ;
                    !-- calculate extent of blocks in current_MU
                    !DebuggerBreakpoint;
                    NewExtent('Top') 	    := max [  max[ dblk ,BLKxy(dblk, 'y') ], MUxy(Current_mu, 'y') ];
                    NewExtent('Bottom') 	:= min [  min[ dblk ,BLKxy(dblk, 'y') ], MUxy(Current_mu, 'y') ];
                    NewExtent('Right') 	    := max [  max[ dblk ,BLKxy(dblk, 'x') ], MUxy(Current_mu, 'x') ];
                    NewExtent('Left') 		:= min [  min[ dblk ,BLKxy(dblk, 'x') ], MUxy(Current_mu, 'x') ];
                    
                    !--make extent 10% larger
                    !Buffer := [NewExtent('top') - NewExtent('bottom')] / 10;
                    !NewExtent(ims | ims='Top' or ims = 'Right') +=  Buffer;
                    !NewExtent(ims | ims='Left' or ims = 'Bottom') -=  Buffer;
                    IncreaseExtent(	NewExtent , 110 [%]);
                    
                    !-- adjust ratio Height =  Width * Sideratio
                    NewSideRatio := [NewExtent('top') - NewExtent('bottom')] /$ [NewExtent('right') - NewExtent('left')];
                    
                    if SideRatio >0 and NewSideRatio > SideRatio  then
                    	!not wide enough:  stretch right Width = Height / SideRatio
                    	NewExtent('right') := NewExtent('left') + [NewExtent('top') - NewExtent('bottom')] / SideRatio;
                    else ! too tall:  stretch bottom Height =  Width * SideRatio
                    	NewExtent('Bottom') := NewExtent('Top') - [NewExtent('right') - NewExtent('left')] * SideRatio;
                    endif;
                    
                    !-- set visible area to new extent
                    VisibleArea_MU(iMS) := NewExtent(iMS);
                }
                Parameter MapSourceAndDest {
                    IndexDomain: {
                        (MapSrc,dest) |
                        sum [(PrGrp), DeliveredMUVolumeToMap_Detail(MapSrc,dest,PrGrp)] $ MapShowProd
                        or
                        sum [(ResGrp), DeliveredMUVolumeToMap_Detail(MapSrc,dest,ResGrp)] $ MapShowRes
                    }
                    Text: "Sources and destinations shown in map";
                    InitialData: 999;
                }
                Set DisplayedBlocks {
                    SubsetOf: Blocks;
                    Index: dblk;
                }
                Parameter CurrentExtent {
                    IndexDomain: (iMS);
                }
                Parameter NewExtent {
                    IndexDomain: (iMS);
                }
                Parameter SideRatio;
                Parameter NewSideRatio;
                Parameter Buffer;
            }
            Procedure IncreaseExtent {
                Arguments: (Extent,zoom);
                Body: {
                    ! Zoom	> 1	=> increase area
                    !		<1	=> smaller area
                    
                    !Put console;
                    !put "--- before adjustment ---"/;
                    !display zoom, extent ;
                    
                    if zoom <= 0 then return 0; endif;
                    
                    if zoom > 1 then
                    	! Y-zoom
                    	Buffer := [Extent('top') - Extent('bottom')] * (zoom-1);
                    	Extent(ims | ims='Top' ) +=  Buffer;
                    	Extent(ims | ims='Bottom' ) -=  Buffer;
                    
                    	! X-Zoom
                    	Buffer := [Extent('right') - Extent('left')] * (zoom-1);
                    	Extent(ims | ims = 'Right') +=  Buffer;
                    	Extent(ims | ims = 'Left') -=  Buffer;
                    else
                    	! Y-zoom
                    	Buffer := [Extent('top') - Extent('bottom')] * (1-zoom);
                    	Extent(ims | ims='Top' ) -=  Buffer;
                    	Extent(ims | ims='Bottom' ) +=  Buffer;
                    
                    	! X-Zoom
                    	Buffer := [Extent('right') - Extent('left')] * (1-zoom);
                    	Extent(ims | ims = 'Right') -=  Buffer;
                    	Extent(ims | ims = 'Left') +=  Buffer;
                    
                    
                    endif;
                    
                    !put "--- after adjustment ---"/;
                    !display extent, VisibleArea_Default;
                    !putclose;
                    
                    return 1;
                }
                Parameter Extent {
                    IndexDomain: (iMS);
                    Property: InOut;
                }
                Parameter zoom {
                    Unit: %;
                    Property: Input;
                }
                Parameter Buffer;
                File Console {
                    Name: "Console";
                    Device: window;
                    Mode: replace;
                }
            }
        }
        Section Data_Checks {
            Assertion Assert_AllDestHaveSources {
                IndexDomain: (dest,PrGrp) | ProductsUsed_PrGrp(dest,PrGrp);
                Definition: MillDemandWithoutSupply(PrGrp,dest);
            }
            Assertion Assert_ThresholdStartAndPenalties {
                IndexDomain: thr | IsSelected(__ThresholdPenalties);
                Text: "you must set Starting thresholds for thr";
                Property: WarnOnly;
                AssertLimit: 1;
                Definition: {
                    sum [(sect) | SectorHasDemand(sect),ThresholdStart(sect,thr) ] > 0
                    and
                    ThresholdPenalties(thr) !need to use zero if you want 0
                }
                Action: {
                    switch(DialogAsk(
                            message : "You must specify starting thresholds and penalties for each sector" ,
                            button1 : "Halt",   button2:"Edit",    button3:"Ignore",       title : "Confirm Action")) do
                            1: halt;
                            2: PageSetFocus(page : "QA", tag : "Thresholds");
                    endswitch;
                }
            }
            Assertion Assert_MillDemand {
                IndexDomain: | IsSelected(__MeetVolumeTargets);
                Text: "you must set Demand targets if Meet Mill Demand is specified";
                Property: WarnOnly;
                AssertLimit: 1;
                Definition: {
                    sum [(dest,gPrGrp,tt,tp),
                     MillDemand_PrGrp(dest,gPrGrp,tt,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp)] > 0 [m3]
                }
                Action: {
                    switch(DialogAsk(
                            message : "You must specify Mill Demand if you select 'Meet Volume Targets'" ,
                            button1 : "Halt",   button2:"Edit",    button3:"Ignore",       title : "Confirm Action")) do
                            1: halt;
                            2: !PageSetFocus(page : "Mills", tag : "Thresholds");
                            	PageOpen(page : "Mill Demand");
                    endswitch;
                }
            }
            Assertion Assert_ConverstionFactors {
                IndexDomain: dest |  ProducesResiduals(dest);
                Text: "Each mill that produces residuals must have conversion factors";
                Property: WarnOnly;
                AssertLimit: 1;
                Definition: {
                    sum[ (gpr,res) | gpr in AllProductsUsed(dest)
                    ![ ( ProductsUsed(dest, ElementCast(Products,gpr,0) )   )
                    !   or (ResidualsUsed(dest, ElementCast(ResidualGroupProducts,gpr,0) ) ) ]
                       ,ResidualsProduced(dest,gpr,res)]
                }
                Action: {
                    switch(DialogAsk(
                            message : FormatString("%e produces residuals but no conversion factors have been specified",dest) ,
                            button1 : "Halt",   button2:"Edit",    button3:"Ignore",       title : "Confirm Action")) do
                            1: halt;
                            2: !PageSetFocus(page : "Mills", tag : "Thresholds");
                            	PageOpen(page : "Mill Demand");
                    endswitch;
                }
            }
            Assertion Assert_ThresholdsForSectorsWithDemand {
                IndexDomain: sect | IsSelected(__ThresholdPenalties) and SectorHasDemand(sect);
                Text: "you must have thresholds for sectors with demand";
                Property: WarnOnly;
                AssertLimit: 1;
                Definition: sum [(thr),ThresholdStart(sect,thr) ] > 0;
                Action: {
                    switch(DialogAsk(
                            message : FormatString("You must define thresholds for sectors that have demand: '%e' ",sect) ,
                            button1 : "Halt",       button2:"Edit", button3:"Ignore",
                            title : "Confirm Action")) do
                            1: halt;
                            2:PageSetFocus(page : "QA", tag : "Thresholds");
                            3:
                    endswitch;
                }
            }
            Assertion Assert_MillSectorRelation {
                IndexDomain: dest | IsSelected(__ThresholdPenalties) and DestHasDemand(dest);
                Text: "dest is part of sector sect";
                Property: WarnOnly;
                AssertLimit: 1;
                Definition: Exists( (sect) | cMillSector(sect,dest));
                Action: {
                     switch(DialogAsk(
                           message : FormatString("%e is not part of any Sector.",dest) ,
                           button1 : "Halt",       button2 : "Edit",  button3:"Ignore",    title : "Confirm Action")) do
                           1:      halt;
                           2: PageSetFocus(page : "QA", tag : "Thresholds");
                           3:
                    endswitch;
                }
            }
            Assertion Assert_MillsInOneSector {
                IndexDomain: dest | IsSelected(__ThresholdPenalties) and count [(sect) | cMillSector(sect,dest )] > 1;
                Text: "dest occurs on multiple sectors";
                Property: WarnOnly;
                AssertLimit: 1;
                Definition: sum [(sect) | cMillSector(sect,dest), cMillSector(sect,dest) ] = 1;
                Action: {
                    switch(DialogAsk(
                           message : FormatString("%e occurs in more than 1 sector",dest) ,
                           button1 : "Halt",       button2:"Edit", button3:"Ignore",       title : "Confirm Action")) do
                           1: halt;
                           2:PageSetFocus(page : "QA", tag : "Thresholds");
                           3:
                    endswitch;
                }
            }
            Assertion Assert_UsesProductsAndProductsUsed {
                IndexDomain: dest | AvailableDest(dest) and [ UsesProducts(dest) or UsesResiduals(dest) or ProducesResiduals(dest) ];
                Text: "dest occurs on multiple sectors";
                Property: WarnOnly;
                AssertLimit: 1;
                Definition: {
                    if UsesProducts(dest) then exists(PrGrp | ProductsUsed_PrGrp(dest, PrGrp)) else 1 endif
                    and
                    if UsesResiduals(dest) then exists(ResGrp | ResidualsUsed_PrGrp(dest, ResGrp)) else 1 endif
                    and
                    if ProducesResiduals(dest) then exists((gpr,res)  | ResidualsProduced(dest, gpr, res)
                                                            			and ProductsUsed(dest, gpr)
                                                            ) else 1 endif
                }
                Action: {
                    MessageString := if UsesProducts(dest) and not exists(PrGrp | ProductsUsed_PrGrp(dest, PrGrp)) then
                    					FormatString("%e Uses products but no products specified",dest)
                    				elseif UsesResiduals(dest) and not exists(ResGrp | ResidualsUsed_PrGrp(dest, ResGrp)) then
                    					FormatString("%e Uses residuals but no residuals specified",dest)
                    				elseif ProducesResiduals(dest) and not exists((gpr,res)  | ResidualsProduced(dest, gpr, res)
                                                            			and ProductsUsed(dest, gpr) ) then
                                        FormatString("%e Produces residuals but no factors specified for products used by %e.",dest,dest)
                                    endif;
                    switch(DialogAsk(
                           message : MessageString ,
                           button1 : "Ignore",       button2:"Edit", button3:"Cancel",       title : "Confirm Action")) do
                           1:
                           2: _dest_s := dest;
                           	PageOpen("_Mills");
                           3: halt;
                    endswitch;
                }
            }
            StringParameter MessageString;
            Procedure AssertMusPerBlock {
                Body: {
                    Current_mu := _mu_s;
                    assert Assert_MusPerBlock;
                }
            }
            Procedure Do_Assert_EquivalentProducts {
                Body: {
                    !assert Assert_EquivalentProducts;
                    
                    EquivalentProducts(prIN,prIN) := 1;
                }
            }
            Procedure CheckBeforeSolve {
                Body: {
                            if not [ card(dest)  ] then
                                    dialogError("Insufficient data: destinations",title:"Nothing to solve");endif;
                            if not [ card(mu)  ] then
                                    dialogError("Insufficient data: mu",title:"Nothing to solve");endif;
                            if not [ card(blk)  ] then
                                    dialogError("Insufficient data: blocks", title:"Nothing to solve");endif;
                            if not [ card(prd) ] then
                                    dialogError("Insufficient data: products",title:"Nothing to solve");endif;
                            if not [ card(term) ] then
                                    dialogError("Insufficient data: terms",title:"Nothing to solve");endif;
                    
                    
                    
                    AssertMusPerBlock;
                    assert Assert_MillDemand;				! ensure there is demand if "Meet mill Demand' selected
                    assert Assert_MillAllDemandTargets ;    ! ensure upper >= lower
                    !assert Assert_MillDemandWithoutSupply;  ! ensure all mills have a potential supply
                    assert Assert_UsesProductsAndProductsUsed;	! ensure products/residuals are specified for all mills that use products/residuals
                    assert Assert_ConverstionFactors;		! ensure all mills that produce residuals have conversion factors
                    assert Assert_HaultimesForAllDestinations; ! ensure all destinations have haultimes
                    assert Assert_HaultimesForAllResiduals; ! ensure all residuals can be sent somewhere
                    
                    assert Assert_ValueForAllProducts;		! ensure all products have value
                    
                    assert Assert_SelectedObjHaveWeight;	! warn if selected objectives have zero weight
                    
                    if IsSelected(__ThresholdPenalties) then
                            assert Assert_MillSectorRelation;               !ensure all mills are part of a sector
                            assert Assert_MillsInOneSector;					!emnsure each mill is in only 1 sector
                            assert Assert_ThresholdStartAndPenalties;		! ensure penalties and thresholds have been specified for each threshold
                            assert Assert_ThresholdsForSectorsWithDemand;	! ensure thresholds have been specified for each sector with demand
                    endif;
                    
                    
                    assert Assert_NoRogueSupplyRoutes;			! make sure supply route subsets are valid
                }
            }
        }
        Section Results {
            Parameter MillDemandX_term {
                IndexDomain: (dest,prd,term);
                Unit: ProductUnit(prd);
                Definition: sum((tt,tp) | tt=__min and term >= tp.ts and term <= tp.tf,MillDemand(dest,prd,tt,tp));
            }
            Parameter MillDemand_term {
                IndexDomain: (dest,gPrGrp,term);
                Unit: ProductGroupUnit(gPrGrp);
                Definition: {
                    sum((tt,tp) | tt=__min and term >= tp.ts and term <= tp.tf,
                    MillDemand_PrGrp(dest,gPrGrp,tt,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp)
                    )
                }
            }
            Parameter MillDemandMax_term {
                IndexDomain: (dest,gPrGrp,term);
                Unit: ProductGroupUnit(gPrGrp);
                Definition: {
                    sum((tt,tp) | tt=__max and term >= tp.ts and term <= tp.tf,
                    MillDemand_PrGrp(dest,gPrGrp,tt,tp) + MillResidualDemand_PrGrp(dest,gPrGrp,tt,tp)
                    )
                }
            }
            Parameter DeliveredVolume_term {
                IndexDomain: (dest,gPrGrp,term);
                Unit: ProductGroupUnit(gPrGrp);
                Definition: DeliveredAllVolume_PrGrp(term,dest,gPrGrp);
            }
            Parameter DeliveredVolume_MU {
                IndexDomain: (term,mu,dest,gProd);
                Unit: ProductUnit(gProd);
                Definition: sum(blk, DeliveredTotalVolume(term,blk,dest,gProd) $ MU_Block_Relation(mu,blk));
            }
            Parameter DeliveredVolumePrd_MuAllterm {
                IndexDomain: (mu,dest,prd);
                Unit: ProductUnit(prd);
                Definition: sum [(term,blk,gPrGrp), DeliveredBlockVolume_VAR(term,blk,prd,dest,gPrGrp) $ MU_Block_Relation(mu,blk) ];
            }
            Parameter DeliveredVolume_Dest {
                IndexDomain: (term,dest,prd);
                Unit: ProductUnit(prd);
                Definition: sum(blk, DeliveredTotalVolume(term,blk,dest,prd));
            }
            Parameter Net_BlockVolumeConversions {
                IndexDomain: (term,blk,prIN,prOUT) | prin <> prout;
                Text: "Volume undergoing conversion in term,blk from prIn to prOUT";
                Range: nonnegative;
                Unit: ProductUnit(prIN);
                Definition: {
                    !OLDBlockVolumeConversions(term,blk,prIN,prOUT)
                }
            }
            Parameter MeetMillAllDemandPrGrp_Lower_Violation {
                IndexDomain: (dest,gPrGrp,tp) | MillDemand_PrGrp(dest,gPrGrp,__min,tp);
                Unit: ProductGroupUnit(gPrGrp);
                Definition: average[term, MeetMillAllDemandPrGrp_Lower.Violation( term, dest, gPrGrp, __min, tp )];
            }
            Parameter DeliveredHaulCost_Mu {
                IndexDomain: (dest,mu,gProd);
                Unit: $;
                Definition: sum[(term,blk) | MU_Block_Relation(mu,blk) ,DeliveredHaulCost(term,blk,dest,gProd)];
            }
            Parameter Copy_DeliveredHaulCost_Mu {
                IndexDomain: (term,dest,mu,gProd);
                Unit: $;
                Definition: sum[blk | MU_Block_Relation(mu,blk) ,DeliveredHaulCost(term,blk,dest,gProd)];
            }
            Parameter DeliveredHaulCost_Res {
                IndexDomain: (destTo,destFrom,res);
                Unit: $;
                Definition: sum[(term)  ,DeliveredHaulCost(term,destFrom,destTo,res)];
            }
            Procedure ClearResults {
                Body: {
                    empty Allvariables;
                    cleandependents;
                }
            }
        }
        Section Access_Linkages {
            Procedure InitializeParameterToExportSets {
                Body: {
                        empty ParametersToExportAndImport; cleandependents;
                        /* Parameters to Import*/
                         SetElementAdd(ParametersToImport,Current_pti,"ManagementUnits_txt");
                         SetElementAdd(ParametersToImport,Current_pti,"AllDestinations_txt");
                         SetElementAdd(ParametersToImport,Current_pti,"Blocks_txt");
                         SetElementAdd(ParametersToImport,Current_pti,"obj_Selected");
                         SetElementAdd(ParametersToImport,Current_pti,"Obj_Identifiers_txt");
                         SetElementAdd(ParametersToImport,Current_pti,"obj_Weights");
                    
                         ! ************************ Costs ******************
                         SetElementAdd(ParametersToImport,Current_pti,"Mu_Block_Relation");
                         SetElementAdd(ParametersToImport,Current_pti,"cPrg");
                         SetElementAdd(ParametersToImport,Current_pti,"EquivalentProducts");
                         SetElementAdd(ParametersToImport,Current_pti,"InitialGS");
                         SetElementAdd(ParametersToImport,Current_pti,"HaulTime");
                         SetElementAdd(ParametersToImport,Current_pti,"VolumePerLoad");
                         SetElementAdd(ParametersToImport,Current_pti,"HaulCostPerUnit");
                         !TruckRate
                         SetElementAdd(ParametersToImport,Current_pti,"LoadingCostPerLoad");
                    
                         !************************ Mill Demand Targets ******************
                         SetElementAdd(ParametersToImport,Current_pti,"cMillSector");
                         SetElementAdd(ParametersToImport,Current_pti,"UsesProducts");
                         SetElementAdd(ParametersToImport,Current_pti,"UsesResiduals");
                         SetElementAdd(ParametersToImport,Current_pti,"ProductsUsed_PrGrp");
                         SetElementAdd(ParametersToImport,Current_pti,"ResidualsUsed_PrGrp");
                         SetElementAdd(ParametersToImport,Current_pti,"ProducesResiduals");
                         SetElementAdd(ParametersToImport,Current_pti,"ResidualsProduced");
                         SetElementAdd(ParametersToImport,Current_pti,"MillDemand_PrGrp");
                         SetElementAdd(ParametersToImport,Current_pti,"MillResidualDemand_PrGrp");
                    
                    	!************************ Flow targets ******************
                         SetElementAdd(ParametersToImport,Current_pti,"TreesFlow");
                    	 SetElementAdd(ParametersToImport,Current_pti,"ResidualFlow");
                    
                         !************************ Map Data ******************
                         SetElementAdd(ParametersToImport,Current_pti,"BLKxy");
                    	 SetElementAdd(ParametersToImport,Current_pti,"MUxy");
                    	 SetElementAdd(ParametersToImport,Current_pti,"Millxy");
                    
                    	!**********************************************************
                        !************************ RESULTS *************************
                        !**********************************************************
                    
                        !************************ Delivered Wood ******************
                        SetElementAdd(ParametersToExportAndImport,Current_pte,"DeliveredVolume");
                    	SetElementAdd(ParametersToExportAndImport,Current_pte,"DeliveredResidualVolume");
                    
                    	! ... added to facilitate mapping woodflow only
                         SetElementAdd(ParametersToImport,Current_pti,"DeliveredBlockVolume_VAR");
                    	 SetElementAdd(ParametersToImport,Current_pti,"DeliveredResidualVolume_VAR");
                    
                    	!**********************************************************
                        !******************** PARAMETERS TO MAP *******************
                        !**********************************************************
                        empty ParametersToMap; cleandependents;
                        ParametersToMap :=
                        	{ 'MU_Block_Relation'				, 'cPrG'			,  'ProducesResiduals'
                        		, 'UsesProducts'				, 'UsesResiduals'	,	'cMillSector'
                        		, 'MUxy'						, 'BLKxy'			,	'Millxy'
                        		, 'DeliveredBlockVolume_VAR'	, 'DeliveredResidualVolume_VAR'
                    		} ;
                         SetElementAdd(ParametersToMap,_ptm,"ManagementUnits_txt");
                         SetElementAdd(ParametersToMap,_ptm,"AllDestinations_txt");
                         SetElementAdd(ParametersToMap,_ptm,"Blocks_txt");
                }
            }
            Procedure InitializeAccessTablenames {
                Body: {
                    block !Names of Access tables
                        AccessTableNames(pte) := data {
                    
                    	 'ManagementUnits_txt'  :  "tblManagementUnits_txt"
                    	,'AllDestinations_txt'	:	"tblAllDestinations_txt"
                    	,'Blocks_txt'			:	"tblBlocks_txt"
                    	,'obj_Selected'  :  "tblobj_Selected"
                    	,'Obj_Identifiers_txt'  :  "tblObj_Identifiers_txt"
                    	,'obj_Weights'  :  "tblobj_Weights"
                    
                    		! ************************ Costs ******************
                    	,'Mu_Block_Relation'  :  "tblMu_Block_Relation"
                    	,'cPrg'  :  "tblcPrg"
                    	,'EquivalentProducts'  :  "tblEquivalentProducts"
                    	,'InitialGS'  :  "tblInitialGS"
                    	,'HaulTime'  :  "tblHaulTime"
                    	,'VolumePerLoad'  :  "tblM3PerLoad"
                    	,'HaulCostPerUnit'  :  "tblHaulCostPerUnit"
                    	,'LoadingCostPerLoad'  :  "tblLoadingCostPerLoad"
                    
                    		!************************ Mill Demand Targets ******************
                    	,'cMillSector'	: "tblcMillSector"
                    	,'UsesProducts'  :  "tblUsesProducts"
                    	,'UsesResiduals'  :  "tblUsesResiduals"
                    	,'ProductsUsed_PrGrp'  :  "tblProductsUsed_PrGrp"
                    	,'ResidualsUsed_PrGrp'  :  "tblResidualsUsed_PrGrp"
                    	,'ProducesResiduals'  :  "tblProducesResiduals"
                    	,'ResidualsProduced'  :	 "tblResidualsProduced"
                    	,'MillDemand_PrGrp'  :  "tblMillDemand_PrGrp"
                    	,'MillResidualDemand_PrGrp'  :  "tblMillResidualDemand_PrGrp"
                    
                    		!************************ Flow targets ******************
                    	,'TreesFlow'  :  "tblTreesFlow"
                    	,'ResidualFlow'  :  "tblResidualFlow"
                    
                    	     !************************ Map Data ******************
                    	,'BLKxy'		:	"tblBLKxy"
                    	,'MUxy'			:	"tblMUxy"
                    	,'Millxy'		:	"tblMillxy"
                    
                    	!**********************************************************
                        !************************ RESULTS *************************
                        !**********************************************************
                    
                        !************************ Delivered Wood ******************
                        ,'DeliveredVolume'			:	"tboDeliveredVolume"
                    	,'DeliveredResidualVolume'	:	"tboDeliveredResidualVolume"
                    	,'DeliveredBlockVolume_VAR'	:	"tblDeliveredBlockVolume_VAR"
                    	,'DeliveredResidualVolume_VAR'	:"tblDeliveredResidualVolume_VAR"
                    
                    	};
                    endblock;
                    
                    AccessTableDomains(pte) := GetIndexDomain(pte, 1);
                }
            }
            DeclarationSection IniDeclaration {
                Set ParametersToExportAndImport {
                    SubsetOf: AllIdentifiers;
                    Index: pte;
                    Parameter: Current_pte, _pte;
                    Property: NoSave;
                }
                Set ParametersToImport {
                    SubsetOf: ParametersToExportAndImport;
                    Index: pti;
                    Parameter: Current_pti;
                    Property: NoSave;
                }
                Set ParametersToMap {
                    SubsetOf: ParametersToExportAndImport;
                    Index: ptm;
                    Parameter: _ptm;
                    Property: NoSave;
                }
                Parameter ParametersToExport_Selected {
                    IndexDomain: (pte);
                    Range: binary;
                    Property: NoSave;
                }
                Parameter ParametersToImport_Selected {
                    IndexDomain: (pte);
                    Range: binary;
                    Property: NoSave;
                }
                StringParameter MSAccess_filename {
                    Property: NoSave;
                    InitialData: {
                        !"WoodFlowDatabase.udl"
                        "MarketFlowDatabase.udl"
                    }
                }
                StringParameter AccessTableNames {
                    IndexDomain: (pte);
                    Text: "Name of tables for pte";
                }
                StringParameter AccessTableDomains {
                    IndexDomain: (pte);
                    Property: NoSave;
                }
            }
            Procedure SetActivePageTagName {
                Body: {
                    PageGetFocus(PageName,TagName);
                    ActivePageTagName := TagName;
                }
                DeclarationSection Declaration2 {
                    StringParameter PageName;
                    StringParameter TagName;
                }
            }
            Procedure ClearActivePageTagName {
                Body: {
                    empty ActivePageTagName;
                }
            }
            Procedure InitializeMapResultsPage {
                Body: {
                    ClearActivePageTagName;
                    
                    ParametersToImport_Selected(pte | FindString(FormatString("%e",pte),"VAR") ) := 1;
                }
            }
            DeclarationSection General_Declarations {
                DatabaseTable dbParametersToExport {
                    DataSource: "TenureDatabase.udl";
                    TableName: "tblParametersToExport";
                    Mapping: {
                        "pte"   -->     pte,
                        "Parameter"     -->     ParametersToExport_Selected(pte)
                    }
                }
                DatabaseTable dbParametersToImport {
                    DataSource: "TenureDatabase.udl";
                    TableName: "tblParametersToImport";
                    Mapping: {
                        "pti"   -->     pti,
                        "Parameter"     -->     ParametersToImport_Selected(pti)
                    }
                }
            }
            DeclarationSection DatabaseTables {
                Comment: "Start of Database Declarations-----dk";
                Parameter T_MillDemand_PrGrp {
                    IndexDomain: (dest,PrGrp,tt,ti,tj)| ProductsUsed_PrGrp(dest,PrGrp);
                    Text: "Volume limit (tt) by Mill (Dest) of Product(prg) during period ti to tj";
                    Range: nonnegative;
                    Unit: ProductGroupUnit(PrGrp);
                }
                Parameter T_MillResidualDemand_PrGrp {
                    IndexDomain: (dest,ResGrp,tt,ti,tj) | ResidualsUsed_PrGrp(dest,ResGrp);
                    Text: "Volume limit (tt) by Mill (Dest) of Residual (ResGrp) during period ti to tj";
                    Range: nonnegative;
                    Unit: ProductGroupUnit(ResGrp);
                }
                StringParameter AllDestinations_txt {
                    IndexDomain: (loc);
                }
                StringParameter Blocks_txt {
                    IndexDomain: (blk);
                }
                DatabaseTable dbManagementUnits_txt {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('ManagementUnits_txt');
                    Mapping: {
                        "mu"   -->     mu,
                        "ManagementUnits_txt"            -->     ManagementUnits_txt(mu)
                    }
                }
                DatabaseTable dbAllDestinations_txt {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('AllDestinations_txt');
                    Mapping: {
                        "dest"   -->     loc,
                        "AllDestinations_txt"            -->     AllDestinations_txt(dest)
                    }
                }
                DatabaseTable dbBlocks_txt {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('Blocks_txt');
                    Mapping: {
                        "blk"   -->     blk,
                        "Blocks_txt"            -->     Blocks_txt(blk)
                    }
                }
                DatabaseTable dbObj_Identifiers_txt {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('Obj_Identifiers_txt');
                    Mapping: {
                        "objId"   -->     objId,
                        "Obj_Identifiers_txt"            -->     Obj_Identifiers_txt(objId)
                    }
                }
                DatabaseTable dbobj_Weights {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('obj_Weights');
                    Mapping: {
                        "objId"   -->     objId,
                        "obj_Weights"            -->     obj_Weights(objId)
                    }
                }
                DatabaseTable dbobj_Selected {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('obj_Selected');
                    Mapping: {
                        "objId"   -->     objId,
                        "obj_Selected" --> obj_Selected(objId)
                    }
                }
                DatabaseTable dbMu_Block_Relation {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('MU_Block_Relation');
                    Mapping: {
                        "mu" --> mu,
                        "blk" --> blk,
                        "MU_Block_Relation"--> MU_Block_Relation(mu,blk)
                    }
                }
                DatabaseTable dbcPrg {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('cPrG');
                    Mapping: {
                        "gPrGrp" --> gPrGrp,
                        "gpr" --> gpr,
                        "cPrg"--> cPrG(gPrGrp,gpr)
                    }
                }
                DatabaseTable dbcMillSector {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('cMillSector');
                    Mapping: {
                        "sect" --> sect,
                        "dest" --> dest,
                        "cMillSector"--> cMillSector(sect, dest)
                    }
                }
                DatabaseTable dbMUxy {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('MUxy');
                    Mapping: {
                        "mu" --> mu,
                        "xy" --> ixy,
                        "MUxy"--> MUxy(mu,ixy)
                    }
                }
                DatabaseTable dbBLKxy {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('BLKxy');
                    Mapping: {
                        "BLK" --> blk,
                        "xy" --> ixy,
                        "BLKxy"--> BLKxy(blk, ixy)
                    }
                }
                DatabaseTable dbMillxy {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('Millxy');
                    Mapping: {
                        "dest" --> dest,
                        "xy" --> ixy,
                        "Millxy"--> Millxy(dest,ixy)
                    }
                }
                DatabaseTable dbEquivalentProducts {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('EquivalentProducts');
                    Mapping: {
                        "prIN" --> prIN,
                        "prOUT" --> prOUT,
                        "EquivalentProducts"--> EquivalentProducts(prIN,prOUT)
                    }
                }
                DatabaseTable dbInitialGS {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('InitialGS');
                    Mapping: {
                        "blk" --> blk,
                        "prd" --> prd,
                        
                        "InitialGS"--> InitialGS(blk,prd)
                    }
                }
                DatabaseTable dbHaulTime {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('HaulTime');
                    Mapping: {
                        "src" --> src,
                        "dest" --> dest,
                        "HaulTime"--> HaulTime(src,dest)
                    }
                }
                DatabaseTable dbM3PerLoad {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('VolumePerLoad');
                    Mapping: {
                        "gProd" --> gProd,
                        "M3PerLoad"--> VolumePerLoad(gProd)
                    }
                }
                DatabaseTable dbHaulCostPerUnit {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('HaulCostPerUnit');
                    Mapping: {
                        "gProd" --> gProd,
                        "HaulCostPerUnit"--> HaulCostPerUnit(gProd)
                    }
                }
                DatabaseTable dbLoadingCostPerLoad {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('LoadingCostPerLoad');
                    Mapping: {
                        "gProd" --> gProd,
                        "LoadingCostPerLoad"--> LoadingCostPerLoad(gProd)
                    }
                }
                DatabaseTable dbUsesProducts {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('UsesProducts');
                    Mapping: {
                        "dest" --> dest,
                        "UsesProducts"--> UsesProducts(dest)
                    }
                }
                DatabaseTable dbUsesResiduals {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('UsesResiduals');
                    Mapping: {
                        "dest" --> dest,
                        "UsesResiduals"--> UsesResiduals(dest)
                    }
                }
                DatabaseTable dbProductsUsed_PrGrp {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('ProductsUsed_PrGrp');
                    Mapping: {
                        "dest" --> dest,
                        "PrGrp" --> PrGrp,
                        "ProductsUsed_PrGrp"--> ProductsUsed_PrGrp(dest,PrGrp)
                    }
                }
                DatabaseTable dbResidualsProduced {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('ResidualsProduced');
                    Mapping: {
                        "dest" --> dest,
                        "prd" --> prd,
                        "res" --> res,
                        "ResidualsProduced"--> ResidualsProduced(dest,prd,res)
                    }
                }
                DatabaseTable dbResidualsUsed_PrGrp {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('ResidualsUsed_PrGrp');
                    Mapping: {
                        "dest" --> dest,
                        "ResGrp" --> ResGrp,
                        "ResidualsUsed_PrGrp"--> ResidualsUsed_PrGrp(dest,ResGrp)
                    }
                }
                DatabaseTable dbProducesResiduals {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('ProducesResiduals');
                    Mapping: {
                        "dest" --> dest,
                        "ProducesResiduals"--> ProducesResiduals(dest)
                    }
                }
                DatabaseTable dbMillDemand_PrGrp {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('MillDemand_PrGrp');
                    Mapping: {
                        "dest" --> dest,
                        "PrGrp" --> PrGrp,
                        "tt" --> tt,
                        "tp_start" --> ti ,
                        "tp_end" --> tj ,
                        "MillDemand_PrGrp"--> T_MillDemand_PrGrp(dest,PrGrp,tt,ti,tj)
                    }
                }
                DatabaseTable dbMillResidualDemand_PrGrp {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('MillResidualDemand_PrGrp');
                    Mapping: {
                        "dest"                     --> dest,
                        "ResGrp"                   --> ResGrp,
                        "tt"                       --> tt,
                        "tp_start"                 --> ti,
                        "tp_end"                   --> tj,
                        "MillResidualDemand_PrGrp" --> T_MillResidualDemand_PrGrp(dest,ResGrp,tt,ti,tj)
                    }
                }
                DatabaseTable dbTreesFlow {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('TreesFlow');
                    Mapping: {
                        "term"      --> term,
                        "mu"        --> mu,
                        "dest"      --> dest,
                        "prod"      --> prd,
                        "tt"        --> tt,
                        "TreesFlow" --> TreesFlow(term,mu,dest,prd,tt)
                    }
                }
                DatabaseTable dbResidualFlow {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('ResidualFlow');
                    Mapping: {
                        "term"      --> term,
                        "destFrom"   --> destFrom,
                        "DestTo"      --> DestTo,
                        "res"      --> res,
                        "tt"        --> tt,
                        "ResidualFlow" --> ResidualFlow(term,destFrom,DestTo,res,tt)
                    }
                }
                DatabaseTable dboDeliveredVolume {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('DeliveredVolume');
                    Mapping: {
                        "term"      --> term,
                        "src"        --> blk,
                        "dest"      --> dest,
                        "gprod"      --> prd,
                        "DeliveredVolume" --> DeliveredVolume(term, blk, dest, prd)
                    }
                }
                DatabaseTable dboDeliveredResidualVolume {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('DeliveredResidualVolume_VAR');
                    Mapping: {
                        "term"      --> term,
                        "src"        --> destFrom,
                        "dest"      --> destTo,
                        "gprod"		--> res,
                        "DeliveredResidualVolume" --> DeliveredResidualVolume(term, destFrom, DestTo, res)
                    }
                }
                DatabaseTable dbDeliveredBlockVolume_VAR {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('DeliveredBlockVolume_VAR');
                    Mapping: {
                        "term"      --> term,
                        "blk"        --> blk,
                        "dest"      --> dest,
                        "prd"      --> prd,
                        "gPrGrp"	--> gPrGrp,
                        "DeliveredBlockVolume_VAR" --> DeliveredBlockVolume_VAR(term, blk, prd, dest, gPrGrp)
                    }
                }
                DatabaseTable dbDeliveredBlockVolume_PARAM {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('DeliveredBlockVolume_VAR');
                    Mapping: {
                        "term"      --> term,
                        "blk"        --> blk,
                        "dest"      --> dest,
                        "prd"      --> prd,
                        "gPrGrp"	--> PrGrp,
                        "Volume" --> DeliveredBlockVolume_Param(term, blk, prd, dest, PrGrp)
                    }
                }
                DatabaseTable dbDeliveredResidualVolume_VAR {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('DeliveredResidualVolume_VAR');
                    Mapping: {
                        "term"      --> term,
                        "src"        --> src,
                        "dest"      --> destTo,
                        "gRes"		--> res,
                        "ResGrp"	--> ResGrp,
                        "DeliveredResidualVolume_VAR" --> DeliveredResidualVolume_VAR(term, src, Res, DestTo, ResGrp)
                    }
                }
                DatabaseTable dbDeliveredResidualVolume_PARAM {
                    DataSource: "TenureDatabase.udl";
                    TableName: AccessTableNames('DeliveredResidualVolume_VAR');
                    Mapping: {
                        "term"      --> term,
                        "src"        --> dest,
                        "dest"      --> destTo,
                        "gRes"		--> res,
                        "ResGrp"	--> ResGrp,
                        "Volume" --> DeliveredResidualVolume_PARAM(term, dest, Res, DestTo, ResGrp)
                    }
                }
            }
            Procedure WriteToAccess {
                Body: {
                    if dialogAsk(
                     message:formatString("This will overwrite existing data in the database.\n\nDo you wish to continue?"),
                            title:"Import data from Access", button1:"Yes",button2:"No") = 2 then return -1; endif;
                    
                    AssignDefaultTo_txt;    ! ensure all _txt parameters contain data
                    EmptyAccessTables;
                    
                    ! check that tablenames are valid
                    if exists( pte | stringlength(AccessTableNames(pte)) = 0 ) then
                    	DialogError("Table names are empty");
                    	return 0;
                    endif;
                    !DebuggerBreakpoint;            !
                     block ! ITEMS Always Written / Read
                            write to table dbManagementUnits_txt in  replace mode;
                            write to table dbAllDestinations_txt in replace mode;
                            write to table dbBlocks_txt in replace mode;
                            write to table dbObj_Identifiers_txt in  replace mode;
                    endblock;
                    
                    /* Selected Parameters /**/
                    
                    if ParametersToExport_Selected('obj_Selected') then write to table dbobj_Selected in  replace mode;  endif;
                    if ParametersToExport_Selected('obj_Weights') then write to table dbobj_Weights in  replace mode;  endif;
                    if ParametersToExport_Selected('MU_Block_Relation') then write to table dbMU_Block_Relation in  replace mode;  endif;
                    if ParametersToExport_Selected('cPrG') then write to table dbcPrG in  replace mode;  endif;
                    if ParametersToExport_Selected('EquivalentProducts') then write to table dbEquivalentProducts in  replace mode;  endif;
                    if ParametersToExport_Selected('InitialGS') then write to table dbInitialGS in  replace mode;  endif;
                    if ParametersToExport_Selected('HaulTime') then write to table dbHaulTime in  replace mode;  endif;
                    if ParametersToExport_Selected('VolumePerLoad') then write to table dbM3PerLoad in  replace mode;  endif;
                    if ParametersToExport_Selected('LoadingCostPerLoad') then write to table dbLoadingCostPerLoad in  replace mode;  endif;
                    if ParametersToExport_Selected('HaulCostPerUnit') then write to table dbHaulCostPerUnit in  replace mode;  endif;
                    if ParametersToExport_Selected('UsesProducts') then write to table dbUsesProducts in  replace mode;  endif;
                    if ParametersToExport_Selected('cMillSector') then write to table dbcMillSector in  replace mode;  endif;
                    if ParametersToExport_Selected('UsesResiduals') then write to table dbUsesResiduals in  replace mode;  endif;
                    if ParametersToExport_Selected('ProductsUsed_PrGrp') then write to table dbProductsUsed_PrGrp in  replace mode;  endif;
                    if ParametersToExport_Selected('ResidualsUsed_PrGrp') then write to table dbResidualsUsed_PrGrp in  replace mode;  endif;
                    if ParametersToExport_Selected('ProducesResiduals') then write to table dbProducesResiduals in  replace mode;  endif;
                    if ParametersToExport_Selected('ResidualsProduced') then write to table dbResidualsProduced in  replace mode;  endif;
                    if ParametersToExport_Selected('TreesFlow') then write to table dbTreesFlow in  replace mode;  endif;
                    if ParametersToExport_Selected('ResidualFlow') then write to table dbResidualFlow in  replace mode;  endif;
                    
                    ! Mill Demand uses compound indices .... must use intermediate parameter
                    if ParametersToExport_Selected('MillDemand_PrGrp') then
                            for (tp | sum((dest,PrGrp,tt), MillDemand_PrGrp(dest,PrGrp,tt,tp)) ) do
                                    T_MillDemand_PrGrp((dest,PrGrp,tt,ti,tj) | ( ti = tp.ts and tj = tp.tf ))
                                            := MillDemand_PrGrp(dest,PrGrp,tt,tp) ;
                            endfor;
                            write to table dbMillDemand_PrGrp in  replace mode;
                    endif;
                    
                    if ParametersToExport_Selected('MillResidualDemand_PrGrp') then
                            for (tp | sum((dest,ResGrp,tt), MillResidualDemand_PrGrp(dest,ResGrp,tt,tp)) ) do
                                    T_MillResidualDemand_PrGrp((dest,ResGrp,tt,ti,tj) | ( ti = tp.ts and tj = tp.tf ))
                                            := MillResidualDemand_PrGrp(dest,ResGrp,tt,tp) ;
                            endfor;
                            write to table dbMillResidualDemand_PrGrp in  replace mode;
                    endif;
                    !****************** MAP DATA ************************
                    if ParametersToExport_Selected('MUxy') then write to table dbMUxy in  replace mode;  endif;
                    if ParametersToExport_Selected('BLKxy') then write to table dbBLKxy in  replace mode;  endif;
                    if ParametersToExport_Selected('Millxy') then write to table dbMillxy in  replace mode;  endif;
                    
                    !****************** RESULTS ************************
                    if ParametersToExport_Selected('DeliveredVolume') then write to table dboDeliveredVolume in  replace mode;  endif;
                    if ParametersToExport_Selected('DeliveredResidualVolume') then write to table dboDeliveredResidualVolume in  replace mode;  endif;
                    if ParametersToExport_Selected('DeliveredBlockVolume_VAR') then write to table dbDeliveredBlockVolume_var in  replace mode;  endif;
                    if ParametersToExport_Selected('DeliveredResidualVolume_VAR') then write to table dbDeliveredResidualVolume_VAR in  replace mode;  endif;
                }
            }
            Procedure AssignDefaultTo_txt {
                Body: {
                     !Obj_Identifiers_txt(objId | Obj_Identifiers_txt(objId)="") := objId;
                    
                    ManagementUnits_txt(mu|ManagementUnits_txt(mu)="") := mu;
                    AllDestinations_txt(loc | AllDestinations_txt(loc) = "") := loc;
                    Blocks_txt(blk | Blocks_txt(blk) = "") := blk;
                }
            }
            Procedure ReadFromAccess {
                Body: {
                    if dialogAsk(
                     message:formatString("This will replace existing data in your model.\n\nDo you wish to continue?%s",""),
                            title:"Import data from Access", button1:"Yes",button2:"No") = 2 then return -1; endif;
                    
                    !debuggerbreakpoint;
                    block! ITEMS Always Written / Read
                            read ManagementUnits_txt from table dbManagementUnits_txt in  replace mode; !mu
                            read AllDestinations_txt from table dbAllDestinations_txt in replace mode;      !dest
                            !read Obj_Identifiers_txt from table dbObj_Identifiers_txt in  replace mode;     !obj_id
                            read Blocks_txt from table dbBlocks_txt in replace mode;                                        !blk
                    endblock;
                    
                    
                    /**/
                    !if ParametersToImport_Selected('ManagementUnits_txt') then read from table dbManagementUnits_txt in  replace mode;  endif;
                    if ParametersToImport_Selected('obj_Selected') then read obj_Selected from table dbobj_Selected in  replace mode;  endif;
                    !if ParametersToImport_Selected('Obj_Identifiers_txt') then read from table dbObj_Identifiers_txt in  replace mode;  endif;
                    if ParametersToImport_Selected('obj_Weights') then read obj_Weights from table dbobj_Weights in  replace mode;  endif;
                    if ParametersToImport_Selected('MU_Block_Relation') then read MU_Block_Relation from table dbMU_Block_Relation in  replace mode;  endif;
                    if ParametersToImport_Selected('cPrG') then read cPrG from table dbcPrG in  replace mode;  endif;
                    if ParametersToImport_Selected('cMillSector') then read cMillSector from table dbcMillSector in  replace mode;  endif;
                    if ParametersToImport_Selected('EquivalentProducts') then read EquivalentProducts from table dbEquivalentProducts in  replace mode;  endif;
                    if ParametersToImport_Selected('InitialGS') then read InitialGS from table dbInitialGS in  replace mode;  endif;
                    
                    /*  Order is important because of index domains /**/
                    !debuggerbreakpoint;
                    if ParametersToImport_Selected('UsesProducts') then read UsesProducts from table dbUsesProducts in  replace mode;  endif;
                    if ParametersToImport_Selected('ProducesResiduals') then read ProducesResiduals from table dbProducesResiduals in  replace mode;  endif;
                    
                    if ParametersToImport_Selected('HaulTime') then read HaulTime from table dbHaulTime in  replace mode;  endif;
                    if ParametersToImport_Selected('VolumePerLoad') then read VolumePerLoad from table dbM3PerLoad in  replace mode;  endif;
                    if ParametersToImport_Selected('LoadingCostPerLoad') then read LoadingCostPerLoad from table dbLoadingCostPerLoad in  replace mode;  endif;
                    if ParametersToImport_Selected('HaulCostPerUnit') then read HaulCostPerUnit from table dbHaulCostPerUnit in  replace mode;  endif;
                    if ParametersToImport_Selected('UsesResiduals') then read UsesResiduals from table dbUsesResiduals in  replace mode;  endif;
                    if ParametersToImport_Selected('ProductsUsed_PrGrp') then read ProductsUsed_PrGrp from table dbProductsUsed_PrGrp in  replace mode;  endif;
                    if ParametersToImport_Selected('ResidualsUsed_PrGrp') then read ResidualsUsed_PrGrp from table dbResidualsUsed_PrGrp in  replace mode;  endif;
                    if ParametersToExport_Selected('ResidualsProduced') then read ResidualsProduced from table dbResidualsProduced in  replace mode;  endif;
                    if ParametersToImport_Selected('TreesFlow') then read TreesFlow from table dbTreesFlow in  replace mode;  endif;
                    if ParametersToExport_Selected('ResidualFlow') then read ResidualFlow from table dbResidualFlow in  replace mode;  endif;
                    
                    ! Mill Demand uses compound indices .... must use intermediate parameter T_
                    if ParametersToImport_Selected('MillDemand_PrGrp') then
                            read T_MillDemand_PrGrp from table dbMillDemand_PrGrp in replace mode;
                            for ((ti,tj) | sum((dest,PrGrp,tt), T_MillDemand_PrGrp(dest,PrGrp,tt,ti,tj)) ) do
                                    MillDemand_PrGrp((dest,PrGrp,tt,tp) | ( ti = tp.ts and tj = tp.tf ))
                                    := T_MillDemand_PrGrp(dest,PrGrp,tt,ti,tj) ;
                            endfor;
                    endif;
                    
                    if ParametersToImport_Selected('MillResidualDemand_PrGrp') then
                            read T_MillResidualDemand_PrGrp from table dbMillResidualDemand_PrGrp in replace mode;
                            for ((ti,tj) | sum((dest,PrGrp,tt), T_MillResidualDemand_PrGrp(dest,PrGrp,tt,ti,tj)) ) do
                                    MillResidualDemand_PrGrp((dest,PrGrp,tt,tp) | ( ti = tp.ts and tj = tp.tf ))
                                    := T_MillResidualDemand_PrGrp(dest,PrGrp,tt,ti,tj) ;
                            endfor;
                    endif;
                    
                    ! dk: Sep 2011 - added to permit wood flow mapping
                    if ParametersToImport_Selected('DeliveredBlockVolume_VAR') then
                    	MapResultsOnly := 1;
                    	read DeliveredBlockVolume_VAR from table dbDeliveredBlockVolume_VAR  in  replace mode;
                    endif;
                    if ParametersToImport_Selected('DeliveredResidualVolume_VAR') then
                    	MapResultsOnly := 1;
                    	read DeliveredResidualVolume_VAR from table dbDeliveredResidualVolume_VAR   in  replace mode;
                    endif;
                }
            }
            Section MappingResults_Section {
                Set ProxyMUs {
                    Index: pmu, pmu1;
                    Parameter: _pmu;
                    Property: NoSave;
                    OrderBy: pmu;
                }
                ElementParameter cMU_ProxyMU {
                    IndexDomain: (pmu);
                    Range: ManagementUnits_Sorted;
                    Property: NoSave;
                }
                ElementParameter ProxyMU_BlockRelation {
                    IndexDomain: blk;
                    Range: ProxyMUs;
                }
                Procedure ReadResultsToMapFromAccess {
                    Body: {
                        if dialogAsk(
                         message:formatString("This will replace existing data in your model.\n\nDo you wish to continue?%s",""),
                                title:"Import data to Map", button1:"Yes",button2:"No") = 2 then return -1; endif;
                        
                        !debuggerbreakpoint;
                        empty AllLocations, ManagementUnits, AllProducts, AllProductGroups; !,Destinations, Blocks;
                        cleandependents;
                        
                        	MapResultsOnly := 1;
                        
                        	!--- Check that tablenames are valid
                        	if exists(ptm|AccessTableNames(ptm)="") then
                        		DialogError("Please initialize or enter tablenames for parameters to map","Missing database table names");
                        		return 0;
                        	endif;
                        
                        	!--- read flow details
                        	!DB_Procedure_1;
                        	read DeliveredBlockVolume_PARAM(term, blk, prd, dest, PrGrp) from table dbDeliveredBlockVolume_PARAM  ;
                        	read DeliveredResidualVolume_PARAM(term, dest, res, DestTo, ResGrp) from table dbDeliveredResidualVolume_PARAM  ;
                        	!read DeliveredBlockVolume_PARAM(term, blk, prd, dest, gPrGrp) from table dbDeliveredBlockVolume_PARAM  ;
                        
                        	!-----------------------------
                        SetIndexDomainsFromFlowData;
                        
                        
                        DeliveredBlockVolume_VAR(term, blk, prd, dest, gPrGrp) := DeliveredBlockVolume_PARAM(term, blk, prd, dest, gPrGrp);
                        DeliveredResidualVolume_VAR(term, MillSrc, gRes, DestTo, ResGrp) := DeliveredResidualVolume_PARAM(term, millsrc, gRes, DestTo, ResGrp);
                        
                        
                        !block! ITEMS Always Written / Read
                        !        read ManagementUnits_txt from table dbManagementUnits_txt in  replace mode; !mu
                        !        read AllDestinations_txt from table dbAllDestinations_txt in replace mode;      !dest
                        !        !read Obj_Identifiers_txt from table dbObj_Identifiers_txt in  replace mode;     !obj_id
                        !        read Blocks_txt from table dbBlocks_txt in replace mode;                                        !blk
                        !endblock;
                        
                        !return 1 ;
                        !ReadSelectedMapParameters;
                    }
                }
                Procedure ReadSelectedMapParameters {
                    Body: {
                        for ptm | ParametersToImport_Selected(ptm) do
                        	switch (ptm) do
                        	'ManagementUnits_txt' :
                        		read from table dbManagementUnits_txt in  merge mode;
                        	'AllDestinations_txt' :
                        		read from table dbAllDestinations_txt in merge mode;      !dest
                        	'Blocks_txt' :
                        		read from table dbBlocks_txt in merge mode;
                        
                        	'obj_Selected' :
                        		read obj_Selected from table dbobj_Selected in  merge mode;
                        	'Obj_Identifiers_txt' :
                        		read from table dbObj_Identifiers_txt in  merge mode;
                        	'obj_Weights' :
                        		read obj_Weights from table dbobj_Weights in  merge mode;
                        	'MU_Block_Relation' :
                        		read MU_Block_Relation from table dbMU_Block_Relation in  merge mode;
                        	'cPrG' :
                        		read cPrG from table dbcPrG in  merge mode;
                        	'cMillSector' :
                        		read cMillSector from table dbcMillSector in  merge mode;
                        	'EquivalentProducts' :
                        		read EquivalentProducts from table dbEquivalentProducts in  merge mode;
                        	'InitialGS' :
                        		read InitialGS from table dbInitialGS in  merge mode;
                        
                        		/*  Order is important because of index domains /**/
                        		!debuggerbreakpoint;
                        	'UsesProducts' :
                        		read UsesProducts from table dbUsesProducts in  merge mode;
                        	'ProducesResiduals' :
                        		read ProducesResiduals from table dbProducesResiduals in  merge mode;
                        
                        	'HaulTime' :
                        		read HaulTime from table dbHaulTime in  merge mode;
                        	'VolumePerLoad' :
                        		read VolumePerLoad from table dbM3PerLoad in  merge mode;
                        	'LoadingCostPerLoad' :
                        		read LoadingCostPerLoad from table dbLoadingCostPerLoad in  merge mode;
                        	'HaulCostPerUnit' :
                        		read HaulCostPerUnit from table dbHaulCostPerUnit in  merge mode;
                        	'UsesResiduals' :
                        		read UsesResiduals from table dbUsesResiduals in  merge mode;
                        	'ProductsUsed_PrGrp' :
                        		read ProductsUsed_PrGrp from table dbProductsUsed_PrGrp in  merge mode;
                        	'ResidualsUsed_PrGrp' :
                        		read ResidualsUsed_PrGrp from table dbResidualsUsed_PrGrp in  merge mode;
                        	'ResidualsProduced' :
                        !		read ResidualsProduced from table dbResidualsProduced in  merge mode;
                        	'TreesFlow' :
                        		read TreesFlow from table dbTreesFlow in  merge mode;
                        	'ResidualFlow' :
                        		read ResidualFlow from table dbResidualFlow in  merge mode;
                        
                        		! Mill Demand uses compound indices .... must use intermediate parameter T_
                        		'MillDemand_PrGrp' :
                        				read T_MillDemand_PrGrp from table dbMillDemand_PrGrp in merge mode;
                        				for ((ti,tj) | sum((dest,PrGrp,tt), T_MillDemand_PrGrp(dest,PrGrp,tt,ti,tj)) ) do
                        						MillDemand_PrGrp((dest,PrGrp,tt,tp) | ( ti = tp.ts and tj = tp.tf ))
                        						:= T_MillDemand_PrGrp(dest,PrGrp,tt,ti,tj) ;
                        				endfor;
                        
                        
                        		'MillResidualDemand_PrGrp':
                        				read T_MillResidualDemand_PrGrp from table dbMillResidualDemand_PrGrp in merge mode;
                        				for ((ti,tj) | sum((dest,PrGrp,tt), T_MillResidualDemand_PrGrp(dest,PrGrp,tt,ti,tj)) ) do
                        						MillResidualDemand_PrGrp((dest,PrGrp,tt,tp) | ( ti = tp.ts and tj = tp.tf ))
                        						:= T_MillResidualDemand_PrGrp(dest,PrGrp,tt,ti,tj) ;
                        				endfor;
                        
                        		'MUxy':
                        			read MUxy from table dbMUxy in merge mode;
                        		'BlkXY':
                        			read BLKxy from table dbBLKxy in merge mode;
                        		'MillXY':
                        			read Millxy from table dbMillxy in merge mode;
                        
                        		! dk: Sep 2011 - added to permit wood flow mapping
                        		'DeliveredBlockVolume_VAR':
                        			MapResultsOnly := 1;
                        			!read from table dbDeliveredBlockVolume_VAR  ;
                        			!read DeliveredBlockVolume_VAR from table dbDeliveredBlockVolume_VAR  in  merge mode;
                        
                        		'DeliveredResidualVolume_VAR' :
                        			MapResultsOnly := 1;
                        			!read from table dbDeliveredResidualVolume_VAR ;
                        			!read DeliveredResidualVolume_VAR from table dbDeliveredResidualVolume_VAR   in  merge mode;
                        
                        		default:
                        			DialogError(FormatString("What should be done with '%e'?",ptm),"No Action Specified");
                        			!return 0;
                        
                        	endswitch;
                        endfor;
                    }
                }
                Procedure SetIndexDomainsFromFlowData {
                    Body: {
                        block	! set index domains etc
                        	!-----------------------------
                        	!--- UsesProduct
                        	UsesProducts(dest
                        		|  exists( (term,src,prd,gprgrp) | DeliveredBlockVolume_PARAM(term, src, prd, dest, gPrGrp))
                        		) := 1;
                        
                        	!--- ProducesResiduals --- must preceed Haultime because src depends on ProducesResiduals
                        	DestReceivingWood
                        		:= { dest |exists( (term,blk,prd,gPrGrp) | DeliveredBlockVolume_PARAM(term, blk, prd, dest, gPrGrp)) } ;
                        	DestSendingResiduals
                        		:= { dest | exists( (term,gRes,DestTo,ResGrp) | DeliveredResidualVolume_PARAM(term, dest, gRes, DestTo, ResGrp)) } ;
                        	ProducesResiduals((dest) | DestReceivingWood(dest) and DestSendingResiduals(dest) ) := 1;
                        	!ProducesResiduals(dest) := 1 $ [
                        	!exists( (term,blk,prd,gPrGrp) | DeliveredBlockVolume_PARAM(term, blk, prd, dest, gPrGrp))
                        	!and
                        	!exists( (term,gRes,DestTo,ResGrp) | DeliveredResidualVolume_PARAM(term, dest, gRes, DestTo, ResGrp))
                        	!];
                        
                        	!---PermittedRoutes ... depends on haultime
                        	!	Can't use src, because src depends on HaulTime
                        	HaulTime((blk, dest)
                        		| not (HaulTime(blk, dest) ) !and HaulTime(blk, dest) <= MaxAllowedHaultime)
                        		and [
                        		 exists( (term,prd,gprgrp) | DeliveredBlockVolume_PARAM(term, blk, prd, dest, gPrGrp))
                        		 ]
                        		) := MaxAllowedHaultime $  (HaulTime(blk, dest) <= MaxAllowedHaultime) ;
                        
                        	HaulTime((DestFrom, dest)
                        		| not (HaulTime(DestFrom, dest) ) !and HaulTime(DestFrom, dest) <= MaxAllowedHaultime)
                        		and [
                        		 exists( (term,gres,resgrp) | DeliveredResidualVolume_PARAM(term, DestFrom, gRes, Dest, ResGrp))
                        		 ]
                        		) := MaxAllowedHaultime  $  (HaulTime(DestFrom, dest) <= MaxAllowedHaultime) ;
                        	!--- GrowingStock
                        	InitialGS((blk, prd) | exists( (term,dest,gprgrp)
                        		|  DeliveredBlockVolume_PARAM(term, blk, prd, dest, gPrGrp)) )
                        		:= sum[(term,dest,gprgrp) ,DeliveredBlockVolume_PARAM(term, blk, prd, dest, gPrGrp) ]
                        			/ PercentBlockAvailable(blk);
                        
                        	if IsSelected(__IncludeOnlyAvailableBlocks) then
                        		PercentBlockAvailable((blk) | not PercentBlockAvailable(blk)) := 1;
                        		InitialGS(blk, prd) /= PercentBlockAvailable(blk);
                        		endif;
                        
                        	!--- Destinations
                        	if IsSelected(__IncludeOnlyAvailableMills) then
                        		IncludeMill(dest
                        			|  exists( (term,src,prd,gprgrp) | DeliveredBlockVolume_PARAM(term, src, prd, dest, gPrGrp))
                        			or  exists( (term,src,gRes,ResGrp) | DeliveredResidualVolume_PARAM(term, src, gRes, Dest, ResGrp))
                        			) := 1;
                        		endif;
                        
                        	!--- ProductsUsed
                        	ProductsUsed_PrGrp((dest,PrGrp)
                        		|  exists( (term,blk,prd) | DeliveredBlockVolume_PARAM(term, blk, prd, dest, PrGrp))
                        		) := 1;
                        
                        
                        	!--- UsesResiduals
                        	UsesResiduals(dest
                        		|  exists( (term,src,gRes,ResGrp) | DeliveredResidualVolume_PARAM(term, src, gRes, Dest, ResGrp))
                        		) := 1;
                        	!--- ResidualsUsed
                        	ResidualsUsed_PrGrp((dest,ResGrp) |  exists( (term,src,gres)
                        		| DeliveredResidualVolume_PARAM(term, src, gRes, Dest, ResGrp))
                        		) := 1;
                        	!---Product Groupings
                        	cPrG((gPrGrp, gpr) | exists((term,blk,dest) | DeliveredBlockVolume_PARAM(term, blk, gpr, dest, gPrGrp) ) ) := 1;
                        	cPrG((gPrGrp, gpr) | exists((term,dest,DestTo) | DeliveredResidualVolume_PARAM(term, dest, gpr, DestTo, gPrGrp) ) ) := 1;
                        
                        	!---ResidualsProduced
                        	ResidualsProduced((dest, gpr, res)| ProducesResiduals(dest) ):=
                        		sum[ (term,DestTo,ResGrp) | cPrG(ResGrp, res) ,DeliveredResidualVolume_PARAM(term, dest, res, DestTo, ResGrp) ]
                        		/$
                        		sum[ (term,blk,PrGrp) | cPrG(PrGrp, gpr) ,DeliveredBlockVolume_PARAM(term, blk, gpr, dest, PrGrp) ]
                        		;
                        
                        endblock;
                        !DeliveredBlockVolume_VAR(term, blk, prd, dest, gPrGrp) := DeliveredBlockVolume_PARAM(term, blk, prd, dest, gPrGrp);
                        !DeliveredResidualVolume_VAR(term, src, gRes, DestTo, ResGrp) := DeliveredResidualVolume_PARAM(term, src, gRes, DestTo, ResGrp);
                        !
                    }
                    Set DestReceivingWood {
                        SubsetOf: Destinations;
                    }
                    Set DestSendingResiduals {
                        SubsetOf: Destinations;
                    }
                }
                Procedure BuildMuProxies {
                    Body: {
                        !if DialogAsk(FormatString("This procedure will build proxy MUs assuming that blocks are labelled XXXXnnnn\n\n%s"
                        !				,"Do you wish to continue?"),"Yes","No","Cancel","Build MU Proxies") <> 1 then return 0; endif;
                        
                        !--- Build set of proxy MUs from base part of Block name
                        for blk in Blocks do
                        	s := FormatString("%e",blk);
                        	i := FindAnyString(s, "0123456789",1);		! Find the start position of ending digitstring e.g. nnn in ABi_nnn
                        	if i > 0 then
                        		s := SubString(s,1,i-1);
                        		SetElementAdd(ProxyMUs , _pmu, s);
                        		ProxyMU_BlockRelation(blk) := _pmu;
                        	endif;
                        endfor;
                        
                        !--- Guess at MU
                        !empty cMU_ProxyMU;
                        for (pmu)  do
                        	s := StringToUpper( FormatString("%e",pmu) );
                        	i := StringLength(s);
                        	cMU_ProxyMU(pmu) := First(mu_s | StringToUpper( SubString(FormatString("%e",mu_s ),1,i)) = s
                        										and not exists(pmu1 | cMU_ProxyMU(pmu1) = mu_s)
                        								)	;
                        endfor;
                    }
                    StringParameter s;
                    Parameter i;
                }
                Procedure AddProxyMUsToSetMU {
                    Body: {
                        empty ManagementUnits;
                        
                        
                        if DialogGetNumber("How many initial characters should be used for MU?",n,0,"Input Response") < 1 then
                        	return 0;
                        endif;
                        
                        for pmu do
                        	s := SubString(FormatString("%e",pmu),1,n);
                        	SetElementAdd(ManagementUnits , _mu, s);
                        	!_mu := ElementCast(ManagementUnits,pmu,1);
                        
                        	cMU_ProxyMU( pmu ) := _mu;
                        endfor;
                        
                        MU_Block_Relation((mu, blk)
                        	| SubString(FormatString("%e",mu),1,n) = SubString(FormatString("%e",blk),1,n)
                        
                        ) := 1 ;
                    }
                    StringParameter s;
                    Parameter n {
                        Range: integer;
                        Unit: 1;
                        Default: 3;
                    }
                }
                Procedure AssignProxyMUsToMuBlockAssociations {
                    Body: {
                        MU_Block_Relation((mu, blk) | mu = cMU_ProxyMU( ProxyMU_BlockRelation(blk) ) ) := 1 ;
                    }
                }
                DatabaseProcedure DB_Procedure_1 {
                    DataSource: "TenureDatabase.udl";
                    StoredProcedure: AccessTableNames('DeliveredBlockVolume_VAR');
                    Property: UseResultSet;
                    Mapping: {
                        "term"      --> term,
                        "blk"        --> blk,
                        "dest"      --> dest,
                        "prd"      --> prd,
                        "gPrGrp"	--> PrGrp,
                        "DeliveredBlockVolume_VAR" --> DeliveredBlockVolume_Param(term, blk, prd, dest, PrGrp)
                    }
                }
            }
            Parameter sasdfa {
                IndexDomain: {
                    (destFrom, DestTo)
                    !| not (HaulTime(src, dest) and HaulTime(src, dest) <= MaxAllowedHaultime)
                    !		and [
                    !		 exists( (term,prd,gprgrp) | DeliveredBlockVolume_PARAM(term, src, prd, dest, gPrGrp))
                    !		 or exists( (term,gres,resgrp) | DeliveredResidualVolume_PARAM(term, src, gRes, Dest, ResGrp))
                    !		 ]
                }
                Range: binary;
                Definition: {
                    !1
                    not (HaulTime(destfrom, DestTo) and HaulTime(destfrom, DestTo) <= MaxAllowedHaultime)
                    		and [
                    		 exists( (term,prd,gprgrp) | DeliveredBlockVolume_PARAM(term, destfrom, prd, DestTo, gPrGrp))
                    		 or exists( (term,gres,resgrp) | DeliveredResidualVolume_PARAM(term, destfrom, gRes, DestTo, ResGrp))
                    		 ]
                }
            }
            Procedure Close_Access_Link {
                Body: {
                    CloseDataSource("TenureDatabase.udl");
                }
            }
            Procedure SelectAllParameters {
                Body: {
                    !if ActivePageTagName = "Export" then
                    !       ParametersToExport_Selected(pte) :=1;
                    !elseif ActivePageTagName = "Import" then
                    !       ParametersToImport_Selected(pti) :=1;
                    !else
                            switch (dialogAsk("Which to you want to Select?",
                                    button1:"Export",button2:"Import",button3:"Both")) do
                                    1:      ParametersToExport_Selected(pte) :=1;
                                    2:      ParametersToImport_Selected(pti) :=1;
                                    default:
                                            ParametersToExport_Selected(pte) :=1;
                                            ParametersToImport_Selected(pti) :=1;
                            endswitch;
                    !endif;
                    !
                }
            }
            Procedure SelectParametersForMapping {
                Body: {
                    switch (dialogAsk("Which to you want to Select?", title:"Select Parameters For Mapping",
                            button1:"Export",button2:"Import",button3:"Both")) do
                            1:      ParametersToExport_Selected(ptm) :=1;
                            2:      ParametersToImport_Selected(pti | pti in ParametersToMap) :=1;
                            default:
                                    ParametersToExport_Selected(ptm) :=1;
                                    ParametersToImport_Selected(pti | pti in ParametersToMap) :=1;
                    endswitch;
                }
            }
            Procedure ClearAllParameters {
                Body: {
                    !if ActivePageTagName = "Export" then
                    !       ParametersToExport_Selected(pte) :=0;
                    !elseif ActivePageTagName = "Import" then
                    !       ParametersToImport_Selected(pti) :=0;
                    !else
                            switch (dialogAsk("Which to you want to Clear?",
                                    button1:"Export",button2:"Import",button3:"Both")) do
                                    1:      ParametersToExport_Selected(pte) :=0;
                                    2:      ParametersToImport_Selected(pti) :=0;
                                    default:
                                            ParametersToExport_Selected(pte) :=0;
                                            ParametersToImport_Selected(pti) :=0;
                            endswitch;
                    !endif;
                    !
                }
            }
            Procedure WriteParametersToExport {
                Body: {
                    if dialogAsk(
                     message:formatString("This will overwrite existing data in the database.\n\nDo you wish to continue?%s",""),
                            title:"Export data to Access", button1:"Yes",button2:"No") = 2 then return -1; endif;
                    
                    write to table dbParametersToExport in dense replace mode;
                    write to table dbParametersToImport in dense replace mode;
                    Close_Access_Link;
                }
            }
            Procedure SwitchAccessFile {
                Body: {
                    if (FileExists ( MSAccess_filename ) = 0 ) then
                    	if MSAccess_filename <> "" then
                        	DialogError("The file '" + MSAccess_filename + "' not found .udl file not found;");     endif;
                        if ( FileSelect( MSAccess_filename,extension:".udl",title:" Select database file") = 0)
                            then return 0; endif;
                    else
                        !if OpenDocument(MSAccess_filename) = 0 then  !OpenDocument doesn't work in AIMMX x64
                        Execute(
                    	executable  :  "Rundll32.exe",
                    	commandline :  "\"C:\\Program Files (x86)\\Common Files\\System\\OLE DB\\oledb32.dll\" , OpenDSLFile " + MSAccess_filename,
                    	wait        :  0,
                    	minimized   :  0 );
                        !endif;
                    endif;
                }
            }
            Procedure EmptyAccessTables {
                Body: {
                    !switch (dialogAsk("Which tables to you wish to empty in the linked Access database:",
                    !        button1:"None", button2:"Selected", button3:"All","Clear tables in Access")) do
                    !        1:      return 1;
                    !        2:      empty dbEquivalentProducts;
                    !        3:
                    !endswitch;
                    !DebuggerBreakpoint;
                    DirectSQL(MSAccess_filename, "Delete * from [tblManagementUnits_txt]");
                    DirectSQL(MSAccess_filename, "Delete * from [tblAllDestinations_txt]");
                    DirectSQL(MSAccess_filename, "Delete * from [tblBlocks_txt]");
                    DirectSQL(MSAccess_filename, "Delete * from [tblObj_Identifiers_txt]");
                    
                    for (pte | ParametersToExport_Selected(pte) and AccessTableNames(pte)<>"") do
                            DirectSQL(MSAccess_filename,
                                    FormatString("Delete * from [%s]",AccessTableNames(pte)));
                    endfor;
                }
            }
            Procedure EmptyIdentifiers {
                Body: {
                    empty ManagementUnits,Destinations,AllLocations,Obj_Identifiers,Blocks;
                    cleandependents;
                }
            }
        }
        Section Quality_Assurance {
            Comment: {
                "This section contains the procedures used for quality assurance.
                
                Quality assurance is implemented by running a growing collection of tests
                A test typically consists of
                - reading an case (or creating a case from datasets),
                - solving the model,
                
                - generating various output files,
                - possibly:
                  - updating the input,
                  - solving the model again,
                  - generating other output files.
                
                The MSDOS batch file that started a test will then call a differencing program to
                verify against known results.
                
                To obtain some flexibility in creating a test Command Action Tables are used.
                A single command table defines a single test.
                Each numbered line in a command action table simulates a major action of SFMM.  The commands
                are executed in numerical order (smallest to largest).
                
                A command action table is an AIMMS 3 composite table.  For example:
                
                COMPOSITE TABLE:
                  qacmdno    qacmdname             qacmdarg1   qacmdarg2    qacmdarg3
                ! -------    ---------             ---------   ---------    ---------
                     10      \"load_ascii\"                                               ! Load the data from inputs\\sample_1.inp
                     20      \"echo_input\"                                               ! Echo the input to the file inputs\\sample_1.ech
                
                                                                                        ! If qacmdarg1 is non-empty then generate a .dmp file
                                                                                        ! with the contents of all computed parameters just
                                                                                        ! before the solve statement.
                     30      \"solve\"               \"yes\"                                ! Compute parameters, generated model and solve it.
                
                     40      \"FARM_Export\"                                              ! Produce a FARM export file inputs\\sample_1.001
                
                                                                                        ! Load the marginal report configuration parameters
                                                                                        ! from the file inputs\\sample_1a.mer
                     50      \"Marginal_Report\"                                          ! Produce a marginal report file into inputs\\sample_1.mrg
                
                                                                                        ! Load the long report output configuration parameters
                                                                                        ! from the file inputs\\sample_1b.mer
                     60      \"Long_Report\"         \"sample_1b\"                          ! Produce a long report into the file inputs\\sample_1.rep
                
                     70      \"Short_Report\"                                             ! Produce a short report into the file inputs\\sample_1.shr
                
                                                                                        ! Produce a Stanley choices.txt file and copy it to
                     80      \"Stanley_Export\"                                           ! the file inputs\\sample_1.txt
                
                
                Please adhere to the following conventions for file name extensions:
                input:
                    .sca     SFMM Command Action table
                    .inp     input file: Data file
                    .mer     merge file: typically contains output control parameters
                output:
                    .001     Farm export file (in the quality assurance procedure we use all wild life species)
                    .dmp     Output from qapreslv.  qapreslv is called just before the actual SOLVE statement.
                             The output format is most suited to differencing programs comparing data.
                    .ech     echo of input
                    .mlg     copy of messages.log from an actual run.
                             Note that this copy is executed by sfmmqaw.bat but that this file is not used for
                             differencing.
                    .mrg     Marginal report (all equation types/50 % from top)
                    .rep     Long report (usually from all reporting options at least two or three periods)
                    .shr     Short report
                    .txt     copy of the Stanley choices.txt file
                
                
                
                IMPLEMENTATION:
                ---------------
                
                It should be possible to do a complete quality assurance test unattended.
                This implies that all dialogs should be suppressed.
                
                There are two tricks used to implement this:
                1) A global parameter Quality_Assurance_Mode is declared that is 0 during
                   normal operation and 1 during a Quality Assurance test.
                2) Consider a major procedure of SFMM such as reading an input file:
                   SFMMImport220text.
                   Such a procedure is broken up into:
                   SFMMImport220text and SFMMImport220text_work
                   whereby SFMMImport220text      does the usual interactive part
                                                  asking for filenames etc, and
                           SFMMImport220text_work does the actual reading work.
                   In addition, in this section a procedure SFMMImport220text_QA is created
                   that gets the arguments for SFMMImport220text_work from a line in the command table
                   and passes these arguments on (possibly after conversion and checking).
                
                To add a new type of action you should:
                - Add a procedure ending in _QA to the section Action_Procedures
                  and make sure it calls the workhorse implementing the actual action.
                - Add the name of the action to the local set ImplementedQualityAssuranceActions
                  of the procedure QA_Interpreter.
                - Add a call to the new _QA procedure in the body of the procedure QA_Interpreter"
            }
            Section General {
                DeclarationSection Quality_Assurance_Declarations {
                    Parameter QualityAssuranceMode {
                        Range: binary;
                        Property: NoSave;
                        InitialData: 0;
                        Comment: {
                            "This parameter is 0 during normal interactive operation of the SFMM model.
                            This parameter is 1 during quality assurance checking of the SFMM model."
                        }
                    }
                    Set QACommandNumbers {
                        SubsetOf: Integers;
                        Index: qacmdno;
                        Property: NoSave;
                        Comment: "Artificial set used to identify the individual commands in a SFMM Command Table";
                    }
                    StringParameter QAcmdname {
                        IndexDomain: (qacmdno);
                        Property: NoSave;
                    }
                    StringParameter QAcmdarg1 {
                        IndexDomain: (qacmdno);
                        Property: NoSave;
                    }
                    StringParameter QAcmdarg2 {
                        IndexDomain: (qacmdno);
                        Property: NoSave;
                    }
                    StringParameter QAcmdarg3 {
                        IndexDomain: (qacmdno);
                        Property: NoSave;
                    }
                    StringParameter QAcmddir {
                        Property: NoSave;
                        Comment: "working directory name of test";
                    }
                    StringParameter QAcmdtestname {
                        Property: NoSave;
                        Comment: "Name of the test: it acts as a base name for various input and output files";
                    }
                    File QAcmdfile {
                        Name: QAcmdfilename;
                        Comment: "The commands for the Quality Assurance Interpreter are contained in this file.";
                    }
                    StringParameter QAcmdfilename {
                        Property: NoSave;
                        Comment: "Location of file that contains the .sct";
                    }
                    File QAerrfile {
                        Name: QAerrfilename;
                        Comment: "The error messages from the Quality Assurance interpreter will be sent to this file.";
                    }
                    StringParameter QAerrfilename {
                        Property: NoSave;
                        Comment: "Location of file that contains the error messages of the Quality Assarance Interpreter";
                    }
                }
                Procedure Main_Quality_Assurance {
                    Body: {
                        ! The first session argument (command line argument after the project) is the testing directory.
                        ! The second session argument is the base of name of the test.
                        
                        ! QA Testing is invoked from the commandline
                        
                        !	 aimms.exe --run-only Test_Quality_Assurance Tenure.prj directory file
                        ! file is the .sca (source command) file without the .sca extension
                        
                        If ( ( SessionArgument( 1, QAcmddir      ) ) and
                             ( SessionArgument( 2, QAcmdtestname ) )     ) then
                        
                          Work_Quality_Assurance( QAcmddir, QAcmdtestname );
                        
                        EndIf ; ! If there is a session argument.
                    }
                    Comment: "This is the procedure that interprets the commands in the .sca table.";
                }
                Procedure Work_Quality_Assurance {
                    Arguments: (cmddir,cmdtestname);
                    Body: {
                        QualityAssuranceMode := 1 ;
                        
                        QAcmdfilename := cmddir + "\\" + cmdtestname + ".sca" ;
                        QAerrfilename := cmddir + "\\" + cmdtestname + ".err" ;
                        
                        display cmddir, cmdtestname, QAcmdfilename ;
                        
                        If ( FileExists( QAcmdfilename ) ) then
                        
                          ! write QAcmdname, QAcmdarg1, QAcmdarg2, QAcmdarg3 to file QAcmdfile; !dk:
                          Read from file QAcmdfile ; ! Read all actions from the command file.
                        
                          display QAcmdname, QAcmdarg1, QAcmdarg2, QAcmdarg3 ;
                        
                          for ( QAcmdno | ( StringLength(QAcmdname(QAcmdno)) > 0) ) do
                            ! QAErrorMessage("Executing command: " + QAcmdno + "  " + QAcmdname(QAcmdno)+ "  '" + QAcmdarg1(QAcmdno)+ "'" );
                            QA_Interpreter(cmddir,cmdtestname,QAcmdname(QAcmdno),QAcmdarg1(QAcmdno),
                                           QAcmdarg2(QAcmdno),QAcmdarg3(QAcmdno));
                          endfor ;
                        Else
                          QAErrorMessage( "The Command Action file " + QAcmdfilename + " has not been found.");
                        EndIf ;
                    }
                    DeclarationSection Argument_Declarations {
                        StringParameter cmddir {
                            Property: Input;
                        }
                        StringParameter cmdtestname {
                            Property: Input;
                        }
                    }
                    DeclarationSection Local_Declarations;
                }
                Procedure QA_test {
                    Body: {
                        !test the QA process
                        
                        Work_Quality_Assurance("testing","plf_sel");
                        !Work_Quality_Assurance("Sample Inputs","Sampl_2");
                    }
                }
                Procedure QA_Interpreter {
                    Arguments: (dirname,testname,cmdname,cmdarg1,cmdarg2,cmdarg3);
                    Body: {
                        QA_Action := StringToElement( ImplementedQualityAssuranceActions, cmdname, create:0);
                        If ( QA_Action ) then
                          switch   QA_Action   DO
                            'Case_Save'        	: Case_Save_QA(cmdarg1 + " QA" );
                            'Case_Load'        	: Case_Load_QA(cmdarg1 );
                            'Solve'           	: Solve_QA( dirname + "\\" + testname + ".dmp" , cmdarg1 ) ;
                            'Dataset_Load'      : Dataset_Load_QA( cmdarg1,cmdarg2 ) ;
                            'Dataset_Save'      : Dataset_Save_QA( cmdarg1,cmdarg2 ) ;
                            'Dataset_Export'    : Dataset_Export_QA( cmdarg1,cmdarg2, dirname + "\\" + cmdarg3 ) ;
                            default            	: QAErrorMessage("QA_Interpreter: Unknown action requested") ;
                        
                          endswitch ;
                        Else
                          QAErrorMessage("QA_Interpreter: Action '" + QA_Action + "'is not an element of the set ImplementedQualityAssuranceActions") ;
                        EndIf ;
                        /*
                            'Load_Ascii'       :           SFMMImport220text_QA( dirname + "\\" + testname + ".inp" );
                            'Echo_input'       :                  Echo_Input_QA( dirname + "\\" + testname + ".ech" );
                            'Solve'            :                       Solve_QA( dirname + "\\" + testname + ".dmp" , cmdarg1 ) ;
                            'FARM_export'      :                 Export_FARM_QA( dirname + "\\" + testname + ".001" );
                            'Marginal_Report'  : Constraint_Marginals_Report_QA( dirname + "\\" + testname + ".mrg" );
                            'Long_Report'      :                 Long_Report_QA( dirname + "\\" + testname + ".rep" , dirname + "\\" + cmdarg1 + ".upd");
                            'Short_report'     :                Short_Report_QA( dirname + "\\" + testname + ".shr" );
                            'Stanley_export'   :             Stanley_Choices_QA( dirname + "\\" + testname + ".txt" );
                            'Case_Save'        :                   Case_Save_QA(                  testname + " QA run Barrier Dual Crossover" );
                        !dk: Nov 2006
                            'Case_Load'         :                   Case_Load_QA(                   cmdarg1 );
                            'Back_Door_Load'    :              Back_Door_Load_QA( dirname + "\\" +  cmdarg1 );
                            default            : QAErrorMessage("QA_Interpreter: Unknown action requested") ;
                        
                        /**/
                    }
                    Comment: "Note that cmdarg2 and cmdarg3 are not yet used but for future extensions.";
                    DeclarationSection Argument_Declarations {
                        StringParameter cmdname {
                            Property: Input;
                        }
                        StringParameter cmdarg1 {
                            Property: Input;
                        }
                        StringParameter cmdarg2 {
                            Property: Input;
                        }
                        StringParameter cmdarg3 {
                            Property: Input;
                        }
                        StringParameter dirname;
                        StringParameter testname;
                    }
                    DeclarationSection Local_Declarations {
                        Set ImplementedQualityAssuranceActions {
                            InitialData: {
                                data {
                                       'Case_Load'       ! Opens a case
                                       ,'Case_Save'       ! Stores the solved case
                                       ,'Dataset_Load'	! loads a dataset
                                      ,'Dataset_Save'	! saves a dataset of given category
                                      ,'Dataset_Export'		!writes dataset to text file
                                      , 'Solve'			  ! Solve the loaded case
                                     }
                            }
                        }
                        ElementParameter QA_Action {
                            Range: ImplementedQualityAssuranceActions;
                        }
                    }
                }
                Procedure QAErrorMessage {
                    Arguments: (Msg);
                    Body: {
                        put QAerrfile ;
                        put msg, / ;
                        putclose ;
                    }
                    StringParameter Msg {
                        Property: Input;
                    }
                }
                Procedure qapreslv {
                    Arguments: (presolve_dumpfilename);
                    Body: {
                        If QualityAssuranceMode then
                        /*
                            PUT    A7PRW    ;
                            PUT    "SCALAR A7PRWTHRSH / 1.0e-6 / ;" /   ;
                        
                            PUT    "$phantom phantom"  /  ;
                        
                            PUT // "parameter Sel_Harv_Succession(mu, allage, ags, ugs, agsph, ugsph) / "/;
                            for ( (mu, allage, ags, ugs, agsph, ugsph) $ Sel_Harv_Succession(mu, allage, ags, ugs, agsph, ugsph)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," . ",
                                agsph.TL:A7PRWLAB,," . ",
                                ugsph.TL:A7PRWLAB,," = ",
                                Sel_Harv_Succession(mu, allage, ags, ugs, agsph, ugsph):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter MaxTend_FC(term, mu, fu, ac, ri, tt) / "/;
                            for ( (term, gsu, fu, ac, ri, tt) $ MaxTend_gsu_FC(term, gsu, fu, ac, ri, tt)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                gsu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                tt.TL:A7PRWLAB,," = ",
                                MaxTend_gsu_FC(term, gsu, fu, ac, ri, tt):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Shw_Delay_Prd(mu, fu, ri, ow) / "/;
                            for ( (mu, fu, ri, ow) $ ( Shw_Delay_Prd(mu, fu, ri, ow) <> inf )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                ow.TL:A7PRWLAB,," = ",
                                Shw_Delay_Prd(mu, fu, ri, ow):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter ResrveArea(mu, fu, ac, rsv) / "/;
                            for ( (mu, fu, ac, rsv) $ ResrveArea(mu, fu, ac, rsv)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                rsv.TL:A7PRWLAB,," = ",
                                ResrveArea(mu, fu, ac, rsv):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_Min_AGS_Improvement_Prop(mu, allage) / "/;
                            for ( (mu, allage) $ ( Sel_Harv_Min_AGS_Improvement_Prop(mu, allage) <> 0.1 )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Harv_Min_AGS_Improvement_Prop(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter FU_Stability_Area_gsu(term, gisu, fu) / "/;
                            for ( (term, gisu, fu) $ FU_Stability_Area_gsu(term, gisu, fu)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                gisu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                FU_Stability_Area_gsu(term, gisu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                            PUT // "parameter Sel_AHA_Gross(sched, mu, allage) / "/;
                            for ( (sched, mu, allage) $ Sel_AHA_Gross(sched, mu, allage)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_AHA_Gross(sched, mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter RegenArea_Dom(term, mu, fu, ri) / "/;
                            for ( (term, mu, fu, ri) $ RegenArea_Dom(term, mu, fu, ri)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                RegenArea_Dom(term, mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Harv_VolAnn_mu_fu_global_sp_pr(sched, mu, fu_global, sp, pr) / "/;
                            for ( (sched, mu, fu_global, sp, pr) $ Harv_VolAnn_mu_fu_global_sp_pr(sched, mu, fu_global, sp, pr)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                Harv_VolAnn_mu_fu_global_sp_pr(sched, mu, fu_global, sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Solve_End = ", Solve_End:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter AvailArea_Dom(mu, fu, ri) / "/;
                            for ( (mu, fu, ri) $ AvailArea_Dom(mu, fu, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                AvailArea_Dom(mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Net_Operable_mu_fu_global(mu, fu_global) / "/;
                            for ( (mu, fu_global) $ Initial_Net_Operable_mu_fu_global(mu, fu_global)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                Initial_Net_Operable_mu_fu_global(mu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Areas_Converted_to_NonFor_nfr(term, mu, nfr) / "/;
                            for ( (term, mu, nfr) $ Sel_Areas_Converted_to_NonFor_nfr(term, mu, nfr)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," = ",
                                Sel_Areas_Converted_to_NonFor_nfr(term, mu, nfr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Long_Report_Options(rprt, term) / "/;
                            for ( (rprt, term) $ Long_Report_Options(rprt, term)) do  ;
                                PUT    rprt.TL:A7PRWLAB,," . ",
                                term.TL:A7PRWLAB,," = ",
                                Long_Report_Options(rprt, term):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter TendCost(mu, fu, ac, ri, tt, fn, an, rn) / "/;
                            for ( (mu, fu, ac, ri, tt, fn, an, rn) $ TendCost(mu, fu, ac, ri, tt, fn, an, rn)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                tt.TL:A7PRWLAB,," . ",
                                fn.TL:A7PRWLAB,," . ",
                                an.TL:A7PRWLAB,," . ",
                                rn.TL:A7PRWLAB,," = ",
                                TendCost(mu, fu, ac, ri, tt, fn, an, rn):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Deferred_Area_Sel = ", Deferred_Area_Sel:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "set sched(term) / "/;
                            for ( term$ sched(term)) do  ;
                                PUT    term.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Shw_Entry_Age(mu, fu, ow) / "/;
                            for ( (mu, fu, ow) $ ( Shw_Entry_Age(mu, fu, ow) <> inf )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ow.TL:A7PRWLAB,," = ",
                                Shw_Entry_Age(mu, fu, ow):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter NaturRehab_Wrk(mu, nfr, fu, ac, ri) / "/;
                            for ( (mu, nfr, fu, ac, ri) $ NaturRehab_Wrk(mu, nfr, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                NaturRehab_Wrk(mu, nfr, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "set shw(fu) / "/;
                            for ( fu$ shw(fu)) do  ;
                                PUT    fu.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Areas_Reserved_from_Harvest(sched, mu, allage) / "/;
                            for ( (sched, mu, allage) $ Sel_Areas_Reserved_from_Harvest(sched, mu, allage)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Areas_Reserved_from_Harvest(sched, mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter OperWindow(mu, fu, ri, ow) / "/;
                            for ( (mu, fu, ri, ow) $ ( OperWindow(mu, fu, ri, ow) <> inf )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                ow.TL:A7PRWLAB,," = ",
                                OperWindow(mu, fu, ri, ow):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Net_Operable_mu_fu_ri(mu, fu, ri) / "/;
                            for ( (mu, fu, ri) $ Initial_Evenage_Net_Operable_mu_fu_ri(mu, fu, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Net_Operable_mu_fu_ri(mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_Max_AGS_Target_Prop(mu, allage) / "/;
                            for ( (mu, allage) $ ( Sel_Harv_Max_AGS_Target_Prop(mu, allage) <> 0.9 )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Harv_Max_AGS_Target_Prop(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_Volume_pHa_mu_allage(sched, mu, allage) / "/;
                            for ( (sched, mu, allage) $ Sel_Harv_Volume_pHa_mu_allage(sched, mu, allage)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Harv_Volume_pHa_mu_allage(sched, mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter SFMM_solverstat = ", SFMM_solverstat:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter PotHabPrUs_mu(term, mu, wl) / "/;
                            for ( (term, mu, wl) $ PotHabPrUs_mu(term, mu, wl)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                wl.TL:A7PRWLAB,," = ",
                                PotHabPrUs_mu(term, mu, wl):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter SFMM_numequ = ", SFMM_numequ:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter RptOptions(rpt, term) / "/;
                            for ( (rpt, term) $ RptOptions(rpt, term)) do  ;
                                PUT    rpt.TL:A7PRWLAB,," . ",
                                term.TL:A7PRWLAB,," = ",
                                RptOptions(rpt, term):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Area_Succeeding_mu_allage(mu, allage) / "/;
                            for ( (mu, allage) $ Initial_Area_Succeeding_mu_allage(mu, allage)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Initial_Area_Succeeding_mu_allage(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter OperClass(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ OperClass(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                OperClass(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "set ri_a(ri) / "/;
                            for ( ri$ ri_a(ri)) do  ;
                                PUT    ri.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "set ri_b(ri) / "/;
                            for ( ri$ SilviculturalIntensitiesCopy3(ri)) do  ;
                                PUT    ri.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Shw_Stage(mu, fu, ri) / "/;
                            for ( (mu, fu, ri) $ Shw_Stage(mu, fu, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Shw_Stage(mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Area_Deferred_mu_fu_global(mu, fu_global) / "/;
                            for ( (mu, fu_global) $ Initial_Area_Deferred_mu_fu_global(mu, fu_global)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                Initial_Area_Deferred_mu_fu_global(mu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter NaturSuccnPP(mu, fu, ac, ff, af) / "/;
                            for ( (mu, fu, ac, ff, af) $ NaturSuccnPP(mu, fu, ac, ff, af)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ff.TL:A7PRWLAB,," . ",
                                af.TL:A7PRWLAB,," = ",
                                NaturSuccnPP(mu, fu, ac, ff, af):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Harv_Seq(term, mu, fu, ac, ri) / "/;
                            for ( (term, mu, fu, ac, ri) $ Harv_Seq(term, mu, fu, ac, ri)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Harv_Seq(term, mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter i = ", i:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter HarvCost(mu, sp, pr) / "/;
                            for ( (mu, sp, pr) $ HarvCost(mu, sp, pr)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                HarvCost(mu, sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Init_Unadjust_Area_Avail_mu_fu(mu, fu) / "/;
                            for ( (mu, fu) $ Init_Unadjust_Area_Avail_mu_fu(mu, fu)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                Init_Unadjust_Area_Avail_mu_fu(mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter BA_Growth(mu, allage, ba_growth_year) / "/;
                            for ( (mu, allage, ba_growth_year) $ BA_Growth(mu, allage, ba_growth_year)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ba_growth_year.TL:A7PRWLAB,," = ",
                                BA_Growth(mu, allage, ba_growth_year):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Pre_Harv_Dom(mu, allage, ags, ugs) / "/;
                            for ( (mu, allage, ags, ugs) $ Sel_Pre_Harv_Dom(mu, allage, ags, ugs)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," = ",
                                Sel_Pre_Harv_Dom(mu, allage, ags, ugs):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "variable Accum_ReserveArea_mu_fu_ac.lo(term, mu, fu, ac) / "/;
                            for ( (term, mu, fu, ac) $ Accum_ReserveArea_mu_fu_ac.lo(term, mu, fu, ac)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," = ",
                                Accum_ReserveArea_mu_fu_ac.lo(term, mu, fu, ac):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "variable Accum_ReserveArea_mu_fu_ac.up(term, mu, fu, ac) / "/;
                            for ( (term, mu, fu, ac) $ ( Accum_ReserveArea_mu_fu_ac.up(term, mu, fu, ac) <> inf )) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," = ",
                                Accum_ReserveArea_mu_fu_ac.up(term, mu, fu, ac):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "variable Accum_ReserveArea_mu_fu_ac(term, mu, fu, ac) / "/;
                            for ( (term, mu, fu, ac) $ Accum_ReserveArea_mu_fu_ac.l(term, mu, fu, ac)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," = ",
                                Accum_ReserveArea_mu_fu_ac.l(term, mu, fu, ac):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter MinTend_FC(term, mu, fu, ac, ri, tt) / "/;
                            for ( (term, mu, fu, ac, ri, tt) $ MinTend_FC(term, mu, fu, ac, ri, tt)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                tt.TL:A7PRWLAB,," = ",
                                MinTend_FC(term, mu, fu, ac, ri, tt):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Disturb_Successn(mu, fu, fn) / "/;
                            for ( (mu, fu, fn) $ Disturb_Successn(mu, fu, fn)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                fn.TL:A7PRWLAB,," = ",
                                Disturb_Successn(mu, fu, fn):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Init_Adjusted_Area_Avail_mu_fu(mu, fu) / "/;
                            for ( (mu, fu) $ Init_Adjusted_Area_Avail_mu_fu(mu, fu)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                Init_Adjusted_Area_Avail_mu_fu(mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Gross_Operable_mu_allage(mu, allage) / "/;
                            for ( (mu, allage) $ Initial_Gross_Operable_mu_allage(mu, allage)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Initial_Gross_Operable_mu_allage(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Age_Range_FuG(mu, fug, ow) / "/;
                            for ( (mu, fug, ow) $ ( Age_Range_FuG(mu, fug, ow) <> 101 )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fug.TL:A7PRWLAB,," . ",
                                ow.TL:A7PRWLAB,," = ",
                                Age_Range_FuG(mu, fug, ow):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Planned_Harvest_Evenage_Inoperable(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ Planned_Harvest_Evenage_Inoperable(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Planned_Harvest_Evenage_Inoperable(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Init_Adjusted_Area_Avail_mu_allage(mu, allage) / "/;
                            for ( (mu, allage) $ Init_Adjusted_Area_Avail_mu_allage(mu, allage)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Init_Adjusted_Area_Avail_mu_allage(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Allage_Area_Dom(mu, allage, ags, ugs) / "/;
                            for ( (mu, allage, ags, ugs) $ Allage_Area_Dom(mu, allage, ags, ugs)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," = ",
                                Allage_Area_Dom(mu, allage, ags, ugs):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_AGS_Prop(ags, agsph) / "/;
                            for ( (ags, agsph) $ Sel_Harv_AGS_Prop(ags, agsph)) do  ;
                                PUT    ags.TL:A7PRWLAB,," . ",
                                agsph.TL:A7PRWLAB,," = ",
                                Sel_Harv_AGS_Prop(ags, agsph):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Allage_Growstock_Tot(mu, allage, ags, ugs) / "/;
                            for ( (mu, allage, ags, ugs) $ Allage_Growstock_Tot(mu, allage, ags, ugs)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," = ",
                                Allage_Growstock_Tot(mu, allage, ags, ugs):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Area_Factor_Evenage(mu, fu) / "/;
                            for ( (mu, fu) $ ( Area_Factor_Evenage(mu, fu) <> 1 )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                Area_Factor_Evenage(mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Area_Deferred_mu_fu(mu, fu) / "/;
                            for ( (mu, fu) $ Initial_Area_Deferred_mu_fu(mu, fu)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                Initial_Area_Deferred_mu_fu(mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter AC_Limit(ac, ow) / "/;
                            for ( (ac, ow) $ AC_Limit(ac, ow)) do  ;
                                PUT    ac.TL:A7PRWLAB,," . ",
                                ow.TL:A7PRWLAB,," = ",
                                AC_Limit(ac, ow):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Fu_HabUnit_Prop(mu, fu_global, hab) / "/;
                            for ( (mu, fu_global, hab) $ Fu_HabUnit_Prop(mu, fu_global, hab)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," . ",
                                hab.TL:A7PRWLAB,," = ",
                                Fu_HabUnit_Prop(mu, fu_global, hab):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Harvest_Area_Converted_to_NonFor(sched, mu, fu_global) / "/;
                            for ( (sched, mu, fu_global) $ Harvest_Area_Converted_to_NonFor(sched, mu, fu_global)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                Harvest_Area_Converted_to_NonFor(sched, mu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter ReserveArea_mu_fu_ac_rsv(term, mu, fu, ac, rsv) / "/;
                            for ( (term, mu, fu, ac, rsv) $ ReserveArea_mu_fu_ac_rsv(term, mu, fu, ac, rsv)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                rsv.TL:A7PRWLAB,," = ",
                                ReserveArea_mu_fu_ac_rsv(term, mu, fu, ac, rsv):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_UGS_Prop(ugs, ugsph) / "/;
                            for ( (ugs, ugsph) $ Sel_Harv_UGS_Prop(ugs, ugsph)) do  ;
                                PUT    ugs.TL:A7PRWLAB,," . ",
                                ugsph.TL:A7PRWLAB,," = ",
                                Sel_Harv_UGS_Prop(ugs, ugsph):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Post_Harv_Dom(mu, allage, ags, ugs, agsph, ugsph) / "/;
                            for ( (mu, allage, ags, ugs, agsph, ugsph) $ Sel_Post_Harv_Dom(mu, allage, ags, ugs, agsph, ugsph)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," . ",
                                agsph.TL:A7PRWLAB,," . ",
                                ugsph.TL:A7PRWLAB,," = ",
                                Sel_Post_Harv_Dom(mu, allage, ags, ugs, agsph, ugsph):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Reserved_Operable_mu_fu_ri(mu, fu, ri) / "/;
                            for ( (mu, fu, ri) $ Initial_Evenage_Reserved_Operable_mu_fu_ri(mu, fu, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Reserved_Operable_mu_fu_ri(mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Corr(sp, pr) / "/;
                            for ( (sp, pr) $ Corr(sp, pr)) do  ;
                                PUT    sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                Corr(sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter NaturRehab(mu, nfr, fu, ac, ri) / "/;
                            for ( (mu, nfr, fu, ac, ri) $ NaturRehab(mu, nfr, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                NaturRehab(mu, nfr, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_TGS_Prop(ags, ugs, agsph, ugsph) / "/;
                            for ( (ags, ugs, agsph, ugsph) $ Sel_Harv_TGS_Prop(ags, ugs, agsph, ugsph)) do  ;
                                PUT    ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," . ",
                                agsph.TL:A7PRWLAB,," . ",
                                ugsph.TL:A7PRWLAB,," = ",
                                Sel_Harv_TGS_Prop(ags, ugs, agsph, ugsph):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Deferred_Evenage_Area_Re_entering(term, mu, fu, ac, ri) / "/;
                            for ( (term, mu, fu, ac, ri) $ Deferred_Evenage_Area_Re_entering(term, mu, fu, ac, ri)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Deferred_Evenage_Area_Re_entering(term, mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "set ugs(ugs_global) / "/;
                            for ( ugs_global$ ugs(ugs_global)) do  ;
                                PUT    ugs_global.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_Avg_TGS(sched, mu, allage) / "/;
                            for ( (sched, mu, allage) $ Sel_Harv_Avg_TGS(sched, mu, allage)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Harv_Avg_TGS(sched, mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter UGS_Class_Midpoint(ugs) / "/;
                            for ( ugs$ UGS_Class_Midpoint(ugs)) do  ;
                                PUT    ugs.TL:A7PRWLAB,," = ",
                                UGS_Class_Midpoint(ugs):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "set non_shw(fu) / "/;
                            for ( fu$ non_shw(fu)) do  ;
                                PUT    fu.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Hab_Pref_Prop_Evenage(mu, fu, ac, ri, wl) / "/;
                            for ( (mu, fu, ac, ri, wl) $ Hab_Pref_Prop_Evenage(mu, fu, ac, ri, wl)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                wl.TL:A7PRWLAB,," = ",
                                Hab_Pref_Prop_Evenage(mu, fu, ac, ri, wl):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Ok = ", Ok:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "set wl_maxmin(wl) / "/;
                            for ( wl$ WildlifeSpecies_maxmin(wl)) do  ;
                                PUT    wl.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Area_Succeeding_mu_fu_global(mu, fu_global) / "/;
                            for ( (mu, fu_global) $ Initial_Area_Succeeding_mu_fu_global(mu, fu_global)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                Initial_Area_Succeeding_mu_fu_global(mu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Solve_Start = ", Solve_Start:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter ProdYield(mu, fu, ac, ri, sp, pr) / "/;
                            for ( (mu, fu, ac, ri, sp, pr) $ ProdYield(mu, fu, ac, ri, sp, pr)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                ProdYield(mu, fu, ac, ri, sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter TendVolPHa(mu, fu, ac, ri, tt, sp) / "/;
                            for ( (mu, fu, ac, ri, tt, sp) $ TendVolPHa(mu, fu, ac, ri, tt, sp)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                tt.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," = ",
                                TendVolPHa(mu, fu, ac, ri, tt, sp):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter HarvReserv(term, mu, fu, rsv) / "/;
                            for ( (term, mu, fu, rsv) $ HarvReserv(term, mu, fu, rsv)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                rsv.TL:A7PRWLAB,," = ",
                                HarvReserv(term, mu, fu, rsv):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter AGS_Class_Midpoint(ags) / "/;
                            for ( ags$ AGS_Class_Midpoint(ags)) do  ;
                                PUT    ags.TL:A7PRWLAB,," = ",
                                AGS_Class_Midpoint(ags):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Hab_Pref_PreSolve(term, mu, wl) / "/;
                            for ( (term, gsu, wl) $ Hab_Pref_PreSolve_gsu(term, gsu, wl)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                gsu.TL:A7PRWLAB,," . ",
                                wl.TL:A7PRWLAB,," = ",
                                Hab_Pref_PreSolve_gsu(term, gsu, wl):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Area_Available_UnDeferred_mu_fu_ac_ri(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ Initial_Evenage_Area_Available_UnDeferred_mu_fu_ac_ri(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Area_Available_UnDeferred_mu_fu_ac_ri(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Area_Factor_Allage(mu, allage) / "/;
                            for ( (mu, allage) $ ( Area_Factor_Allage(mu, allage) <> 1 )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Area_Factor_Allage(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Hab_Pref_Prop_NonFor(mu, nfr, wl) / "/;
                            for ( (mu, nfr, wl) $ Hab_Pref_Prop_NonFor(mu, nfr, wl)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," . ",
                                wl.TL:A7PRWLAB,," = ",
                                Hab_Pref_Prop_NonFor(mu, nfr, wl):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Hab_Pref_Prop_Allage(mu, allage, canopy, wl) / "/;
                            for ( (mu, allage, canopy, wl) $ Hab_Pref_Prop_Allage(mu, allage, canopy, wl)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                canopy.TL:A7PRWLAB,," . ",
                                wl.TL:A7PRWLAB,," = ",
                                Hab_Pref_Prop_Allage(mu, allage, canopy, wl):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter MaxHarv_FC(term, mu, fu, ac, ri) / "/;
                            for ( (term, gsu, fu, ac, ri) $ MaxHarv_gsu_FC(term, gsu, fu, ac, ri)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                gsu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                MaxHarv_gsu_FC(term, gsu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter ProdProp_1(mu, fu, ac, ri, sp, pr) / "/;
                            for ( (mu, fu, ac, ri, sp, pr) $ ProdProp_1(mu, fu, ac, ri, sp, pr)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                ProdProp_1(mu, fu, ac, ri, sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_Area_mu_allage(sched, mu, allage) / "/;
                            for ( (sched, mu, allage) $ Sel_Harv_Area_mu_allage(sched, mu, allage)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Harv_Area_mu_allage(sched, mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Gross_Operable_mu_fu_ac_ri(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ Initial_Evenage_Gross_Operable_mu_fu_ac_ri(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Gross_Operable_mu_fu_ac_ri(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "set dup_to(mu) / "/;
                            for ( mu$ dup_to(mu)) do  ;
                                PUT    mu.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Corr_1(sp, pr) / "/;
                            for ( (sp, pr) $ Corr_1(sp, pr)) do  ;
                                PUT    sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                Corr_1(sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Objective_Function(objective) / "/;
                            for ( objectives_i$ Objective_Select(objectives_i)) do  ;
                                PUT    Objectives_i.TL:A7PRWLAB,," = ",
                                Objective_Select(objectives_i):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter FU_Stability_Line(mu, fu, di) / "/;
                            for ( (mu, fu, di) $ FU_Stability_Line(mu, fu, di)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                di.TL:A7PRWLAB,," = ",
                                FU_Stability_Line(mu, fu, di):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter BA_Class_TGS(ags, ugs) / "/;
                            for ( (ags, ugs) $ BA_Class_TGS(ags, ugs)) do  ;
                                PUT    ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," = ",
                                BA_Class_TGS(ags, ugs):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Reserved_Operable_mu_fu_ac_ri(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ Initial_Evenage_Reserved_Operable_mu_fu_ac_ri(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Reserved_Operable_mu_fu_ac_ri(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Allage_Area_Reserved(mu, allage, ags, ugs, rsv) / "/;
                            for ( (mu, allage, ags, ugs, rsv) $ Initial_Allage_Area_Reserved(mu, allage, ags, ugs, rsv)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," . ",
                                rsv.TL:A7PRWLAB,," = ",
                                Initial_Allage_Area_Reserved(mu, allage, ags, ugs, rsv):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Shw_Successn(mu, fu, ff, ac, ri) / "/;
                            for ( (mu, fu, ff, ac, ri) $ Shw_Successn(mu, fu, ff, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ff.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Shw_Successn(mu, fu, ff, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter BA_Max_Prop_Harv(mu, allage) / "/;
                            for ( (mu, allage) $ ( BA_Max_Prop_Harv(mu, allage) <> 0.4 )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                BA_Max_Prop_Harv(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Area_Available_Wrk(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ Initial_Evenage_Area_Available_Wrk(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Area_Available_Wrk(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter MaxHarv_FU(term, mu, fu) / "/;
                            for ( (term, mu, fu) $ MaxHarv_FU(term, mu, fu)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                MaxHarv_FU(term, mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Fu_Hab_Prop(mu, fu, hab) / "/;
                            for ( (mu, fu, hab) $ Fu_Hab_Prop(mu, fu, hab)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                hab.TL:A7PRWLAB,," = ",
                                Fu_Hab_Prop(mu, fu, hab):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter HDS_Age_Range(hab, hds, ow) / "/;
                            for ( (hab, hds, ow) $ HDS_Age_Range(hab, hds, ow)) do  ;
                                PUT    hab.TL:A7PRWLAB,," . ",
                                hds.TL:A7PRWLAB,," . ",
                                ow.TL:A7PRWLAB,," = ",
                                HDS_Age_Range(hab, hds, ow):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Area_Disturbed_mu_fu_ac_ri(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ Initial_Evenage_Area_Disturbed_mu_fu_ac_ri(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Area_Disturbed_mu_fu_ac_ri(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Yield_1(mu, fu, ac, ri, sp) / "/;
                            for ( (mu, fu, ac, ri, sp) $ Yield_1(mu, fu, ac, ri, sp)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," = ",
                                Yield_1(mu, fu, ac, ri, sp):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Area_Deferred_mu(mu) / "/;
                            for ( mu$ Initial_Area_Deferred_mu(mu)) do  ;
                                PUT    mu.TL:A7PRWLAB,," = ",
                                Initial_Area_Deferred_mu(mu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "variable NonFstArea.lo(term, mu, nfr) / "/;
                            for ( (term, mu, nfr) $ NonFstArea.lo(term, mu, nfr)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," = ",
                                NonFstArea.lo(term, mu, nfr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "variable NonFstArea.up(term, mu, nfr) / "/;
                            for ( (term, mu, nfr) $ ( NonFstArea.up(term, mu, nfr) <> inf )) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," = ",
                                NonFstArea.up(term, mu, nfr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "variable NonFstArea(term, mu, nfr) / "/;
                            for ( (term, mu, nfr) $ NonFstArea.l(term, mu, nfr)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," = ",
                                NonFstArea.l(term, mu, nfr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Disturbanc_Wrk(mu, fu) / "/;
                            for ( (mu, fu) $ Disturbanc_Wrk(mu, fu)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                Disturbanc_Wrk(mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter BA_Min_Prop_Harv(mu, allage) / "/;
                            for ( (mu, allage) $ ( BA_Min_Prop_Harv(mu, allage) <> 0.25 )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                BA_Min_Prop_Harv(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter BA_Min_Post_Harv(mu, allage) / "/;
                            for ( (mu, allage) $ ( BA_Min_Post_Harv(mu, allage) <> 20 )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                BA_Min_Post_Harv(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "set ags(ags_global) / "/;
                            for ( ags_global$ ags(ags_global)) do  ;
                                PUT    ags_global.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Unharvested_Vol(mu, fu, ri, sp) / "/;
                            for ( (mu, fu, ri, sp) $ Unharvested_Vol(mu, fu, ri, sp)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," = ",
                                Unharvested_Vol(mu, fu, ri, sp):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter TendVolume(mu, fu, ac, ri, tt, sp) / "/;
                            for ( (mu, fu, ac, ri, tt, sp) $ TendVolume(mu, fu, ac, ri, tt, sp)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                tt.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," = ",
                                TendVolume(mu, fu, ac, ri, tt, sp):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Disable_Subunit_Sel(term, mu) / "/;
                            for ( (term, mu) $ Disable_Subunit_Sel(term, mu)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," = ",
                                Disable_Subunit_Sel(term, mu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter ProdProp_Allage_UGS(mu, sp, pr) / "/;
                            for ( (mu, sp, pr) $ ProdProp_Allage_UGS(mu, sp, pr)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                ProdProp_Allage_UGS(mu, sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Area_Available_UnDeferred_mu_fu(mu, fu) / "/;
                            for ( (mu, fu) $ Initial_Evenage_Area_Available_UnDeferred_mu_fu(mu, fu)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Area_Available_UnDeferred_mu_fu(mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter ChangePrUs_mu(term, mu, wl) / "/;
                            for ( (term, mu, wl) $ ChangePrUs_mu(term, mu, wl)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                wl.TL:A7PRWLAB,," = ",
                                ChangePrUs_mu(term, mu, wl):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter MinHarv_FC(term, mu, fu, ac, ri) / "/;
                            for ( (term, mu, fu, ac, ri) $ MinHarv_FC(term, mu, fu, ac, ri)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                MinHarv_FC(term, mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Solve_Date = ", Solve_Date:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter FUSuccessn_SI(mu, fu, ri, ff, rf) / "/;
                            for ( (mu, fu, ri, ff, rf) $ FUSuccessn_SI(mu, fu, ri, ff, rf)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                ff.TL:A7PRWLAB,," . ",
                                rf.TL:A7PRWLAB,," = ",
                                FUSuccessn_SI(mu, fu, ri, ff, rf):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Harv_VolpHa_mu_shw_ac_ri(mu, shw, ac, ri) / "/;
                            for ( (mu, shw, ac, ri) $ Harv_VolpHa_mu_shw_ac_ri(mu, shw, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                shw.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Harv_VolpHa_mu_shw_ac_ri(mu, shw, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Harvest_to_NonFor_Prop(term, mu, fu_global, nfr) / "/;
                            for ( (term, mu, fu_global, nfr) $ Harvest_to_NonFor_Prop(term, mu, fu_global, nfr)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," = ",
                                Harvest_to_NonFor_Prop(term, mu, fu_global, nfr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter MinHarv_FU(term, mu, fu) / "/;
                            for ( (term, mu, fu) $ MinHarv_FU(term, mu, fu)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                MinHarv_FU(term, mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter FMP_Year = ", FMP_Year:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter RehabArea_Dom(term, mu, nfr, rh) / "/;
                            for ( (term, mu, nfr, rh) $ RehabArea_Dom(term, mu, nfr, rh)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," . ",
                                rh.TL:A7PRWLAB,," = ",
                                RehabArea_Dom(term, mu, nfr, rh):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "set allage_exist(allage) / "/;
                            for ( allage$ allage_exist(allage)) do  ;
                                PUT    allage.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter ReserveArea_mu_fu_global(term, mu, fu_global) / "/;
                            for ( (term, mu, fu_global) $ ReserveArea_mu_fu_global(term, mu, fu_global)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                ReserveArea_mu_fu_global(term, mu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Min_HarvArea_FU(term, mu, fu_global) / "/;
                            for ( (term, gsu, fu_global) $ Min_HarvArea_gsu_FU(term, gsu, fu_global)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                gsu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                Min_HarvArea_gsu_FU(term, gsu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_Area_mu_allage_ags_ugs(sched, mu, allage, ags, ugs) / "/;
                            for ( (sched, mu, allage, ags, ugs) $ Sel_Harv_Area_mu_allage_ags_ugs(sched, mu, allage, ags, ugs)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," = ",
                                Sel_Harv_Area_mu_allage_ags_ugs(sched, mu, allage, ags, ugs):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Area_Deferred_mu_fu_ri(mu, fu, ri) / "/;
                            for ( (mu, fu, ri) $ Initial_Evenage_Area_Deferred_mu_fu_ri(mu, fu, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Area_Deferred_mu_fu_ri(mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter SchedYears = ", SchedYears:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter ActiveRehab(mu, nfr, rh, fu, ac, ri) / "/;
                            for ( (mu, nfr, rh, fu, ac, ri) $ ActiveRehab(mu, nfr, rh, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," . ",
                                rh.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                ActiveRehab(mu, nfr, rh, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Harvest_Reserve_Prop(term, mu, fu_global, rsv) / "/;
                            for ( (term, mu, fu_global, rsv) $ Harvest_Reserve_Prop(term, mu, fu_global, rsv)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," . ",
                                rsv.TL:A7PRWLAB,," = ",
                                Harvest_Reserve_Prop(term, mu, fu_global, rsv):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Disturb_Cycle(mu, fu) / "/;
                            for ( (mu, fu) $ ( Disturb_Cycle(mu, fu) <> inf )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                Disturb_Cycle(mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Minimum_Operable_TGS(mu, allage) / "/;
                            for ( (mu, allage) $ Sel_Minimum_Operable_TGS(mu, allage)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Minimum_Operable_TGS(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "set tgs(tgs_global) / "/;
                            for ( tgs_global$ tgs(tgs_global)) do  ;
                                PUT    tgs_global.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter AgeBegnHDS(hab, hds) / "/;
                            for ( (hab, hds) $ ( AgeBegnHDS(hab, hds) <> inf )) do  ;
                                PUT    hab.TL:A7PRWLAB,," . ",
                                hds.TL:A7PRWLAB,," = ",
                                AgeBegnHDS(hab, hds):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Area_Disturbed_mu_fu_global(mu, fu_global) / "/;
                            for ( (mu, fu_global) $ Initial_Area_Disturbed_mu_fu_global(mu, fu_global)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                Initial_Area_Disturbed_mu_fu_global(mu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Gross_Operable_mu_fu_global(mu, fu_global) / "/;
                            for ( (mu, fu_global) $ Initial_Gross_Operable_mu_fu_global(mu, fu_global)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                Initial_Gross_Operable_mu_fu_global(mu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Area_Succeeding_mu_fu_ac_ri(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ Initial_Evenage_Area_Succeeding_mu_fu_ac_ri(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Area_Succeeding_mu_fu_ac_ri(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Allage_Volume_Ratio(mu, allage, sp) / "/;
                            for ( (mu, allage, sp) $ Allage_Volume_Ratio(mu, allage, sp)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," = ",
                                Allage_Volume_Ratio(mu, allage, sp):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Planned_Ops_Sel = ", Planned_Ops_Sel:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter BA_Post_Growth(mu, allage, ags, ugs, agspg, ugspg) / "/;
                            for ( (mu, allage, ags, ugs, agspg, ugspg) $ BA_Post_Growth(mu, allage, ags, ugs, agspg, ugspg)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," . ",
                                agspg.TL:A7PRWLAB,," . ",
                                ugspg.TL:A7PRWLAB,," = ",
                                BA_Post_Growth(mu, allage, ags, ugs, agspg, ugspg):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Plan_Horizon = ", Plan_Horizon:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter PotHabPrUs(term, wl) / "/;
                            for ( (term, wl) $ PotHabPrUs(term, wl)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                wl.TL:A7PRWLAB,," = ",
                                PotHabPrUs(term, wl):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Area_Succeeding_mu_fu_ri(mu, fu, ri) / "/;
                            for ( (mu, fu, ri) $ Initial_Evenage_Area_Succeeding_mu_fu_ri(mu, fu, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Area_Succeeding_mu_fu_ri(mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "set wl_show(wl) / "/;
                            for ( wl$ wl_show(wl)) do  ;
                                PUT    wl.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_AHA_Net(sched, mu, allage) / "/;
                            for ( (sched, mu, allage) $ Sel_AHA_Net(sched, mu, allage)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_AHA_Net(sched, mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_Avg_AGS_Prop(sched, mu, allage) / "/;
                            for ( (sched, mu, allage) $ Sel_Harv_Avg_AGS_Prop(sched, mu, allage)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Harv_Avg_AGS_Prop(sched, mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Init_Unadjust_Area_Avail_mu_allage(mu, allage) / "/;
                            for ( (mu, allage) $ Init_Unadjust_Area_Avail_mu_allage(mu, allage)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Init_Unadjust_Area_Avail_mu_allage(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter FUSuccessn(mu, fu, ri, ff) / "/;
                            for ( (mu, fu, ri, ff) $ FUSuccessn(mu, fu, ri, ff)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                ff.TL:A7PRWLAB,," = ",
                                FUSuccessn(mu, fu, ri, ff):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter RegenCost(mu, fu, ri) / "/;
                            for ( (mu, fu, ri) $ RegenCost(mu, fu, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                RegenCost(mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Allage_Growstock(mu, allage, ags, ugs, sp, pr) / "/;
                            for ( (mu, allage, ags, ugs, sp, pr) $ Allage_Growstock(mu, allage, ags, ugs, sp, pr)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                Allage_Growstock(mu, allage, ags, ugs, sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_HarvArea_Converted_to_NonFor(mu, allage) / "/;
                            for ( (mu, allage) $ Sel_HarvArea_Converted_to_NonFor(mu, allage)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_HarvArea_Converted_to_NonFor(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "set exist(rsv) / "/;
                            for ( rsv$ exist(rsv)) do  ;
                                PUT    rsv.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "set accum(rsv) / "/;
                            for ( rsv$ accum(rsv)) do  ;
                                PUT    rsv.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Tend_Seq(term, mu, fu, ac, ri, tt) / "/;
                            for ( (term, mu, fu, ac, ri, tt) $ Tend_Seq(term, mu, fu, ac, ri, tt)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                tt.TL:A7PRWLAB,," = ",
                                Tend_Seq(term, mu, fu, ac, ri, tt):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter SeedlngPHa(mu, fu, ri) / "/;
                            for ( (mu, fu, ri) $ SeedlngPHa(mu, fu, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                SeedlngPHa(mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "set ri_copy(ri) / "/;
                            for ( ri$ SilviculturalIntensitiesCopy1(ri)) do  ;
                                PUT    ri.TL:A7PRWLAB /;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter ShelterWood_Fut(mu, fu, fn, ac, ri) / "/;
                            for ( (mu, fu, fn, ac, ri) $ ShelterWood_Fut(mu, fu, fn, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                fn.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                ShelterWood_Fut(mu, fu, fn, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter ChangePrUs(term, wl) / "/;
                            for ( (term, wl) $ ChangePrUs(term, wl)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                wl.TL:A7PRWLAB,," = ",
                                ChangePrUs(term, wl):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter NonForP(term, mu, fu, ri, nfr) / "/;
                            for ( (term, mu, fu, ri, nfr) $ NonForP(term, mu, fu, ri, nfr)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," = ",
                                NonForP(term, mu, fu, ri, nfr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Harv2NonFr(term, mu, fu, nfr) / "/;
                            for ( (term, mu, fu, nfr) $ Harv2NonFr(term, mu, fu, nfr)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," = ",
                                Harv2NonFr(term, mu, fu, nfr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Area_Disturbed_mu_fu_ri(mu, fu, ri) / "/;
                            for ( (mu, fu, ri) $ Initial_Evenage_Area_Disturbed_mu_fu_ri(mu, fu, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Area_Disturbed_mu_fu_ri(mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_Option_Volume_pHa_Total(mu, allage, ags, ugs, agsph, ugsph) / "/;
                            for ( (mu, allage, ags, ugs, agsph, ugsph) $ Sel_Harv_Option_Volume_pHa_Total(mu, allage, ags, ugs, agsph, ugsph)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," . ",
                                agsph.TL:A7PRWLAB,," . ",
                                ugsph.TL:A7PRWLAB,," = ",
                                Sel_Harv_Option_Volume_pHa_Total(mu, allage, ags, ugs, agsph, ugsph):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Nfr_Hab_Prop(mu, nfr, hab) / "/;
                            for ( (mu, nfr, hab) $ Nfr_Hab_Prop(mu, nfr, hab)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                nfr.TL:A7PRWLAB,," . ",
                                hab.TL:A7PRWLAB,," = ",
                                Nfr_Hab_Prop(mu, nfr, hab):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter HabQuality(hab, hds, wl) / "/;
                            for ( (hab, hds, wl) $ HabQuality(hab, hds, wl)) do  ;
                                PUT    hab.TL:A7PRWLAB,," . ",
                                hds.TL:A7PRWLAB,," . ",
                                wl.TL:A7PRWLAB,," = ",
                                HabQuality(hab, hds, wl):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Operable_Area(term, mu, allage) / "/;
                            for ( (term, mu, allage) $ Sel_Operable_Area(term, mu, allage)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Operable_Area(term, mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter SFMM_numnz = ", SFMM_numnz:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter ProdProp_Evenage(mu, fu, ri, sp, pr) / "/;
                            for ( (mu, fu, ri, sp, pr) $ ProdProp_Evenage(mu, fu, ri, sp, pr)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                ProdProp_Evenage(mu, fu, ri, sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter HarvArea_Dom(term, mu, fu, ac, ri) / "/;
                            for ( (term, mu, fu, ac, ri) $ HarvArea_Dom(term, mu, fu, ac, ri)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                HarvArea_Dom(term, mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Allage_Area_Reserved_mu_allage_ags_ugs_rsv(term, mu, allage, ags, ugs, rsv) / "/;
                            for ( (term, mu, allage, ags, ugs, rsv) $ Allage_Area_Reserved_mu_allage_ags_ugs_rsv(term, mu, allage, ags, ugs, rsv)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," . ",
                                rsv.TL:A7PRWLAB,," = ",
                                Allage_Area_Reserved_mu_allage_ags_ugs_rsv(term, mu, allage, ags, ugs, rsv):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter SFMM_iterusd = ", SFMM_iterusd:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter Sel_Harv_Volume_mu_allage(sched, mu, allage) / "/;
                            for ( (sched, mu, allage) $ Sel_Harv_Volume_mu_allage(sched, mu, allage)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Harv_Volume_mu_allage(sched, mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Deferred_Out_Evenage_Area(term, mu, fu, ac, ri) / "/;
                            for ( (term, mu, fu, ac, ri) $ Deferred_Out_Evenage_Area(term, mu, fu, ac, ri)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Deferred_Out_Evenage_Area(term, mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Cut_Cycle_FU(term, mu, allage) / "/;
                            for ( (term, mu, allage) $ ( Sel_Cut_Cycle_FU(term, mu, allage) <> 20 )) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Sel_Cut_Cycle_FU(term, mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter LastPass(mu, fu) / "/;
                            for ( (mu, fu) $ LastPass(mu, fu)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                LastPass(mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Stumpage(mu, sp, pr) / "/;
                            for ( (mu, sp, pr) $ Stumpage(mu, sp, pr)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                Stumpage(mu, sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Start_Term(term) / "/;
                            for ( term$ Start_Term(term)) do  ;
                                PUT    term.TL:A7PRWLAB,," = ",
                                Start_Term(term):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter ReservP(term, mu, fu, ri, rsv) / "/;
                            for ( (term, mu, fu, ri, rsv) $ ReservP(term, mu, fu, ri, rsv)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                rsv.TL:A7PRWLAB,," = ",
                                ReservP(term, mu, fu, ri, rsv):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter AvailableArea_mu_fu_global(term, mu, fu_global) / "/;
                            for ( (term, mu, fu_global) $ AvailableArea_mu_fu_global(term, mu, fu_global)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                AvailableArea_mu_fu_global(term, mu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter AC_HDS_Prop(ac, hab, hds) / "/;
                            for ( (ac, hab, hds) $ AC_HDS_Prop(ac, hab, hds)) do  ;
                                PUT    ac.TL:A7PRWLAB,," . ",
                                hab.TL:A7PRWLAB,," . ",
                                hds.TL:A7PRWLAB,," = ",
                                AC_HDS_Prop(ac, hab, hds):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Reserved_Operable_mu_fu_global(mu, fu_global) / "/;
                            for ( (mu, fu_global) $ Initial_Reserved_Operable_mu_fu_global(mu, fu_global)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                Initial_Reserved_Operable_mu_fu_global(mu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Harvest_AreaAnn_mu_fu_global(sched, mu, fu_global) / "/;
                            for ( (sched, mu, fu_global) $ Harvest_AreaAnn_mu_fu_global(sched, mu, fu_global)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                Harvest_AreaAnn_mu_fu_global(sched, mu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter NaturSuccn_GUI(mu, fu, ac, ri, ff) / "/;
                            for ( (mu, fu, ac, ri, ff) $ NaturSuccn_GUI(mu, fu, ac, ri, ff)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                ff.TL:A7PRWLAB,," = ",
                                NaturSuccn_GUI(mu, fu, ac, ri, ff):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sp_Pr_Dom(sp, pr) / "/;
                            for ( (sp, pr) $ Sp_Pr_Dom(sp, pr)) do  ;
                                PUT    sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                Sp_Pr_Dom(sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Sel_Harv_AGS_Improvement_Prop(ags, ugs, agsph, ugsph) / "/;
                            for ( (ags, ugs, agsph, ugsph) $ Sel_Harv_AGS_Improvement_Prop(ags, ugs, agsph, ugsph)) do  ;
                                PUT    ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," . ",
                                agsph.TL:A7PRWLAB,," . ",
                                ugsph.TL:A7PRWLAB,," = ",
                                Sel_Harv_AGS_Improvement_Prop(ags, ugs, agsph, ugsph):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter BA_Class_AGS_Prop(ags, ugs) / "/;
                            for ( (ags, ugs) $ BA_Class_AGS_Prop(ags, ugs)) do  ;
                                PUT    ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," = ",
                                BA_Class_AGS_Prop(ags, ugs):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter SFMM_numvar = ", SFMM_numvar:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter Initial_Evenage_Area_Deferred_mu_fu_ac_ri(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ Initial_Evenage_Area_Deferred_mu_fu_ac_ri(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Area_Deferred_mu_fu_ac_ri(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Net_Operable_mu_fu_ac_ri(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ Initial_Evenage_Net_Operable_mu_fu_ac_ri(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Net_Operable_mu_fu_ac_ri(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Init_Disturb_Area(mu, fu) / "/;
                            for ( (mu, fu) $ Init_Disturb_Area(mu, fu)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                Init_Disturb_Area(mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter TendArea_Dom(term, mu, fu, ac, ri, tt) / "/;
                            for ( (term, mu, fu, ac, ri, tt) $ TendArea_Dom(term, mu, fu, ac, ri, tt)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                tt.TL:A7PRWLAB,," = ",
                                TendArea_Dom(term, mu, fu, ac, ri, tt):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Harv_VolAnn_mu_allage_tgs_sp(sched, mu, allage, tgs, sp) / "/;
                            for ( (sched, mu, allage, tgs, sp) $ Harv_VolAnn_mu_allage_tgs_sp(sched, mu, allage, tgs, sp)) do  ;
                                PUT    sched.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                tgs.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," = ",
                                Harv_VolAnn_mu_allage_tgs_sp(sched, mu, allage, tgs, sp):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Net_Operable_mu_allage(mu, allage) / "/;
                            for ( (mu, allage) $ Initial_Net_Operable_mu_allage(mu, allage)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Initial_Net_Operable_mu_allage(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Harv_VolpHa_mu_shw_ac_ri_sp_pr(mu, shw, ac, ri, sp, pr) / "/;
                            for ( (mu, shw, ac, ri, sp, pr) $ Harv_VolpHa_mu_shw_ac_ri_sp_pr(mu, shw, ac, ri, sp, pr)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                shw.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                Harv_VolpHa_mu_shw_ac_ri_sp_pr(mu, shw, ac, ri, sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Yield_1_Tot(mu, fu, ac, ri) / "/;
                            for ( (mu, fu, ac, ri) $ Yield_1_Tot(mu, fu, ac, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Yield_1_Tot(mu, fu, ac, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Disturbanc(mu, fu) / "/;
                            for ( (mu, fu) $ Disturbanc(mu, fu)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," = ",
                                Disturbanc(mu, fu):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter ShelterWood_Vol(mu, fu, sp, ri) / "/;
                            for ( (mu, fu, sp, ri) $ ShelterWood_Vol(mu, fu, sp, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                ShelterWood_Vol(mu, fu, sp, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter NaturSuccn(mu, fu, ac, ri, fn, an, rn) / "/;
                            for ( (mu, fu, ac, ri, fn, an, rn) $ NaturSuccn(mu, fu, ac, ri, fn, an, rn)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                fn.TL:A7PRWLAB,," . ",
                                an.TL:A7PRWLAB,," . ",
                                rn.TL:A7PRWLAB,," = ",
                                NaturSuccn(mu, fu, ac, ri, fn, an, rn):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Evenage_Gross_Operable_mu_fu_ri(mu, fu, ri) / "/;
                            for ( (mu, fu, ri) $ Initial_Evenage_Gross_Operable_mu_fu_ri(mu, fu, ri)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," = ",
                                Initial_Evenage_Gross_Operable_mu_fu_ri(mu, fu, ri):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Objective_Select(objectives) / "/;
                            for ( objectives_i$ Objective_Select(objectives_i)) do  ;
                                PUT    objectives_i.TL:A7PRWLAB,," = ",
                                Objective_Select(objectives_i):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT " phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Planned_Harvest_Allage_Inoperable(mu, allage) / "/;
                            for ( (mu, allage) $ Planned_Harvest_Allage_Inoperable(mu, allage)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Planned_Harvest_Allage_Inoperable(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Reserved_Operable_mu_allage(mu, allage) / "/;
                            for ( (mu, allage) $ Initial_Reserved_Operable_mu_allage(mu, allage)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," = ",
                                Initial_Reserved_Operable_mu_allage(mu, allage):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom .  phantom = 0 / ; " / ;
                        
                        
                            ! set fu_global(*)
                        
                            PUT // "parameter ProdProp_Allage_AGS(mu, sp, pr) / "/;
                            for ( (mu, sp, pr) $ ProdProp_Allage_AGS(mu, sp, pr)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                sp.TL:A7PRWLAB,," . ",
                                pr.TL:A7PRWLAB,," = ",
                                ProdProp_Allage_AGS(mu, sp, pr):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter SFMM_modelstat = ", SFMM_modelstat:A7PRWWID:A7PRWDEC /;
                        
                        
                            PUT // "parameter Age_Range(mu, fu, ow) / "/;
                            for ( (mu, fu, ow) $ ( Age_Range(mu, fu, ow) <> 101 )) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                fu.TL:A7PRWLAB,," . ",
                                ow.TL:A7PRWLAB,," = ",
                                Age_Range(mu, fu, ow):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Shw_Delay_Dom(term, mu, shw, ac, ri, trm, an) / "/;
                            for ( (term, mu, shw, ac, ri, trm, an) $ Shw_Delay_Dom(term, mu, shw, ac, ri, trm, an)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                shw.TL:A7PRWLAB,," . ",
                                ac.TL:A7PRWLAB,," . ",
                                ri.TL:A7PRWLAB,," . ",
                                trm.TL:A7PRWLAB,," . ",
                                an.TL:A7PRWLAB,," = ",
                                Shw_Delay_Dom(term, mu, shw, ac, ri, trm, an):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Max_HarvArea_FU(term, mu, fu_global) / "/;
                            for ( (term, gsu, fu_global) $ Max_HarvArea_gsu_FU(term, gsu, fu_global)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                gsu.TL:A7PRWLAB,," . ",
                                fu_global.TL:A7PRWLAB,," = ",
                                Max_HarvArea_gsu_FU(term, gsu, fu_global):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Initial_Allage_Area_Available_Wrk(mu, allage, ags, ugs) / "/;
                            for ( (mu, allage, ags, ugs) $ Initial_Allage_Area_Available_Wrk(mu, allage, ags, ugs)) do  ;
                                PUT    mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," = ",
                                Initial_Allage_Area_Available_Wrk(mu, allage, ags, ugs):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                            PUT // "parameter Allage_Area_Available_mu_allage_ags_ugs(term, mu, allage, ags, ugs) / "/;
                            for ( (term, mu, allage, ags, ugs) $ Allage_Area_Available_mu_allage_ags_ugs(term, mu, allage, ags, ugs)) do  ;
                                PUT    term.TL:A7PRWLAB,," . ",
                                mu.TL:A7PRWLAB,," . ",
                                allage.TL:A7PRWLAB,," . ",
                                ags.TL:A7PRWLAB,," . ",
                                ugs.TL:A7PRWLAB,," = ",
                                Allage_Area_Available_mu_allage_ags_ugs(term, mu, allage, ags, ugs):A7PRWWID:A7PRWDEC, " , "/;
                             endfor ;
                            PUT "phantom . phantom . phantom . phantom .  phantom = 0 / ; " / ;
                        
                        
                        
                            PUTCLOSE ;
                            ! End of file aputcomp.gms, continuing on line 95 of file Sfmm_Obj.Aim.
                            /**/
                        EndIf ;
                    }
                    Comment: "To verify that the parameters computed up till the solve statement are still the same.";
                    DeclarationSection Local_Declarations {
                        StringParameter presolve_dumpfilename;
                        File A7prw {
                            Name: presolve_dumpfilename;
                            Device: Disk;
                            Mode: replace;
                        }
                        Parameter a7prwlab {
                            InitialData: 10;
                        }
                        Parameter a7prwid {
                            InitialData: 20;
                        }
                        Parameter a7prwdec {
                            InitialData: 8;
                        }
                        Parameter a7rpwthrsh {
                            InitialData: 1.0e-6;
                        }
                    }
                }
                Procedure WriteMatrixOverviewFile {
                    Body: {
                        put MatrixOverviewFile ;
                        display CurrentMatrixRowCount     where colsperline = 1, coldim = 0 ;
                        display CurrentMatrixColumnCount  where colsperline = 1, coldim = 0 ;
                        display CurrentMatrixBlockSizes   where colsperline = 1, coldim = 0 ;
                        putclose ;
                    }
                    File MatrixOverviewFile {
                        Name: "Matrix.siz";
                        Mode: replace;
                        Comment: "Debugging purposes.";
                    }
                }
            }
            Section Action_Procedures {
                Procedure Test_Case_Save_QA {
                    Body: {
                        Case_Save_QA("Silly Case");
                    }
                }
                Procedure Case_Save_QA {
                    Arguments: (OutputFilename);
                    Body: {
                        
                        prev_CurrentDefaultCaseType := CurrentDefaultCaseType ;
                        CurrentDefaultCaseType := StringToElement( AllCaseTypes, "All Identifiers", create:0);
                        If ( CurrentDefaultCaseType ) Then
                          If ( Not CaseFind( outputFilename, CaseNumber ) ) Then
                            rcode := CaseCreate(outputfilename,CaseNumber);
                          EndIf ;
                          rcode := CaseSetCurrent(CaseNumber);
                          rcode := CaseSave(confirm:0);
                        EndIf ;
                        CurrentDefaultCaseType := prev_CurrentDefaultCaseType;
                    }
                    DeclarationSection ArgumentDeclaration {
                        StringParameter OutputFilename {
                            Property: Input;
                        }
                    }
                    DeclarationSection LocalDeclarations {
                        ElementParameter CaseNumber {
                            Range: AllCases;
                        }
                        ElementParameter prev_CurrentDefaultCaseType {
                            Range: AllCaseTypes;
                        }
                        Parameter rcode;
                    }
                }
                Procedure Case_Load_QA {
                    Arguments: (OutputFilename);
                    Body: {
                        If ( CaseFind( outputFilename, CaseNumber ) ) Then
                                CaseSetChangedStatus(status:0);         ! set changestatus of current case to no change
                                CaseLoadCurrent(CaseNumber,dialog:0);
                        Else
                                QAErrorMessage("Case_Load_QA: Unable to load case (" + outputfilename )
                        EndIf ;
                    }
                    DeclarationSection ArgumentDeclaration {
                        StringParameter OutputFilename {
                            Property: Input;
                        }
                    }
                    DeclarationSection LocalDeclarations {
                        ElementParameter CaseNumber {
                            Range: AllCases;
                        }
                        ElementParameter prev_CurrentDefaultCaseType {
                            Range: AllCaseTypes;
                        }
                        Parameter rcode;
                    }
                }
                Procedure Dataset_Load_QA {
                    Arguments: (DatasetName,CategoryName);
                    Body: {
                        DataCategory := StringToElement(AllDataCategories,CategoryName,0) ;
                        if DataCategory  = '' then
                        	QAErrorMessage("Dataset_Load_QA: Unable to load dataset '" + DatasetName  + "' in  category '" + CategoryName + "'");
                        endif;
                        
                        If ( DatasetFind(DataCategory, DatasetName, DatasetNumber ) ) Then
                               rcode := DatasetSetChangedStatus(DataCategory,status:0);         ! set changestatus of current dataset to no change
                               rcode := DatasetLoadCurrent(DataCategory,DatasetNumber,dialog:0);
                        Else
                                QAErrorMessage("Dataset_Load_QA: Unable to load dataset (" + DatasetName )
                        EndIf ;
                    }
                    DeclarationSection ArgumentDeclaration {
                        StringParameter DatasetName {
                            Property: Input;
                        }
                        StringParameter CategoryName {
                            Property: Input;
                        }
                    }
                    DeclarationSection LocalDeclarations {
                        ElementParameter DatasetNumber {
                            Range: AllDataSets;
                        }
                        ElementParameter DataCategory {
                            Range: AllDataCategories;
                        }
                        ElementParameter prev_CurrentDefaultCaseType {
                            Range: AllCaseTypes;
                        }
                        Parameter rcode;
                    }
                }
                Procedure Dataset_Save_QA {
                    Arguments: (DatasetName,CategoryName);
                    Body: {
                        DataCategory := StringToElement(AllDataCategories,CategoryName,0) ;
                        if DataCategory  = '' then
                        	QAErrorMessage("Dataset_Save_QA: Unable to save dataset '" + DatasetName  + "' in  category '" + CategoryName + "'");
                        	return 0;
                        endif;
                        
                        If ( DatasetFind(DataCategory, DatasetName, DatasetNumber ) ) Then
                               rcode := DatasetSetChangedStatus(DataCategory,status:0);         ! set changestatus of current dataset to no change
                        endif;
                        
                        
                        rcode := DatasetSave(DataCategory,confirm:0);
                        if rcode < 1 then
                                QAErrorMessage("Dataset_Load_QA: Unable to load dataset (" + DatasetName + CurrentErrorMessage)
                        EndIf ;
                    }
                    DeclarationSection ArgumentDeclaration {
                        StringParameter DatasetName {
                            Property: Input;
                        }
                        StringParameter CategoryName {
                            Property: Input;
                        }
                    }
                    DeclarationSection LocalDeclarations {
                        ElementParameter DatasetNumber {
                            Range: AllDataSets;
                        }
                        ElementParameter DataCategory {
                            Range: AllDataCategories;
                        }
                        ElementParameter prev_CurrentDefaultCaseType {
                            Range: AllCaseTypes;
                        }
                        Parameter rcode;
                    }
                }
                Procedure Dataset_Export_QA {
                    Arguments: (DatasetName,CategoryName,OutFileName);
                    Body: {
                        ! Export dataset to ascii file
                        DataCategory := StringToElement(AllDataCategories,CategoryName,0) ;
                        if DataCategory  = '' then
                        	QAErrorMessage("Dataset_Load_QA: Unable to load dataset '" + DatasetName  + "' in  category '" + CategoryName + "'");
                        	return 0;
                        endif;
                        
                        If ( DatasetFind(DataCategory, DatasetName, DatasetNumber ) ) Then
                               rcode := DatasetSetChangedStatus(DataCategory,status:0);         ! set changestatus of current dataset to no change
                               rcode := DatasetLoadCurrent(DataCategory,DatasetNumber,dialog:0);
                        
                               ! get identifiers in category
                        
                               if DataCategoryContents(DataCategory,DatasetContents) then
                               		if FileExists(outfilename) then FileDelete(OutFileName,1); endif;
                               		write DatasetContents to file outfilename in backup mode;
                               endif;
                        Else
                                QAErrorMessage("Dataset_Load_QA: Unable to load dataset (" + DatasetName )
                        EndIf ;
                    }
                    DeclarationSection ArgumentDeclaration {
                        StringParameter DatasetName {
                            Property: Input;
                        }
                        StringParameter CategoryName {
                            Property: Input;
                        }
                        StringParameter OutFileName {
                            Property: Input;
                        }
                    }
                    DeclarationSection LocalDeclarations {
                        ElementParameter DatasetNumber {
                            Range: AllDataSets;
                        }
                        ElementParameter DataCategory {
                            Range: AllDataCategories;
                        }
                        Set DatasetContents {
                            SubsetOf: AllIdentifiers;
                            Index: idc;
                        }
                        ElementParameter prev_CurrentDefaultCaseType {
                            Range: AllCaseTypes;
                        }
                        Parameter rcode;
                    }
                }
                Procedure Solve_QA {
                    Arguments: (presolve_dumpfilename,dodump);
                    Body: {
                        if StringToUpper(SubString( dodump,1,1)) = "Y" then
                        	MainExecution_work( presolve_dumpfilename, 1 ) ;
                        else
                        	MainExecution_work( presolve_dumpfilename, 0 ) ;
                        endif;
                    }
                    StringParameter presolve_dumpfilename {
                        Property: Input;
                    }
                    StringParameter dodump {
                        Property: Input;
                    }
                }
                Procedure Test_Case_Load_QA {
                    Body: {
                        Case_Load_QA("Test Sample1");
                    }
                }
                Procedure Test_Dataset_Load_QA {
                    Body: {
                        Dataset_Load_QA("Base MU","MU Definitions");
                    }
                }
                Procedure Test_Dataset_Save_QA {
                    Body: {
                        DebuggerBreakpoint;
                        Dataset_Save_QA("QA Base MU","MU Definitions");
                    }
                }
                Procedure Test_Dataset_Export_QA {
                    Body: {
                        !DebuggerBreakpoint;
                        Dataset_Export_QA("Base MU","MU Definitions","testing\\junk.txt");
                    }
                }
            }
            Section Runtime_Library_Section {
                ElementParameter MyRuntimeLib {
                    Range: AllIdentifiers;
                    Property: NoSave;
                }
                ElementParameter MyProcedure {
                    Range: AllIdentifiers;
                    Default: 'MainInitialization';
                    Property: NoSave;
                }
                ElementParameter PToDisplay {
                    Range: AllIdentifiers;
                    Property: NoSave;
                }
                StringParameter BodyString {
                    Property: NoSave;
                }
                File QADebug {
                    Device: window;
                }
                Procedure ViewData {
                    Body: {
                        if _pte then
                        	s := FormatString("[Data Page] %e",_pte);
                        
                        	if StringToElement(PageNames, s, 0) then
                        		PageOpen(s);
                        	else ! write to console
                        		MyDisplayData(_pte);
                        	endif;
                        endif;
                        !cprg
                    }
                    StringParameter s;
                }
                Procedure MyDisplayData {
                    Arguments: (_IdentifierToView);
                    Body: {
                        if not _IdentifierToView then return 0; endif;
                        
                        
                        if MyRuntimeLib = '' then
                        	!--check if library exists
                        	i :=1;
                        	repeat
                        		LibName := FormatString("Library_%i",i);
                        		MyRuntimeLib := StringToElement(AllIdentifiers,LibName,0);
                        		break when ( MyRuntimeLib = '' or loopcount > 10);
                        		i += 1;
                        	endrepeat;
                        
                        	!--- Create new library
                        		!LibName := "Library_1";
                                MyRuntimeLib := me::CreateLibrary(LibName, FormatString("L%i",i));
                                MyProcedure := me::Create("Procedure1",'procedure',MyRuntimeLib);
                        endif;
                        
                        BodyString := "put QADebug ;\n";
                        
                        ! what I want is to see the contents of the identifier referenced by ParameterToDiplay
                                PToDisplay := StringToElement(AllIdentifiers,FormatString("%e",_IdentifierToView));
                                BodyString += FormatString("display %e Where decimals = 2;\n", PToDisplay);
                        
                        BodyString += "putclose";
                        
                        me::SetAttribute(
                                runtimeId : MyProcedure,
                                attr      :  'Body',
                                txt       :  BodyString);
                        
                        if me::Compile(MyProcedure) <> 1 then
                                DialogError("Error compiling MyProcedure","Compile Error");
                                return 0;
                        endif;
                        
                        Apply(MyProcedure);
                        
                        !FileEdit(BindingConstraints_File);
                    }
                    ElementParameter _IdentifierToView {
                        Range: AllIdentifiers;
                        Property: Input;
                    }
                    StringParameter LibName;
                    Parameter i;
                }
            }
        }
    }
    Section Documentation {
        StringParameter WhatsNew {
            Definition: "<prj>:\\Whats New\\Beta 2b";
        }
        Procedure EditWhatsNewFile {
            Body: {
                fileEdit(WhatsNew);
            }
        }
    }
    Section Page_Management_Section {
        Comment: {
            "This section contains the page management declarations and procedures to let pages and subpages work
            
            InitializePageSet --- YOU MUST EDIT THIS to define the main pages
            	- finds child pages for all main pages
            
            OpenParentPage
            
            SetLastViewedChildPage"
        }
        Section Colors_General {
            DeclarationSection button_colours {
                ElementParameter ColourButtonActive {
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        'Button Active'
                        !'yellow'
                    }
                }
                ElementParameter ColourButtonInactive {
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        'Button InActive'
                        !'green'
                    }
                }
                ElementParameter ColourButtonError {
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        'Button Error'
                        !'red'
                    }
                }
                ElementParameter ButtonMills_Colour {
                    Range: AllColors;
                    Property: NoSave;
                    Definition: 'grey';
                }
                Set HeaderButtons {
                    Index: btn;
                    Parameter: CurrentButton;
                    Property: NoSave;
                    InitialData: {
                        data {
                        !General, Supply, Mills, Markets, Costs, 'Exec', 'QA Exec', Results, Other, Candy, Maps, Explore
                         'Regions' , 'Facilities Separator' , 'Markets' ,'Exec Separator' ,'Results','Maps'
                        }
                    }
                }
                ElementParameter HeaderButtonColours {
                    IndexDomain: btn;
                    Range: AllColors;
                    Property: NoSave;
                    Definition: {
                        ! ===== buttons that can be red for errors or warnings
                        !if (btn = 'Other' and HIDE_MillDemandWithoutSupply = 0) then ColourButtonError ! Cost Button
                        !elseif (btn = 'Costs' and HIDE_MillDemandWithoutSupply = 0) then ColourButtonError ! Cost Button
                        !ElseIf (btn = 'General Data' and MUsPerBlockPROBLEM)  then ColourButtonError
                        !ElseIf (btn = 'General' and MUsPerBlockPROBLEM)  then ColourButtonError
                        !ElseIf (btn = 'Results' and NumberOfInfeasibilities)  then ColourButtonError
                        !else
                        if btn = CurrentButton then ColourButtonActive
                        else        ColourButtonInactive
                        endif
                    }
                    Comment: {
                        "if btn = CurrentButton then ColourButtonActive
                        else
                                ! ===== buttons that can be red for errors or warnings
                                if (btn = \'Other\' and HIDE_MillDemandWithoutSupply = 0) then ColourButtonError ! Cost Button
                                ElseIf (btn = \'General Data\' and MUsPerBlockPROBLEM)  then ColourButtonError
                                ElseIf (btn = \'Results\' and NumberOfInfeasibilities)  then ColourButtonError
                                else
                                        ColourButtonInactive
                                endif
                         endif"
                    }
                }
            }
            ElementParameter BackgroundColour {
                Range: AllColors;
            }
            Procedure AssignCurrentButton {
                Body: {
                    if PageGetActive(PageName) = 0 then return 0 ; endif;
                    
                    block !remove library prefix
                    	retval := FindString(PageName, "::");
                    	if retval then
                    		PageName := SubString(PageName , retval+2, StringLength(PageName));
                    	endif;
                    endblock;
                    
                    
                    for btn do
                    	ButtonName := FormatString("%e",btn);
                    	if ButtonName = PageName then
                    		CurrentButton := btn ;
                    		return 1;
                    
                    	elseif FindString(PageName, ButtonName) and not FindString(ButtonName," ") then
                    		CurrentButton := btn;
                    		return 1;
                    	endif;
                    endfor;
                    
                    return 0;
                }
                Comment: {
                    "Assign value to CurrentButton based on Active Page Name;"
                }
                StringParameter PageName;
                StringParameter ButtonName;
                Parameter retval;
            }
        }
        Procedure InitializePageSet {
            Body: {
                ! Get names of all pages in project
                PageGetAll(PageSet,1,0,0,0);
                
                GUIPagesWithChildren := data { 'nsm::Regions' , 'nsm::Facilities Separator' , 'nsm::Markets'
                								,'nsm::Exec Separator' ,'nsm::Results','nsm::Maps'
                							! --- RO Library
                							!, 'fro::Test FlowRO'
                							! --- Map Only GUI
                							!, 'Map _Supply' , 'Map _Maps' , 'Map _Mills' , 'Map Explore'
                						};
                
                !DebuggerBreakpoint;
                for gpag do
                	ParentPage := FormatString("%e",gpag);
                	sLib := GetLibraryPrefix(ParentPage);
                
                	! get name of all child pages
                	if PageGetChild(ParentPage, PageName , 0) then
                		PageName := sLib + PageName;	!add library prefix
                		_gpag := StringToElement(GUIPagesWithChildren, ParentPage,0);
                
                		repeat
                			_pag := StringToElement(PageSet,PageName,0);
                			GUIParentChildPages += { ( _gpag,_pag) };
                			retval := PageGetNext(PageName,Pagename,0);
                			PageName := sLib + PageName;	!add library prefix
                			break when (retval=0);
                		endrepeat;
                	endif;
                endfor;
                
                ! -- check which pages use ReadOnlyParameters
                PagesWithReadOnlyParameters := {  };
                for IndexNonDataPages  do
                	PageGetUsedIdentifiers(IndexNonDataPages,TempIdentifierSet);
                	!if IndexNonDataPages = 'Supply Zones' then DebuggerBreakpoint; endif;
                
                	! iIdent is list of used identifiers in pag
                	for (iIdent | iIdent in ReadOnlyParameters) do
                		PagesWithReadOnlyParameters += { (IndexNonDataPages,iIdent) };
                	endfor;
                endfor;
                
                !ResetReadOnlyPages;
            }
            StringParameter ParentPage;
            StringParameter PageName;
            Parameter retval;
            Set TempIdentifierSet {
                SubsetOf: AllIdentifiers;
                Index: iIdent;
            }
            StringParameter sLib;
        }
        Procedure GetAllChidPages {
            Arguments: (ParentPageName,PageNameSet);
            Body: {
                if StringToElement(PageSet, ParentPageName,0) = '' then
                	return 0;
                endif;
                
                retval := FindString(ParentPageName,"::") ;
                if retval > 0 then
                	pre := SubString(ParentPageName,1,retval+1);
                endif;
                
                
                ! get name of all child pages
                retval := PageGetChild(ParentPageName, PageName , 0) ;
                if retval <> 0 then
                	_epag := StringToElement(PageSet,pre+PageName,0);
                	PageNameSet += _epag;
                
                	repeat
                		!PageName := FormatString("%e",_epag);
                		retval := PageGetNext(FormatString("%e",_epag),Pagename,0);
                		if FindString(PageName, pre) = 0 then
                			PageName := Pre + PageName;
                		endif;
                		break when (retval=0);
                		_epag := StringToElement(PageSet,PageName,0);
                		PageNameSet += _epag ; !{ ( _gpag,_pag) };
                	endrepeat;
                endif;
            }
            Set PageNameSet {
                SubsetOf: PageSet;
                Index: pns;
                Parameter: _pns;
                Property: Output;
            }
            StringParameter ParentPageName {
                Property: Input;
            }
            StringParameter PageName;
            ElementParameter _epag {
                Range: PageSet;
            }
            StringParameter ParentPage;
            StringParameter Pre;
            Parameter retval;
        }
        Procedure test {
            Body: {
                ParentPageName := "nsm::NS Main Page";
                GetAllChidPages(ParentPageName, PageNameSet);
                
                return 1;
            }
            Set PageNameSet {
                SubsetOf: PageSet;
                Index: pns;
                Parameter: _pns;
            }
            StringParameter ParentPageName;
            StringParameter PageName;
        }
        Procedure OpenParentPage {
            Body: {
                !*********************************************************************************
                ! When a parent page is opened (e.g. clicking main navitation button)
                ! ... switch to last opened child page (_LastViewedChildPage)
                !*********************************************************************************
                
                !-- If the main page is opened by clicking on a side navigation bar (FromHeader=0) then open the page
                !-- otherwise open the last opened child page
                block ! Check that Pagesets have been initialized
                	if card(GUIPagesWithChildren)=0 then
                		InitializePageSet;
                	endif;
                endblock;
                
                
                if PageGetActive(PageName)=0 then return 0; endif;
                
                block ! Page-specific initialization
                	PageGetUsedIdentifiers(PageName,PageIdentifiers);
                	if 'IsSelected' in PageIdentifiers then
                		IsSelected(__EvenFlow) :=
                		if not exists( (dest, gPrGrp, tpM) | EvenFlowDeliver(dest, gPrGrp, tpM)) then 0 endif ;
                		UpdateSelectorDescriptions;
                	endif;
                endblock;
                
                
                ! check if current page is a header page ... _gpag <> ''
                _gpag := StringToElement(GUIPagesWithChildren, GetPagenameWithLibraryPrefix(PageName),0);
                
                ResetReadOnlyPages;		! for pages with checkboxes, turn on read-only mode
                
                block ! Parent Page Handler
                	!-- check if current page is a child or parent page
                	if _gpag = '' then !PageName is a Child Page
                		AssignCurrentButton;
                		return 1;
                	elseif FromHeader=0 then !Parent Page opened by clicking side navigation button
                		empty _LastViewedChildPage(_gpag);
                		AssignCurrentButton;
                		return 1;
                	else ! Parent page opened by clicking main button
                		FromHeader:=0;
                	endif;
                endblock;
                
                AssignCurrentButton;
                
                block ! Child Page Handler
                !--- check if a child page was previously opened
                	if _LastViewedChildPage(_gpag) <> '' then
                		PageClose;
                		PageOpen(FormatString("%e",_LastViewedChildPage(_gpag) ) );
                		ResetReadOnlyPages;
                	endif;
                endblock;
                
                return 1;
            }
            StringParameter PageName;
            Set PageIdentifiers {
                SubsetOf: AllIdentifiers;
            }
            StringParameter sLib;
        }
        Procedure SetLastViewedChildPage {
            Body: {
                !*** Sets the appropriate element parameter _LastViewedChildPage when the child page is opened
                !*** executed when a page is opened from Side Navigation Button
                
                
                
                if PageGetActive(Pagename) = 0 then return 0; endif;
                
                ! check if current page is a child page
                _pag := StringToElement(GUIChildPages,GetPagenameWithLibraryPrefix(PageName),0);
                
                PageGetParent(PageName,ParentPage,0); !no library prefix required here
                _gpag := StringToElement(GUIPagesWithChildren, GetPagenameWithLibraryPrefix(ParentPage),0);
                
                !DebuggerBreakpoint;
                !-- check if current page is a parent page
                if GUIPagesWithChildren(_pag) then
                	empty _LastViewedChildPage(_gpag);
                	return 1;
                elseif _gpag='' or _pag='' then
                		return 1;
                endif;
                
                !--- check if a child page was previously opened
                _LastViewedChildPage(_gpag) := _pag;
                ResetReadOnlyPages;
                
                
                block ! page-specific actions
                	if FindString(pagename, "shapefil",CaseSensitive:0) then
                		SetCanDisplayShapefile;
                	elseif FindString(PageName, "MUs and Blocks") then
                		InitializeMUForBlock;
                	endif;
                endblock;
                
                return 1;
            }
            StringParameter ParentPage;
            StringParameter PageName;
            StringParameter sLib;
        }
        Procedure Empty_LastViewedPage {
            Body: {
                empty _LastViewedChildPage;
            }
        }
        Procedure ResetReadOnlyPages {
            Body: {
                if PageGetActive(PageName) = 0 then
                	for (pag,iROP) | iROP in ReadOnlyParameters and (pag,iROP)  in PagesWithReadOnlyParameters do
                		switch iROP do
                		'MillEdit_On':		empty MillEdit_On;
                		'MapEdit_On':		empty MapEdit_On;
                		endswitch;
                	endfor;
                else
                	_pag := StringToElement(PageSet,GetPagenameWithLibraryPrefix(PageName),0);
                	for iROP in ReadOnlyParameters | (_pag,iROP)  in PagesWithReadOnlyParameters do
                		switch iROP do
                		'MillEdit_On':		empty MillEdit_On;
                		'MapEdit_On':		empty MapEdit_On;
                		endswitch;
                 	endfor;
                 endif;
            }
            StringParameter PageName;
            Index iROP {
                Range: ReadOnlyParameters;
            }
        }
        Function GetLibraryPrefix {
            Arguments: (ParentPage);
            Range: string;
            Body: {
                		retval := FindString(ParentPage, "::");
                		if retval=0 then
                			sLib :="";
                		else
                			sLib := SubString(ParentPage,1,retval+1);
                		endif;
                
                		GetLibraryPrefix := sLib;
            }
            Parameter retval;
            StringParameter sLib;
            StringParameter ParentPage {
                Property: Input;
            }
        }
        Function GetPagenameWithLibraryPrefix {
            Arguments: (PageName);
            Range: string;
            Body: {
                _pag := StringToElement(PageSet, PageName, 0);
                if _pag='' then
                !	MyPageSet := { pag | FindString(FormatString("%e",pag) , PageName) > 0 } ;
                	_pag := First(pag in PageSet |
                			StringToUpper(
                			SubString(
                				FormatString("%e",pag),
                				FindString(FormatString("%e",pag),"::")+2 ,
                				StringLength(FormatString("%e",pag))
                			)
                							)
                			= StringToUpper(PageName)
                			);
                endif;
                GetPagenameWithLibraryPrefix := FormatString("%e", _pag);
            }
            Parameter retval;
            StringParameter sLib;
            StringParameter PageName {
                Property: Input;
            }
            ElementParameter _pag {
                Range: PageSet;
            }
            Set MyPageSet {
                SubsetOf: PageSet;
            }
        }
        Set PageSet {
            Index: pag;
            Parameter: _pag;
            Property: NoSave;
        }
        Set PageSetExcludeData {
            SubsetOf: PageSet;
            Text: "Pages excluding [Data...] Pages";
            Index: IndexNonDataPages;
            Property: NoSave;
            OrderBy: IndexNonDataPages;
            Definition: {
                { pag | FindString(FormatString("%e",pag),"[Data Page]")=0 }
            }
        }
        ElementParameter _ipagd {
            Range: PageSetExcludeData;
            Property: NoSave;
        }
        Set GUIPagesWithChildren {
            SubsetOf: PageSet;
            Index: gpag;
            Parameter: _gpag;
            Property: NoSave;
        }
        Set GUIParentChildPages {
            SubsetOf: (GUIPagesWithChildren,PageSet);
            Property: NoSave;
        }
        Set GUIChildPages {
            SubsetOf: PageSet;
            Index: gcp;
            Property: NoSave;
            Definition: {
                { pag | exists( gpag | (gpag,pag) in GUIParentChildPages) }
            }
        }
        ElementParameter _LastViewedChildPage {
            IndexDomain: gpag;
            Range: GUIChildPages;
            Property: NoSave;
        }
        StringParameter CurrentPageName {
            Property: NoSave;
        }
        Parameter FromHeader {
            Text: "1 if main navigation button clicked";
            Range: binary;
            Property: NoSave;
        }
        StringParameter PageKeywords {
            IndexDomain: (IndexNonDataPages);
            Property: NoSave;
        }
        Set ReadOnlyParameters {
            SubsetOf: AllIdentifiers;
            Property: NoSave;
            Definition: {
                { 'MillEdit_On' , 'MapEdit_On' }
            }
        }
        Set PagesWithReadOnlyParameters {
            SubsetOf: (PageSetExcludeData,ReadOnlyParameters);
            Property: NoSave;
        }
        Parameter MainPageOpened {
            Range: binary;
            Unit: 1;
            Default: 0;
            Property: NoSave;
        }
    }
    Section Users_and_Groups_Section {
        DeclarationSection User_and_Group_Security {
            Set AllowedActions {
                Index: aact;
                Parameter: __ASaveData,__ALoadData,__ASolve,__AChangeAuthorization,__ADevelop,__AMap,__AMillNames;
                Property: NoSave;
                Definition: {
                    data {
                    'Save Data'
                    ,'Load Data'
                    ,Solve
                    ,'Change Authorization'
                    ,Develop
                    ,Map
                    ,MillNames
                    }
                }
            }
            Parameter IsAuthorizedMatrix {
                IndexDomain: (IndexAuthorizationLevels,aact);
                Range: binary;
                Default: 1;
                Property: NoSave;
                Definition: {
                    !data {
                    !
                    !(Developer	,'Save Data')				:	1
                    !,(Developer	,'Load Data')				:	1
                    !,(Developer	,Solve)						:	1
                    !,(Developer	,Develop)					:	1
                    !,(Developer	,Map)						:	1
                    !,(Developer	,MillNames)					:	1
                    !,(Developer	,'Change Authorization')	:	1
                    !,('Run Model'	,Solve)					:	1
                    !,('Run Model'	,Map)					:	1
                    !,('Run Model'	,'Load Data')			:	1
                    !,('Run Model'	,MillNames)				:	1
                    !,('Modify Scenario'	,'Save Data')		:	1
                    !,('Modify Scenario'	,'Load Data')		:	1
                    !,('Modify Scenario'	,Solve)				:	1
                    !,('Modify Scenario'	,Map)				:	1
                    !,('Modify Scenario'	,MillNames)			:	1
                    !,('MapOnly'	,Map)						:	1
                    !,('MapOnly'	,'Load Data')				:	1
                    !,('MapOnly'	,'Save Data')				:	1
                    !
                    !}
                }
            }
            Parameter HIDE_IsAuthorized {
                IndexDomain: (IndexAuthorizationLevels,aact);
                Range: binary;
                Property: NoSave;
                Definition: if IsAuthorizedMatrix(IndexAuthorizationLevels,aact) then 0 else 1 endif;
            }
            Parameter IsAuthorized {
                IndexDomain: (aact);
                Range: binary;
                Property: NoSave;
                Definition: if IsAuthorizedMatrix(CurrentAuthorizationLevel,aact) then 1 else 0 endif;
            }
            Parameter IsNotAuthorized {
                IndexDomain: (aact);
                Range: binary;
                Property: NoSave;
                Definition: not IsAuthorized(aact);
            }
        }
        Procedure InitializeUserGroupPermissions {
            Body: {
                __ASaveData 			:= 'Save Data';
                __ALoadData 			:= 'Load Data';
                __ASolve 				:= 'Solve';
                __AChangeAuthorization 	:= 'Change Authorization';
                __ADevelop 				:= 'Develop';
                __AMap					:= 'Map';
                __AMillNames			:= 'MillNames';
            }
        }
    }
    Section UserFunctions {
        Function FindAnyString {
            Arguments: (Src,Find,ReturnLastPosition);
            Range: integer;
            Body: {
                ! Searches Src for occurunce of any characters in Find
                ! if ReturnLastPosition=0, returns the position in Src of first char that also occurs in Find
                !		e.g. FindAnyString("asdbr1fgsetg","0123456789") returns 6 ... the postion of "1" in "asdbr1fgsetg"
                
                ! if ReturnLastPosition=1, searches from the end of Src and returns the position of a substring consisting
                !	endirely of characters in Find
                !		e.g. FindAnyString("ab123_234","0123456789",1) returns 7 ... the position of "234" in "ab123_234"
                
                block ! remove trailing spaces
                len := StringLength(src);
                	While SubString(src,-1,-1)=" " and len > 0 do
                		len -= 1;
                		src := SubString(src,1,len);
                	endwhile;
                endblock;
                
                
                len := StringLength(src);
                i := 1;
                pos := 0;
                
                if ReturnLastPosition then
                	pos := FindString(find,SubString(src,-i,-i));	! -1 => search from end
                	if pos > 0 then !valid character found
                		while i <= len and pos>0 do
                			i += 1;
                			pos := FindString(find,SubString(src,-i,-i));	! -1 => search from end
                		endwhile;
                		i -= 1;
                		FindAnyString := len - i + 1;
                	else
                		FindAnyString := 0;
                	endif;
                
                else
                	pos := 0;
                
                	!--- find 1st occurence in src of any character in find
                	while i <= len do
                		pos := FindString(find,SubString(src,i,i));
                		if pos > 0 then break endif;
                		i += 1;
                	endwhile;
                
                	FindAnyString := i;
                endif;
            }
            StringParameter Src {
                Property: Input;
            }
            StringParameter Find {
                Property: Input;
            }
            Parameter i;
            Parameter len {
                Range: integer;
            }
            Parameter pos;
            Parameter ReturnLastPosition {
                Property: Optional;
            }
        }
        Function GetIndexDomain {
            Arguments: (c_element,IndexOnly);
            Range: string;
            Body: {
                s := AttributeToString(c_element, 'Index Domain');
                s := SubString(s, 1, StringLength(s)-1);
                
                if IndexOnly then
                	i := FindString(s , "|");
                	if i > 0 then
                		s := SubString(s, 1, i-1);
                	endif;
                endif;
                
                GetIndexDomain := s;
            }
            ElementParameter c_element {
                Range: AllIdentifiers;
                Property: Input;
            }
            Parameter IndexOnly {
                Property: Optional;
            }
            StringParameter s;
            Parameter i;
        }
        Procedure TrimString {
            Arguments: (StringName);
            Body: {
                ! remove beginning spaces
                len := StringLength(StringName);
                While SubString(StringName,1,1)=" " do
                	StringName := SubString(StringName,2,len);
                endwhile;
                
                ! remove trailing spaces
                len := StringLength(StringName);
                While SubString(StringName,-1,-1)=" " and len > 0 do
                	len -= 1;
                	StringName := SubString(StringName,1,len);
                endwhile;
            }
            StringParameter StringName {
                Property: InOut;
            }
            Parameter len;
        }
        Procedure Test_TrimString {
            Body: {
                DialogGetString("Enter String",s);
                
                trimstring(s);
                
                DialogMessage("'" + s + "'");
            }
            StringParameter s;
        }
        Procedure Test_FindAnyString {
            Body: {
                DialogGetString("Enter String",s);
                pos := FindAnyString(s,"0123456789");
                
                if pos then
                	DialogMessage( FormatString("digit string found starting as position %n in '%s'",pos,s) );
                else
                	DialogMessage("No digitstring found");
                endif;
            }
            StringParameter s;
            Parameter pos;
        }
    }
}
